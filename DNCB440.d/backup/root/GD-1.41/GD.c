/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of GD.xs. Do not edit this file, edit GD.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "GD.xs"
#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <gd.h>
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif
/* Copyright 1995 - 1998, Lincoln D. Stein.  See accompanying README file for
        usage restrictions */

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    case 'A':
        break;
    case 'B':
        break;
    case 'C':
        break;
    case 'D':
        break;
    case 'E':
        break;
    case 'F':
        break;
    case 'G':
        if (strEQ(name, "GD_CMP_IMAGE"))
#ifdef GD_CMP_IMAGE
          return GD_CMP_IMAGE;
#else
            goto not_there;
#endif
        if (strEQ(name, "GD_CMP_NUM_COLORS"))
#ifdef GD_CMP_NUM_COLORS
          return GD_CMP_NUM_COLORS;
#else
        goto not_there;
#endif
        if (strEQ(name, "GD_CMP_COLOR"))
#ifdef GD_CMP_COLOR
          return GD_CMP_COLOR;
#else
        goto not_there;
#endif
        if (strEQ(name, "GD_CMP_SIZE_X"))
#ifdef GD_CMP_SIZE_X
          return GD_CMP_SIZE_X;
#else
        goto not_there;
#endif
        if (strEQ(name, "GD_CMP_SIZE_Y"))
#ifdef GD_CMP_SIZE_Y
          return GD_CMP_SIZE_Y;
#else
        goto not_there;
#endif
        if (strEQ(name, "GD_CMP_TRANSPARENT"))
#ifdef GD_CMP_TRANSPARENT
          return GD_CMP_TRANSPARENT;
#else
        goto not_there;
#endif
        if (strEQ(name, "GD_CMP_BACKGROUND"))
#ifdef GD_CMP_BACKGROUND
          return GD_CMP_BACKGROUND;
#else
        goto not_there;
#endif
        if (strEQ(name, "GD_CMP_INTERLACE"))
#ifdef GD_CMP_INTERLACE
          return GD_CMP_INTERLACE;
#else
        goto not_there;
#endif
        break;
    case 'H':
        break;
    case 'I':
        break;
    case 'J':
        break;
    case 'K':
        break;
    case 'L':
        break;
    case 'M':
        break;
    case 'N':
        break;
    case 'O':
        break;
    case 'P':
        break;
    case 'Q':
        break;
    case 'R':
        break;
    case 'S':
        break;
    case 'T':
        break;
    case 'U':
        break;
    case 'V':
        break;
    case 'W':
        break;
    case 'X':
        break;
    case 'Y':
        break;
    case 'Z':
        break;
    case 'a':
        break;
    case 'b':
        break;
    case 'c':
        break;
    case 'd':
        break;
    case 'e':
        break;
    case 'f':
        break;
    case 'g':
        if (strEQ(name, "gdBrushed"))
#ifdef gdBrushed
            return gdBrushed;
#else
            goto not_there;
#endif
        if (strEQ(name, "gdDashSize"))
#ifdef gdDashSize
            return gdDashSize;
#else
            goto not_there;
#endif
        if (strEQ(name, "gdMaxColors"))
#ifdef gdMaxColors
            return gdMaxColors;
#else
            goto not_there;
#endif
        if (strEQ(name, "gdStyled"))
#ifdef gdStyled
            return gdStyled;
#else
            goto not_there;
#endif
        if (strEQ(name, "gdStyledBrushed"))
#ifdef gdStyledBrushed
            return gdStyledBrushed;
#else
            goto not_there;
#endif
        if (strEQ(name, "gdTiled"))
#ifdef gdTiled
            return gdTiled;
#else
            goto not_there;
#endif
        if (strEQ(name, "gdTransparent"))
#ifdef gdTransparent
            return gdTransparent;
#else
            goto not_there;
#endif
        break;
    case 'h':
        break;
    case 'i':
        break;
    case 'j':
        break;
    case 'k':
        break;
    case 'l':
        break;
    case 'm':
        break;
    case 'n':
        break;
    case 'o':
        break;
    case 'p':
        break;
    case 'q':
        break;
    case 'r':
        break;
    case 's':
        break;
    case 't':
        break;
    case 'u':
        break;
    case 'v':
        break;
    case 'w':
        break;
    case 'x':
        break;
    case 'y':
        break;
    case 'z':
        break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

typedef gdImagePtr      GD__Image;
typedef gdFontPtr       GD__Font;
typedef PerlIO          * InputStream;
extern  gdFontPtr       gdFontGiant;
extern  gdFontPtr       gdFontLarge;
extern  gdFontPtr       gdFontSmall;
extern  gdFontPtr       gdFontMediumBold;
extern  gdFontPtr       gdFontTiny;

#ifdef PERL_OBJECT
#  ifdef WIN32
#define GDIMAGECREATEFROMGIF(x) gdImageCreateFromGif((FILE*)x)
#define GDIMAGECREATEFROMPNG(x) gdImageCreateFromPng((FILE*)x)
#define GDIMAGECREATEFROMXBM(x) gdImageCreateFromXbm((FILE*)x)
#define GDIMAGECREATEFROMJPEG(x) gdImageCreateFromJpeg((FILE*)x)
#define GDIMAGECREATEFROMWBMP(x) gdImageCreateFromWBMP((FILE*)x)
#define GDIMAGECREATEFROMGD(x) gdImageCreateFromGd((FILE*)x)
#define GDIMAGECREATEFROMGD2(x) gdImageCreateFromGd2((FILE*)x)
#define GDIMAGECREATEFROMGD2PART(x,a,b,c,d) gdImageCreateFromGd2Part((FILE*)x,a,b,c,d)
#  endif
#else
#  ifdef USE_PERLIO
#define GDIMAGECREATEFROMGIF(x) gdImageCreateFromGif(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMPNG(x) gdImageCreateFromPng(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMXBM(x) gdImageCreateFromXbm(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMJPEG(x) gdImageCreateFromJpeg(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMWBMP(x) gdImageCreateFromWBMP(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGD(x) gdImageCreateFromGd(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGD2(x) gdImageCreateFromGd2(PerlIO_findFILE(x))
#define GDIMAGECREATEFROMGD2PART(x,a,b,c,d) gdImageCreateFromGd2Part(PerlIO_findFILE(x),a,b,c,d)
#  else
#define GDIMAGECREATEFROMGIF(x) gdImageCreateFromGif(x)
#define GDIMAGECREATEFROMPNG(x) gdImageCreateFromPng(x)
#define GDIMAGECREATEFROMXBM(x) gdImageCreateFromXbm(x)
#define GDIMAGECREATEFROMJPEG(x) gdImageCreateFromJpeg(x)
#define GDIMAGECREATEFROMWBMP(x) gdImageCreateFromWBMP(x)
#define GDIMAGECREATEFROMGD(x) gdImageCreateFromGd(x)
#define GDIMAGECREATEFROMGD2(x) gdImageCreateFromGd2(x)
#define GDIMAGECREATEFROMGD2PART(x,a,b,c,d) gdImageCreateFromGd2Part(x,a,b,c,d)
#  endif
#endif

/* definitions required to create images from in-memory buffers */
                     
typedef struct bufIOCtx {
  gdIOCtx    ctx;
  char*      data;
  int        length;
  int        pos;
} bufIOCtx;

typedef struct bufIOCtx *bufIOCtxPtr;

static int bufGetC (gdIOCtxPtr ctx) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;

  if (bctx->pos >= bctx->length) return EOF;
  return bctx->data[bctx->pos];
}

static int bufGetBuf (gdIOCtxPtr ctx, void* buf, int len) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;
  int remain,rlen;

  remain = bctx->length - bctx->pos;
  if (remain >= len) {
    rlen = len;
  } else {
    if (remain <= 0) return EOF;
    rlen = remain;
  }
  memcpy(buf,(void*)(bctx->data + bctx->pos),rlen);
  bctx->pos += rlen;
  return rlen;
}

static int bufSeek (gdIOCtxPtr ctx, const int pos) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;
  bctx->pos = pos;
  if (bctx->pos > bctx->length)
    bctx->pos = bctx->length;
  return TRUE;
}

static long bufTell (gdIOCtxPtr ctx) {
  bufIOCtxPtr bctx = (bufIOCtxPtr) ctx;
  return bctx->pos;
}

static void bufFree(gdIOCtxPtr ctx) {
  Safefree(ctx);
}

static gdIOCtx* newDynamicCtx (char* data, int length) {
  bufIOCtxPtr   ctx;
  
  Newz(0,ctx,1,bufIOCtx);
  if (ctx == NULL) return NULL;
  ctx->data   = data;
  ctx->pos    = 0;
  ctx->length = length;

  ctx->ctx.getC   = bufGetC;
  ctx->ctx.getBuf = bufGetBuf;
  ctx->ctx.seek   = bufSeek;
  ctx->ctx.tell   = bufTell;
  ctx->ctx.free   = bufFree;
  ctx->ctx.putC   = NULL;
  ctx->ctx.putBuf = NULL;
  return (gdIOCtx*)ctx;
}

#line 358 "GD.c"
XS(XS_GD_constant)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::constant(name, arg)");
    {
	char *	name = (char *)SvPV(ST(0),PL_na);
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__new)
{
    dXSARGS;
    if (items < 0 || items > 3)
	Perl_croak(aTHX_ "Usage: GD::Image::_new(packname=\"GD::Image\", x=64, y=64)");
    {
	char *	packname;
	int	x;
	int	y;
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}

	if (items < 2)
	    x = 64;
	else {
	    x = (int)SvIV(ST(1));
	}

	if (items < 3)
	    y = 64;
	else {
	    y = (int)SvIV(ST(2));
	}
#line 364 "GD.xs"
        {
                gdImagePtr theImage;
                theImage = gdImageCreate(x,y);
                RETVAL = theImage;
        }
#line 410 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromPng)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromPng(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 378 "GD.xs"
        RETVAL = (GD__Image) GDIMAGECREATEFROMPNG(filehandle);
#line 434 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromPngData)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromPngData(packname=\"GD::Image\", imageData)");
    {
	char *	packname;
	SV *	imageData = ST(1);
#line 388 "GD.xs"
          gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#line 453 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 392 "GD.xs"
        data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
        RETVAL = (GD__Image) gdImageCreateFromPngCtx(ctx);
        (ctx->free)(ctx);
#line 466 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromGdData)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromGdData(packname=\"GD::Image\", imageData)");
    {
	char *	packname;
	SV *	imageData = ST(1);
#line 405 "GD.xs"
          gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#line 485 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 409 "GD.xs"
        data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
        RETVAL = (GD__Image) gdImageCreateFromGdCtx(ctx);
        (ctx->free)(ctx);
#line 498 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromGd2Data)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromGd2Data(packname=\"GD::Image\", imageData)");
    {
	char *	packname;
	SV *	imageData = ST(1);
#line 422 "GD.xs"
          gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#line 517 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 426 "GD.xs"
        data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
        RETVAL = (GD__Image) gdImageCreateFromGd2Ctx(ctx);
        (ctx->free)(ctx);
#line 530 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromGifData)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromGifData(packname=\"GD::Image\", imageData)");
    {
	char *	packname;
	SV *	imageData = ST(1);
#line 439 "GD.xs"
          gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
          SV* errormsg;
#line 550 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 444 "GD.xs"
#ifdef HAVE_GIF
        data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
        RETVAL = (GD__Image) gdImageCreateFromGifCtx(ctx);
        ctx->free(ctx);
#else
    errormsg = perl_get_sv("@",0);
    sv_setpv(errormsg,"libgd was not built with gif support\n");
    XSRETURN_EMPTY;
#endif
#line 569 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromJpegData)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromJpegData(packname=\"GD::Image\", imageData)");
    {
	char *	packname;
	SV *	imageData = ST(1);
#line 463 "GD.xs"
          gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
          SV* errormsg;
#line 589 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 468 "GD.xs"
#ifdef HAVE_JPEG
        data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
        RETVAL = (GD__Image) gdImageCreateFromJpegCtx(ctx);
        (ctx->free)(ctx);
#else
        errormsg = perl_get_sv("@",0);
        sv_setpv(errormsg,"libgd was not built with jpeg support\n");
        XSRETURN_EMPTY;
#endif
#line 608 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromWBMPData)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromWBMPData(packname=\"GD::Image\", imageData)");
    {
	char *	packname;
	SV *	imageData = ST(1);
#line 487 "GD.xs"
          gdIOCtx* ctx;
          char*    data;
          STRLEN   len;
#line 627 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 491 "GD.xs"
        data = SvPV(imageData,len);
        ctx = newDynamicCtx(data,len);
        RETVAL = (GD__Image) gdImageCreateFromWBMPCtx(ctx);
        (ctx->free)(ctx);
#line 640 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromGif)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromGif(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
#line 504 "GD.xs"
                SV* errormsg;
#line 657 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 506 "GD.xs"
#ifdef HAVE_GIF
        RETVAL = (GD__Image) GDIMAGECREATEFROMGIF(filehandle);
#else
    errormsg = perl_get_sv("@",0);
    sv_setpv(errormsg,"libgd was not built with gif support\n");
    XSRETURN_EMPTY;
#endif
#line 673 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromXbm)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromXbm(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 522 "GD.xs"
        RETVAL = GDIMAGECREATEFROMXBM(filehandle);
#line 697 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromGd)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromGd(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 532 "GD.xs"
        RETVAL = GDIMAGECREATEFROMGD(filehandle);
#line 721 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromGd2)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromGd2(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 542 "GD.xs"
        RETVAL = GDIMAGECREATEFROMGD2(filehandle);
#line 745 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromJpeg)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromJpeg(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
#line 552 "GD.xs"
          gdImagePtr img;
          SV* errormsg;
#line 763 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 555 "GD.xs"
#ifdef HAVE_JPEG
        img = GDIMAGECREATEFROMJPEG(filehandle);
        if (img == NULL) {
          errormsg = perl_get_sv("@",0);
          if (errormsg != NULL)
            sv_setpv(errormsg,"libgd was not built with jpeg support\n");
          XSRETURN_EMPTY;
        }
        RETVAL = img;
#else
        errormsg = perl_get_sv("@",0);
        sv_setpv(errormsg,"libgd was not built with jpeg support\n");
        XSRETURN_EMPTY;
#endif
#line 786 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromWBMP)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromWBMP(packname=\"GD::Image\", filehandle)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
#line 578 "GD.xs"
          gdImagePtr img;
          SV* errormsg;
#line 804 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 581 "GD.xs"
        img = GDIMAGECREATEFROMWBMP(filehandle);
        if (img == NULL) {
          errormsg = perl_get_sv("@",0);
          if (errormsg != NULL)
            sv_setpv(errormsg,"libgd was not built with WBMP support\n");
          XSRETURN_EMPTY;
        }
        RETVAL = img;
#line 821 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_newFromXpm)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::newFromXpm(packname=\"GD::Image\", filename)");
    {
	char *	packname;
	char *	filename = (char *)SvPV(ST(1),PL_na);
#line 598 "GD.xs"
          gdImagePtr img;
          SV* errormsg;
#line 839 "GD.c"
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 601 "GD.xs"
#ifdef HAVE_XPM
        img = gdImageCreateFromXpm(filename);
        if (img == NULL) {
            errormsg = perl_get_sv("@",0);
            if (errormsg != NULL)
              sv_setpv(errormsg,"libgd was not built with xpm support\n");
            XSRETURN_EMPTY;
        }
        RETVAL = img;
#else
        errormsg = perl_get_sv("@",0);
        sv_setpv(errormsg,"libgd was not built with xpm support\n");
        XSRETURN_EMPTY;
#endif
#line 862 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image__newFromGd2Part)
{
    dXSARGS;
    if (items < 5 || items > 6)
	Perl_croak(aTHX_ "Usage: GD::Image::_newFromGd2Part(packname=\"GD::Image\", filehandle, srcX, srcY, width, height)");
    {
	char *	packname;
	InputStream	filehandle = IoIFP(sv_2io(ST(1)));
	int	srcX = (int)SvIV(ST(2));
	int	srcY = (int)SvIV(ST(3));
	int	width = (int)SvIV(ST(4));
	int	height = (int)SvIV(ST(5));
	GD__Image	RETVAL;

	if (items < 1)
	    packname = "GD::Image";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 628 "GD.xs"
        RETVAL = GDIMAGECREATEFROMGD2PART(filehandle,srcX,srcY,width,height);
#line 890 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Image", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::DESTROY(image)");
    {
	GD__Image	image;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not a reference");
#line 637 "GD.xs"
        {
                gdImageDestroy(image);
        }
#line 915 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_png)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::png(image)");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 646 "GD.xs"
  {
        void*         data;
        int           size;
        data = (void *) gdImagePngPtr(image,&size);
        RETVAL = newSVpv((char*) data,size);
        gdFree(data);
  }
#line 943 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_gif)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::gif(image)");
    {
	GD__Image	image;
#line 661 "GD.xs"
    SV* errormsg;
#line 959 "GD.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 663 "GD.xs"
  {
        void*         data;
        int           size;
#ifdef HAVE_GIF
        data = (void *) gdImageGifPtr(image,&size);
        RETVAL = newSVpv((char*) data,size);
        free(data);
#else
        errormsg = perl_get_sv("@",0);
        sv_setpv(errormsg,"libgd was not built with gif support\n");
        XSRETURN_EMPTY;
#endif
  }
#line 982 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_jpeg)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: GD::Image::jpeg(image, quality=-1)");
    {
	GD__Image	image;
	int	quality;
#line 685 "GD.xs"
  SV* errormsg;
#line 999 "GD.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (items < 2)
	    quality = -1;
	else {
	    quality = (int)SvIV(ST(1));
	}
#line 687 "GD.xs"
  {
        void*         data;
        int           size;
#ifdef HAVE_JPEG
        data = (void *) gdImageJpegPtr(image,&size,quality);
        if (data == NULL) {
          errormsg = perl_get_sv("@",0);
          if (errormsg != NULL)
            sv_setpv(errormsg,"libgd was not built with jpeg support\n");
          XSRETURN_EMPTY;
        }
        RETVAL = newSVpv((char*) data,size);
        gdFree(data);
#else
        errormsg = perl_get_sv("@",0);
        sv_setpv(errormsg,"libgd was not built with jpeg support\n");
        XSRETURN_EMPTY;
#endif
  }
#line 1034 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_wbmp)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::wbmp(image, fg)");
    {
	GD__Image	image;
	int	fg = (int)SvIV(ST(1));
#line 715 "GD.xs"
  SV* errormsg;
#line 1051 "GD.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 717 "GD.xs"
  {
        void*         data;
        int           size;
        data = (void *) gdImageWBMPPtr(image,&size,fg);
        if (data == NULL) {
          errormsg = perl_get_sv("@",0);
          if (errormsg != NULL)
            sv_setpv(errormsg,"libgd was not built with WBMP support\n");
          XSRETURN_EMPTY;
        }
        RETVAL = newSVpv((char*) data,size);
        gdFree(data);
  }
#line 1074 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_gd)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::gd(image)");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 738 "GD.xs"
  {
        void*         data;
        int           size;
        data = gdImageGdPtr(image,&size);
        RETVAL = newSVpv((char*) data,size);
        gdFree(data);
  }
#line 1104 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_gd2)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::gd2(image)");
    {
	GD__Image	image;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 753 "GD.xs"
  {
        void*         data;
        int           size;
        data = gdImageGd2Ptr(image,0,GD2_FMT_COMPRESSED,&size);
        RETVAL = newSVpv((char*) data,size);
        gdFree(data);
  }
#line 1134 "GD.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_GD__Image_transparent)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: GD::Image::transparent(image, ...)");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 768 "GD.xs"
        {
                int color;
                if (items > 1) {
                        color=(int)SvIV(ST(1));
                        gdImageColorTransparent(image,color);
                }
                RETVAL = gdImageGetTransparent(image);
        }
#line 1166 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_getBounds)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::getBounds(image)");
    SP -= items;
    {
	GD__Image	image;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 784 "GD.xs"
        {
                int sx,sy;
                sx = gdImageSX(image);
                sy = gdImageSY(image);
                EXTEND(sp,2);
                PUSHs(sv_2mortal(newSViv(sx)));
                PUSHs(sv_2mortal(newSViv(sy)));
        }
#line 1196 "GD.c"
	PUTBACK;
	return;
    }
}

XS(XS_GD__Image_rgb)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::rgb(image, color)");
    SP -= items;
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 799 "GD.xs"
        {
                int r,g,b;
                r = gdImageRed(image,color);
                g = gdImageGreen(image,color);
                b = gdImageBlue(image,color);
                EXTEND(sp,3);
                PUSHs(sv_2mortal(newSViv(r)));
                PUSHs(sv_2mortal(newSViv(g)));
                PUSHs(sv_2mortal(newSViv(b)));
        }
#line 1229 "GD.c"
	PUTBACK;
	return;
    }
}

XS(XS_GD__Image_boundsSafe)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::boundsSafe(image, x, y)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 817 "GD.xs"
        {
                RETVAL=gdImageBoundsSafe(image,x,y);
        }
#line 1257 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_getPixel)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::getPixel(image, x, y)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 830 "GD.xs"
        {
                RETVAL=gdImageGetPixel(image,x,y);
        }
#line 1285 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_setPixel)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::setPixel(image, x, y, color)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	color = (int)SvIV(ST(3));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 844 "GD.xs"
        {
                gdImageSetPixel(image,x,y,color);
        }
#line 1312 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_line)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::line(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 858 "GD.xs"
        {
                gdImageLine(image,x1,y1,x2,y2,color);
        }
#line 1340 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_dashedLine)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::dashedLine(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 872 "GD.xs"
        {
                gdImageDashedLine(image,x1,y1,x2,y2,color);
        }
#line 1368 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_openPolygon)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::openPolygon(image, poly, color)");
    {
	GD__Image	image;
	SV *	poly = ST(1);
	int	color = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 883 "GD.xs"
        {
                dSP ;
                int length,count ;
                int x,y,i ;
                gdPointPtr polyptr;

                ENTER ;
                SAVETMPS ;
                PUSHMARK(sp) ;
                XPUSHs(poly) ;
                PUTBACK ;
                count = perl_call_method("length",G_SCALAR) ;
                SPAGAIN ;
                if (count != 1)
                        croak("Didn't get a single result from GD::Poly::length() call.\n");
                length = POPi ;
                PUTBACK ;
                FREETMPS ;
                LEAVE ;

                polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
                if (polyptr == NULL)
                        croak("safemalloc() returned NULL in GD::Image::poly().\n");

                for (i=0;i<length;i++) {
                        ENTER ;
                        SAVETMPS ;
                        PUSHMARK(sp) ;
                        XPUSHs(poly) ;
                        XPUSHs(sv_2mortal(newSViv(i))) ;
                        PUTBACK ;
                        count = perl_call_method("getPt",G_ARRAY) ;
                        SPAGAIN ;
                        if (count != 2)
                                croak("Didn't get a single result from GD::Poly::length() call.\n");
                        y = POPi ;
                        x = POPi ;
                        PUTBACK ;
                        FREETMPS ;
                        LEAVE ;

                        polyptr[i].x = x;
                        polyptr[i].y = y;
                }

                gdImagePolygon(image,polyptr,length,color);
                safefree((char*) polyptr);
        }
#line 1438 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_filledPolygon)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: GD::Image::filledPolygon(image, poly, color)");
    {
	GD__Image	image;
	SV *	poly = ST(1);
	int	color = (int)SvIV(ST(2));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 939 "GD.xs"
        {
                dSP ;
                int length,count ;
                int x,y,i ;
                gdPointPtr polyptr;

                ENTER ;
                SAVETMPS ;
                PUSHMARK(sp) ;
                XPUSHs(poly) ;
                PUTBACK ;
                count = perl_call_method("length",G_SCALAR) ;
                SPAGAIN ;
                if (count != 1)
                        croak("Didn't get a single result from GD::Poly::length() call.\n");
                length = POPi ;
                PUTBACK ;
                FREETMPS ;
                LEAVE ;

                polyptr = (gdPointPtr)safemalloc(sizeof(gdPoint)*length);
                if (polyptr == NULL)
                        croak("safemalloc() returned NULL in GD::Image::poly().\n");

                for (i=0;i<length;i++) {
                        ENTER ;
                        SAVETMPS ;
                        PUSHMARK(sp) ;
                        XPUSHs(poly) ;
                        XPUSHs(sv_2mortal(newSViv(i))) ;
                        PUTBACK ;
                        count = perl_call_method("getPt",G_ARRAY) ;
                        SPAGAIN ;
                        if (count != 2)
                                croak("Didn't get a single result from GD::Poly::length() call.\n");
                        y = POPi ;
                        x = POPi ;
                        PUTBACK ;
                        FREETMPS ;
                        LEAVE ;

                        polyptr[i].x = x;
                        polyptr[i].y = y;
                }

                gdImageFilledPolygon(image,polyptr,length,color);
                safefree((char*) polyptr);
        }
#line 1508 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_rectangle)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::rectangle(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 998 "GD.xs"
        {
                gdImageRectangle(image,x1,y1,x2,y2,color);
        }
#line 1536 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_filledRectangle)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::filledRectangle(image, x1, y1, x2, y2, color)");
    {
	GD__Image	image;
	int	x1 = (int)SvIV(ST(1));
	int	y1 = (int)SvIV(ST(2));
	int	x2 = (int)SvIV(ST(3));
	int	y2 = (int)SvIV(ST(4));
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1012 "GD.xs"
        {
                gdImageFilledRectangle(image,x1,y1,x2,y2,color);
        }
#line 1564 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_arc)
{
    dXSARGS;
    if (items != 8)
	Perl_croak(aTHX_ "Usage: GD::Image::arc(image, cx, cy, w, h, s, e, color)");
    {
	GD__Image	image;
	int	cx = (int)SvIV(ST(1));
	int	cy = (int)SvIV(ST(2));
	int	w = (int)SvIV(ST(3));
	int	h = (int)SvIV(ST(4));
	int	s = (int)SvIV(ST(5));
	int	e = (int)SvIV(ST(6));
	int	color = (int)SvIV(ST(7));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1028 "GD.xs"
        {
                gdImageArc(image,cx,cy,w,h,s,e,color);
        }
#line 1594 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_fillToBorder)
{
    dXSARGS;
    if (items != 5)
	Perl_croak(aTHX_ "Usage: GD::Image::fillToBorder(image, x, y, border, color)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	border = (int)SvIV(ST(3));
	int	color = (int)SvIV(ST(4));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1041 "GD.xs"
        {
                gdImageFillToBorder(image,x,y,border,color);
        }
#line 1621 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_fill)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::fill(image, x, y, color)");
    {
	GD__Image	image;
	int	x = (int)SvIV(ST(1));
	int	y = (int)SvIV(ST(2));
	int	color = (int)SvIV(ST(3));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1053 "GD.xs"
        {
                gdImageFill(image,x,y,color);
        }
#line 1647 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_setBrush)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::setBrush(image, brush)");
    {
	GD__Image	image;
	GD__Image	brush;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    brush = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("brush is not of type GD::Image");
#line 1063 "GD.xs"
        {
                gdImageSetBrush(image,brush);
        }
#line 1678 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_setTile)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::setTile(image, tile)");
    {
	GD__Image	image;
	GD__Image	tile;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tile = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("tile is not of type GD::Image");
#line 1073 "GD.xs"
        {
                gdImageSetTile(image,tile);
        }
#line 1709 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_setStyle)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: GD::Image::setStyle(image, ...)");
    {
	GD__Image	image;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1082 "GD.xs"
        {
                int     *style;
                int     i;

                if (items < 2)
                        return;
                style = (int*) safemalloc(sizeof(int)*(items-1));
                if (style == NULL)
                        croak("malloc returned NULL at setStyle().\n");
                for(i=1;i<items;i++) {
                        style[i-1]=(int)SvIV(ST(i));
                }
                gdImageSetStyle(image,style,items-1);
                safefree((char*) style);
        }
#line 1744 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_colorAllocate)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorAllocate(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1106 "GD.xs"
        {
                RETVAL = gdImageColorAllocate(image,r,g,b);
        }
#line 1772 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorClosest)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorClosest(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1120 "GD.xs"
        {
                RETVAL = gdImageColorClosest(image,r,g,b);
        }
#line 1801 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorClosestHWB)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorClosestHWB(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1134 "GD.xs"
        {
                RETVAL = gdImageColorClosestHWB(image,r,g,b);
        }
#line 1830 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorExact)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorExact(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1148 "GD.xs"
        {
                RETVAL = gdImageColorExact(image,r,g,b);
        }
#line 1859 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorResolve)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: GD::Image::colorResolve(image, r, g, b)");
    {
	GD__Image	image;
	int	r = (int)SvIV(ST(1));
	int	g = (int)SvIV(ST(2));
	int	b = (int)SvIV(ST(3));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1162 "GD.xs"
        {
                RETVAL = gdImageColorResolve(image,r,g,b);
        }
#line 1888 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorsTotal)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Image::colorsTotal(image)");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1173 "GD.xs"
        {
                RETVAL = gdImageColorsTotal(image);
        }
#line 1914 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_interlaced)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: GD::Image::interlaced(image, ...)");
    {
	GD__Image	image;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1185 "GD.xs"
        {
                if (items > 1) {
                        if (SvOK(ST(1)))
                                gdImageInterlace(image,1);
                        else
                                gdImageInterlace(image,0);
                }
                RETVAL = gdImageGetInterlaced(image);
        }
#line 1946 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_compare)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::compare(image1, image2)");
    {
	GD__Image	image1;
	GD__Image	image2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image1 = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image1 is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    image2 = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image2 is not of type GD::Image");
#line 1203 "GD.xs"
        {
          RETVAL = gdImageCompare(image1,image2);
        }
#line 1980 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Image_colorDeallocate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::colorDeallocate(image, color)");
    {
	GD__Image	image;
	int	color = (int)SvIV(ST(1));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");
#line 1215 "GD.xs"
        {
                gdImageColorDeallocate(image,color);
        }
#line 2005 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_copy)
{
    dXSARGS;
    if (items != 8)
	Perl_croak(aTHX_ "Usage: GD::Image::copy(destination, source, dstX, dstY, srcX, srcY, w, h)");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2));
	int	dstY = (int)SvIV(ST(3));
	int	srcX = (int)SvIV(ST(4));
	int	srcY = (int)SvIV(ST(5));
	int	w = (int)SvIV(ST(6));
	int	h = (int)SvIV(ST(7));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 1231 "GD.xs"
        {
                gdImageCopy(destination,source,dstX,dstY,srcX,srcY,w,h);
        }
#line 2042 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_copyResized)
{
    dXSARGS;
    if (items != 10)
	Perl_croak(aTHX_ "Usage: GD::Image::copyResized(destination, source, dstX, dstY, srcX, srcY, destW, destH, srcW, srcH)");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2));
	int	dstY = (int)SvIV(ST(3));
	int	srcX = (int)SvIV(ST(4));
	int	srcY = (int)SvIV(ST(5));
	int	destW = (int)SvIV(ST(6));
	int	destH = (int)SvIV(ST(7));
	int	srcW = (int)SvIV(ST(8));
	int	srcH = (int)SvIV(ST(9));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 1249 "GD.xs"
        {
                gdImageCopyResized(destination,source,dstX,dstY,srcX,srcY,destW,destH,srcW,srcH);
        }
#line 2081 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_copyMerge)
{
    dXSARGS;
    if (items != 9)
	Perl_croak(aTHX_ "Usage: GD::Image::copyMerge(destination, source, dstX, dstY, srcX, srcY, w, h, pct)");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2));
	int	dstY = (int)SvIV(ST(3));
	int	srcX = (int)SvIV(ST(4));
	int	srcY = (int)SvIV(ST(5));
	int	w = (int)SvIV(ST(6));
	int	h = (int)SvIV(ST(7));
	int	pct = (int)SvIV(ST(8));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 1266 "GD.xs"
        {
                gdImageCopyMerge(destination,source,dstX,dstY,srcX,srcY,w,h,pct);
        }
#line 2119 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_copyMergeGray)
{
    dXSARGS;
    if (items != 9)
	Perl_croak(aTHX_ "Usage: GD::Image::copyMergeGray(destination, source, dstX, dstY, srcX, srcY, w, h, pct)");
    {
	GD__Image	destination;
	GD__Image	source;
	int	dstX = (int)SvIV(ST(2));
	int	dstY = (int)SvIV(ST(3));
	int	srcX = (int)SvIV(ST(4));
	int	srcY = (int)SvIV(ST(5));
	int	w = (int)SvIV(ST(6));
	int	h = (int)SvIV(ST(7));
	int	pct = (int)SvIV(ST(8));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 1283 "GD.xs"
        {
                gdImageCopyMergeGray(destination,source,dstX,dstY,srcX,srcY,w,h,pct);
        }
#line 2157 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_paletteCopy)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: GD::Image::paletteCopy(destination, source)");
    {
	GD__Image	destination;
	GD__Image	source;

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    destination = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("destination is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    source = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("source is not of type GD::Image");
#line 1293 "GD.xs"
        {
                gdImagePaletteCopy(destination,source);
        }
#line 2188 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_char)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::char(image, font, x, y, c, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	c = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1307 "GD.xs"
        {
                gdImageChar(image,font,x,y,*c,color);
        }
#line 2223 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_charUp)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::charUp(image, font, x, y, c, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	c = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1321 "GD.xs"
        {
                gdImageCharUp(image,font,x,y,*c,color);
        }
#line 2258 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_string)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::string(image, font, x, y, s, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	s = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1335 "GD.xs"
        {
                gdImageString(image,font,x,y,(unsigned char*)s,color);
        }
#line 2293 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_stringUp)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: GD::Image::stringUp(image, font, x, y, s, color)");
    {
	GD__Image	image;
	GD__Font	font;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	char *	s = (char *)SvPV(ST(4),PL_na);
	int	color = (int)SvIV(ST(5));

	if (sv_derived_from(ST(0), "GD::Image")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(GD__Image,tmp);
	}
	else
	    croak("image is not of type GD::Image");

	if (sv_derived_from(ST(1), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1349 "GD.xs"
        {
                gdImageStringUp(image,font,x,y,(unsigned char*)s,color);
        }
#line 2328 "GD.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_GD__Image_stringFT)
{
    dXSARGS;
    if (items != 8)
	Perl_croak(aTHX_ "Usage: GD::Image::stringFT(image, fgcolor, fontname, ptsize, angle, x, y, string)");
    SP -= items;
    {
	SV *	image = ST(0);
	int	fgcolor = (int)SvIV(ST(1));
	char *	fontname = (char *)SvPV(ST(2),PL_na);
	double	ptsize = (double)SvNV(ST(3));
	double	angle = (double)SvNV(ST(4));
	int	x = (int)SvIV(ST(5));
	int	y = (int)SvIV(ST(6));
	char *	string = (char *)SvPV(ST(7),PL_na);
#line 1365 "GD.xs"
          gdImagePtr img;
          int brect[8];
          char *err;
          SV* errormsg;
          int i;
#line 2354 "GD.c"
#line 1371 "GD.xs"
        {
          if (sv_isobject(image) && sv_derived_from(image, "GD::Image")) {
            IV tmp = SvIV((SV*)SvRV(image));
            img = (gdImagePtr) tmp;
          } else {
            img = NULL;
          }

          err = gdImageStringFT(img,brect,fgcolor,fontname,ptsize,angle,x,y,string);
          if (err) {
            errormsg = perl_get_sv("@",0);
            if (errormsg != NULL)
              sv_setpv(errormsg,err);
            XSRETURN_EMPTY;
          } else {
            EXTEND(sp,8);
            for (i=0;i<8;i++) {
              PUSHs(sv_2mortal(newSViv(brect[i])));
            }
          }

        }
#line 2378 "GD.c"
	PUTBACK;
	return;
    }
}

XS(XS_GD__Font_Small)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Small(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 1401 "GD.xs"
        {
                RETVAL = gdFontSmall;
        }
#line 2402 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_Large)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Large(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 1412 "GD.xs"
        {
                RETVAL = gdFontLarge;
        }
#line 2427 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_Giant)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Giant(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 1423 "GD.xs"
        {
                RETVAL = gdFontGiant;
        }
#line 2452 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_MediumBold)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::MediumBold(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 1434 "GD.xs"
        {
                RETVAL = gdFontMediumBold;
        }
#line 2477 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_Tiny)
{
    dXSARGS;
    if (items < 0 || items > 1)
	Perl_croak(aTHX_ "Usage: GD::Font::Tiny(packname=\"GD::Font\")");
    {
	char *	packname;
	GD__Font	RETVAL;

	if (items < 1)
	    packname = "GD::Font";
	else {
	    packname = (char *)SvPV(ST(0),PL_na);
	}
#line 1445 "GD.xs"
        {
                RETVAL = gdFontTiny;
        }
#line 2502 "GD.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GD::Font", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_nchars)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::nchars(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1456 "GD.xs"
        {
                RETVAL = font->nchars;
        }
#line 2529 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_offset)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::offset(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1467 "GD.xs"
        {
                RETVAL = font->offset;
        }
#line 2555 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_width)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::width(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1478 "GD.xs"
        {
                RETVAL = font->w;
        }
#line 2581 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_GD__Font_height)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: GD::Font::height(font)");
    {
	GD__Font	font;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GD::Font")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    font = INT2PTR(GD__Font,tmp);
	}
	else
	    croak("font is not of type GD::Font");
#line 1489 "GD.xs"
        {
                RETVAL = font->h;
        }
#line 2607 "GD.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_GD)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("GD::constant", XS_GD_constant, file);
        newXSproto("GD::Image::_new", XS_GD__Image__new, file, "$;$$");
        newXSproto("GD::Image::_newFromPng", XS_GD__Image__newFromPng, file, "$$");
        newXSproto("GD::Image::newFromPngData", XS_GD__Image_newFromPngData, file, "$$");
        newXSproto("GD::Image::newFromGdData", XS_GD__Image_newFromGdData, file, "$$");
        newXSproto("GD::Image::newFromGd2Data", XS_GD__Image_newFromGd2Data, file, "$$");
        newXSproto("GD::Image::newFromGifData", XS_GD__Image_newFromGifData, file, "$$");
        newXSproto("GD::Image::newFromJpegData", XS_GD__Image_newFromJpegData, file, "$$");
        newXSproto("GD::Image::newFromWBMPData", XS_GD__Image_newFromWBMPData, file, "$$");
        newXSproto("GD::Image::_newFromGif", XS_GD__Image__newFromGif, file, "$$");
        newXSproto("GD::Image::_newFromXbm", XS_GD__Image__newFromXbm, file, "$$");
        newXSproto("GD::Image::_newFromGd", XS_GD__Image__newFromGd, file, "$$");
        newXSproto("GD::Image::_newFromGd2", XS_GD__Image__newFromGd2, file, "$$");
        newXSproto("GD::Image::_newFromJpeg", XS_GD__Image__newFromJpeg, file, "$$");
        newXSproto("GD::Image::_newFromWBMP", XS_GD__Image__newFromWBMP, file, "$$");
        newXSproto("GD::Image::newFromXpm", XS_GD__Image_newFromXpm, file, "$$");
        newXSproto("GD::Image::_newFromGd2Part", XS_GD__Image__newFromGd2Part, file, "$$");
        newXSproto("GD::Image::DESTROY", XS_GD__Image_DESTROY, file, "$");
        newXSproto("GD::Image::png", XS_GD__Image_png, file, "$");
        newXSproto("GD::Image::gif", XS_GD__Image_gif, file, "$");
        newXSproto("GD::Image::jpeg", XS_GD__Image_jpeg, file, "$");
        newXSproto("GD::Image::wbmp", XS_GD__Image_wbmp, file, "$");
        newXSproto("GD::Image::gd", XS_GD__Image_gd, file, "$");
        newXSproto("GD::Image::gd2", XS_GD__Image_gd2, file, "$");
        newXSproto("GD::Image::transparent", XS_GD__Image_transparent, file, "$;$");
        newXSproto("GD::Image::getBounds", XS_GD__Image_getBounds, file, "$");
        newXSproto("GD::Image::rgb", XS_GD__Image_rgb, file, "$$");
        newXSproto("GD::Image::boundsSafe", XS_GD__Image_boundsSafe, file, "$$$");
        newXSproto("GD::Image::getPixel", XS_GD__Image_getPixel, file, "$$$");
        newXSproto("GD::Image::setPixel", XS_GD__Image_setPixel, file, "$$$");
        newXSproto("GD::Image::line", XS_GD__Image_line, file, "$$$$$$");
        newXSproto("GD::Image::dashedLine", XS_GD__Image_dashedLine, file, "$$$$$$");
        newXSproto("GD::Image::openPolygon", XS_GD__Image_openPolygon, file, "$$$");
        newXSproto("GD::Image::filledPolygon", XS_GD__Image_filledPolygon, file, "$$$");
        newXSproto("GD::Image::rectangle", XS_GD__Image_rectangle, file, "$$$$$$");
        newXSproto("GD::Image::filledRectangle", XS_GD__Image_filledRectangle, file, "$$$$$$");
        newXSproto("GD::Image::arc", XS_GD__Image_arc, file, "$$$$$$$$");
        newXSproto("GD::Image::fillToBorder", XS_GD__Image_fillToBorder, file, "$$$$$");
        newXSproto("GD::Image::fill", XS_GD__Image_fill, file, "$$$$");
        newXSproto("GD::Image::setBrush", XS_GD__Image_setBrush, file, "$$");
        newXSproto("GD::Image::setTile", XS_GD__Image_setTile, file, "$$");
        newXSproto("GD::Image::setStyle", XS_GD__Image_setStyle, file, "$;$");
        newXSproto("GD::Image::colorAllocate", XS_GD__Image_colorAllocate, file, "$$$$");
        newXSproto("GD::Image::colorClosest", XS_GD__Image_colorClosest, file, "$$$$");
        newXSproto("GD::Image::colorClosestHWB", XS_GD__Image_colorClosestHWB, file, "$$$$");
        newXSproto("GD::Image::colorExact", XS_GD__Image_colorExact, file, "$$$$");
        newXSproto("GD::Image::colorResolve", XS_GD__Image_colorResolve, file, "$$$$");
        newXSproto("GD::Image::colorsTotal", XS_GD__Image_colorsTotal, file, "$");
        newXSproto("GD::Image::interlaced", XS_GD__Image_interlaced, file, "$;$");
        newXSproto("GD::Image::compare", XS_GD__Image_compare, file, "$$");
        newXSproto("GD::Image::colorDeallocate", XS_GD__Image_colorDeallocate, file, "$$");
        newXSproto("GD::Image::copy", XS_GD__Image_copy, file, "$$$$$$$$");
        newXSproto("GD::Image::copyResized", XS_GD__Image_copyResized, file, "$$$$$$$$$$");
        newXSproto("GD::Image::copyMerge", XS_GD__Image_copyMerge, file, "$$$$$$$$$");
        newXSproto("GD::Image::copyMergeGray", XS_GD__Image_copyMergeGray, file, "$$$$$$$$$");
        newXSproto("GD::Image::paletteCopy", XS_GD__Image_paletteCopy, file, "$$");
        newXSproto("GD::Image::char", XS_GD__Image_char, file, "$$$$$$");
        newXSproto("GD::Image::charUp", XS_GD__Image_charUp, file, "$$$$$$");
        newXSproto("GD::Image::string", XS_GD__Image_string, file, "$$$$$$");
        newXSproto("GD::Image::stringUp", XS_GD__Image_stringUp, file, "$$$$$$");
        newXSproto("GD::Image::stringFT", XS_GD__Image_stringFT, file, "$$$$$$$$");
        newXSproto("GD::Font::Small", XS_GD__Font_Small, file, "$");
        newXSproto("GD::Font::Large", XS_GD__Font_Large, file, "$");
        newXSproto("GD::Font::Giant", XS_GD__Font_Giant, file, "$");
        newXSproto("GD::Font::MediumBold", XS_GD__Font_MediumBold, file, "$");
        newXSproto("GD::Font::Tiny", XS_GD__Font_Tiny, file, "$");
        newXSproto("GD::Font::nchars", XS_GD__Font_nchars, file, "$");
        newXSproto("GD::Font::offset", XS_GD__Font_offset, file, "$");
        newXSproto("GD::Font::width", XS_GD__Font_width, file, "$");
        newXSproto("GD::Font::height", XS_GD__Font_height, file, "$");
    XSRETURN_YES;
}

