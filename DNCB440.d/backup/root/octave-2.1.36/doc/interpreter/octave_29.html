<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from octave.texi on 1 May 2002 -->

<TITLE>GNU Octave - Control Theory</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_28.html">previous</A>, <A HREF="octave_30.html">next</A>, <A HREF="octave_44.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC176" HREF="octave_toc.html#TOC176">Control Theory</A></H1>

<P>
The Octave Control Systems Toolbox (OCST) was initially developed
by Dr. A. Scottedward Hodel 
<A HREF="mailto:a.s.hodel@eng.auburn.edu">a.s.hodel@eng.auburn.edu</A> with the assistance
of his students

<UL>
<LI>R. Bruce Tenison <A HREF="mailto:btenison@dibbs.net">btenison@dibbs.net</A>,

<LI>David C. Clem,

<LI>John E. Ingram <A HREF="mailto:John.Ingram@sea.siemans.com">John.Ingram@sea.siemans.com</A>, and

<LI>Kristi McGowan.

</UL>

<P>
This development was supported in part by NASA's Marshall Space Flight 
Center as part of an in-house CACSD environment.  Additional important 
contributions were made by Dr. Kai Mueller <A HREF="mailto:mueller@ifr.ing.tu-bs.de">mueller@ifr.ing.tu-bs.de</A>
and Jose Daniel Munoz Frias (<CODE>place.m</CODE>).

</P>
<P>
An on-line menu-driven tutorial is available via <CODE>DEMOcontrol</CODE>;
beginning OCST users should start with this program. 

</P>
<P>
@anchor{doc-DEMOcontrol}
<DL>
<DT><U>Function File:</U>  <B>DEMOcontrol</B>
<DD><A NAME="IDX987"></A>
Octave Control Systems Toolbox demo/tutorial program.  The demo
allows the user to select among several categories of OCST function:

<PRE>
octave:1&#62; DEMOcontrol
O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X
Octave Controls System Toolbox Demo

  [ 1] System representation
  [ 2] Block diagram manipulations
  [ 3] Frequency response functions
  [ 4] State space analysis functions
  [ 5] Root locus functions
  [ 6] LQG/H2/Hinfinity functions
  [ 7] End
</PRE>

<P>
Command examples are interactively run for users to observe the use
of OCST functions.
</DL>
@seealso{Demo Programs: bddemo.m, frdemo.m, analdemo.m,
moddmeo.m, rldemo.m}

</P>



<H2><A NAME="SEC177" HREF="octave_toc.html#TOC177">System Data Structure</A></H2>

<P>
The OCST stores all dynamic systems in
a single data structure format that can represent continuous systems,
discrete-systems, and mixed (hybrid) systems in state-space form, and
can also represent purely continuous/discrete systems in either
transfer function or pole-zero form. In order to
provide more flexibility in treatment of discrete/hybrid systems, the
OCST also keeps a record of which system outputs are sampled.

</P>
<P>
Octave structures are accessed with a syntax much like that used
by the C programming language.  For consistency in
use of the data structure used in the OCST, it is recommended that
the system structure access m-files be used (see section <A HREF="octave_29.html#SEC182">System Construction and Interface Functions</A>).
Some elements of the data structure are absent depending on the internal
system representation(s) used.  More than one system representation
can be used for SISO systems; the OCST m-files ensure that all representations
used are consistent with one another.

</P>
<P>
@anchor{doc-sysrepdemo}
<DL>
<DT><U>Function File:</U>  <B>sysrepdemo</B>
<DD><A NAME="IDX988"></A>
Tutorial for the use of the system data structure functions.
</DL>

</P>



<H3><A NAME="SEC178" HREF="octave_toc.html#TOC178">Variables common to all OCST system formats</A></H3>

<P>
The data structure elements (and variable types) common to all  system
representations are listed below; examples of the initialization
and use of the system data structures are given in subsequent sections and
in the online demo <CODE>DEMOcontrol</CODE>.
<DL COMPACT>

<DT><VAR>n</VAR>
<DD>
<DT><VAR>nz</VAR>
<DD>
The respective number of continuous and discrete states
in the system (scalar)

<DT><VAR>inname</VAR>
<DD>
<DT><VAR>outname</VAR>
<DD>
list of name(s) of the system input, output signal(s). (list of strings)

<DT><VAR>sys</VAR>
<DD>
System status vector.  (vector)

This vector indicates both what representation was used to initialize
the system data structure (called the primary system type) and which
other representations are currently up-to-date with the primary system
type (see section <A HREF="octave_29.html#SEC187">Data structure access functions</A>).

The value of the first element of the vector indicates the primary
system type.

<DL COMPACT>

<DT>0
<DD>
for tf form (initialized with <CODE>tf2sys</CODE> or <CODE>fir2sys</CODE>)

<DT>1
<DD>
for zp form (initialized with <CODE>zp2sys</CODE>)

<DT>2
<DD>
for ss form (initialized with <CODE>ss2sys</CODE>)
</DL>

The next three elements are boolean flags that indicate whether tf, zp,
or ss, respectively, are "up to date" (whether it is safe to use the
variables associated with these representations).  These flags are
changed when calls are made to the <CODE>sysupdate</CODE> command.

<DT><VAR>tsam</VAR>
<DD>
 Discrete time sampling period  (nonnegative scalar).
 <VAR>tsam</VAR> is set to 0 for continuous time systems.

<DT><VAR>yd</VAR>
<DD>
 Discrete-time output list (vector)

 indicates which outputs are discrete time (i.e.,
    produced by D/A converters) and which are continuous time.
    yd(ii) = 0 if output ii is continuous, = 1 if discrete.
</DL>

<P>
The remaining variables of the  system data structure are only present
if the corresponding entry of the <CODE>sys</CODE> vector is true (=1).

</P>


<H3><A NAME="SEC179" HREF="octave_toc.html#TOC179"><CODE>tf</CODE> format variables</A></H3>

<DL COMPACT>

<DT><VAR>num</VAR>
<DD>
 numerator coefficients   (vector)

<DT><VAR>den</VAR>
<DD>
 denominator coefficients   (vector)

</DL>



<H3><A NAME="SEC180" HREF="octave_toc.html#TOC180"><CODE>zp</CODE> format variables</A></H3>

<DL COMPACT>

<DT><VAR>zer</VAR>
<DD>
 system zeros   (vector)

<DT><VAR>pol</VAR>
<DD>
 system poles    (vector)

<DT><VAR>k</VAR>
<DD>
 leading coefficient   (scalar)

</DL>



<H3><A NAME="SEC181" HREF="octave_toc.html#TOC181"><CODE>ss</CODE> format variables</A></H3>

<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<DT><VAR>b</VAR>
<DD>
<DT><VAR>c</VAR>
<DD>
<DT><VAR>d</VAR>
<DD>
The usual state-space matrices. If a system has both
        continuous and discrete states, they are sorted so that
        continuous states come first, then discrete states

<STRONG>Note</STRONG> some functions (e.g., <CODE>bode</CODE>, <CODE>hinfsyn</CODE>) 
will not accept systems with both discrete and continuous states/outputs

<DT><VAR>stname</VAR>
<DD>
names of system states   (list of strings)

</DL>



<H2><A NAME="SEC182" HREF="octave_toc.html#TOC182">System Construction and Interface Functions</A></H2>

<P>
Construction and manipulations of the OCST system data structure
(see section <A HREF="octave_29.html#SEC177">System Data Structure</A>) requires attention to many details in order
to ensure that data structure contents remain consistent.  Users
are strongly encouraged to use the system interface functions
in this section.  Functions for the formatted display in of system
data structures are given in section <A HREF="octave_29.html#SEC189">System display functions</A>.

</P>



<H3><A NAME="SEC183" HREF="octave_toc.html#TOC183">Finite impulse response system interface functions</A></H3>

<P>
@anchor{doc-fir2sys}
<DL>
<DT><U>Function File:</U>  <B>fir2sys</B> <I>(<VAR>num</VAR>, <VAR>tsam</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>)</I>
<DD><A NAME="IDX989"></A>
construct a system data structure from FIR description

</P>
<P>
<STRONG>Inputs:</STRONG>
<DL COMPACT>

<DT><VAR>num</VAR>
<DD>
vector of coefficients @math{[c_0 c_1 ... c_n]}
of the SISO FIR transfer function

C(z) = c0 + c1*z^{-1} + c2*z^{-2} + ... + znz^{-n}

<DT><VAR>tsam</VAR>
<DD>
sampling time (default: 1)

<DT><VAR>inname</VAR>
<DD>
name of input signal;  may be a string or a list with a single entry.

<DT><VAR>outname</VAR>
<DD>
name of output signal; may be a string or a list with a single entry.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>sys</VAR> (system data structure)

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys = fir2sys([1 -1 2 4],0.342,"A/D input","filter output");
octave:2&#62; sysout(sys)
Input(s)
        1: A/D input

Output(s):
        1: filter output (discrete)

Sampling interval: 0.342
transfer function form:
1*z^3 - 1*z^2 + 2*z^1 + 4
-------------------------
1*z^3 + 0*z^2 + 0*z^1 + 0
</PRE>

</DL>

<P>
@anchor{doc-sys2fir}
<DL>
<DT><U>Function File:</U> [<VAR>c</VAR>, <VAR>tsam</VAR>, <VAR>input</VAR>, <VAR>output</VAR>] = <B>sys2fir</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX990"></A>

</P>
<P>
Extract FIR data from system data structure; see fir2sys for
parameter descriptions.
</DL>
@seealso{fir2sys}

</P>



<H3><A NAME="SEC184" HREF="octave_toc.html#TOC184">State space system interface functions</A></H3>

<P>
@anchor{doc-ss2sys}
<DL>
<DT><U>Function File:</U>  <B>ss2sys</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>, <VAR>tsam</VAR>, <VAR>n</VAR>, <VAR>nz</VAR>, <VAR>stname</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>, <VAR>outlist</VAR>)</I>
<DD><A NAME="IDX991"></A>
Create system structure from state-space data.   May be continous,
discrete, or mixed (sampeled-data)

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<DT><VAR>b</VAR>
<DD>
<DT><VAR>c</VAR>
<DD>
<DT><VAR>d</VAR>
<DD>
usual state space matrices.

default: <VAR>d</VAR> = zero matrix

<DT><VAR>tsam</VAR>
<DD>
sampling rate.  Default: @math{tsam = 0} (continuous system)

<DT><VAR>n</VAR>
<DD>
<DT><VAR>nz</VAR>
<DD>
number of continuous, discrete states in the system

If <VAR>tsam</VAR> is 0, @math{n = <CODE>rows</CODE>(<VAR>a</VAR>)}, @math{nz = 0}.

If <VAR>tsam</VAR> is greater than zero, @math{n = 0},
@math{nz = <CODE>rows</CODE>(<VAR>a</VAR>)}

see below for system partitioning

<DT><VAR>stname</VAR>
<DD>
list of strings of state signal names

default (<VAR>stname</VAR>=[] on input): <CODE>x_n</CODE> for continuous states,
<CODE>xd_n</CODE> for discrete states

<DT><VAR>inname</VAR>
<DD>
list of strings of input signal names

default (<VAR>inname</VAR> = [] on input): <CODE>u_n</CODE>

<DT><VAR>outname</VAR>
<DD>
list of strings of input signal names

default (<VAR>outname</VAR> = [] on input): <CODE>y_n</CODE>

<DT><VAR>outlist</VAR>
<DD>
list of indices of outputs y that are sampled

If <VAR>tsam</VAR> is 0, @math{outlist = []}.

If <VAR>tsam</VAR> is greater than 0, @math{outlist = 1:<CODE>rows</CODE>(<VAR>c</VAR>)}.
</DL>

<P>
Unlike states, discrete/continous outputs may appear in any order.

</P>
<P>
<STRONG>Note</STRONG> <CODE>sys2ss</CODE> returns a vector <VAR>yd</VAR> where
<VAR>yd</VAR>(<VAR>outlist</VAR>) = 1; all other entries of <VAR>yd</VAR> are 0.

</P>
<P>
<STRONG>Outputs</STRONG>
<VAR>outsys</VAR> = system data structure

</P>
<P>
<STRONG>System partitioning</STRONG>

</P>
<P>
Suppose for simplicity that outlist specified
that the first several outputs were continuous and the remaining outputs
were discrete.  Then the system is partitioned as

<PRE>
x = [ xc ]  (n x 1)
    [ xd ]  (nz x 1 discrete states)
a = [ acc acd ]  b = [ bc ]
    [ adc add ]      [ bd ]
c = [ ccc ccd ]  d = [ dc ]
    [ cdc cdd ]      [ dd ]

    (cdc = c(outlist,1:n), etc.)
</PRE>

<P>
with dynamic equations:
@math{d/dt xc(t)     = acc*xc(t)      + acd*xd(k*tsam) + bc*u(t)}

</P>
<P>
@math{xd((k+1)*tsam) = adc*xc(k*tsam) + add*xd(k*tsam) + bd*u(k*tsam)}

</P>
<P>
@math{yc(t)      = ccc*xc(t)      + ccd*xd(k*tsam) + dc*u(t)}

</P>
<P>
@math{yd(k*tsam) = cdc*xc(k*tsam) + cdd*xd(k*tsam) + dd*u(k*tsam)}

</P>
<P>
<STRONG>Signal partitions</STRONG>

<PRE>
        | continuous      | discrete               |
----------------------------------------------------
states  | stname(1:n,:)   | stname((n+1):(n+nz),:) |
----------------------------------------------------
outputs | outname(cout,:) | outname(outlist,:)     |
----------------------------------------------------
</PRE>

<P>
where @math{cout} is the list of in 1:<CODE>rows</CODE>(<VAR>p</VAR>)
that are not contained in outlist. (Discrete/continuous outputs
may be entered in any order desired by the user.)

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; a = [1 2 3; 4 5 6; 7 8 10];
octave:2&#62; b = [0 0 ; 0 1 ; 1 0];
octave:3&#62; c = eye(3);
octave:4&#62; sys = ss2sys(a,b,c,[],0,3,0,list("volts","amps","joules"));
octave:5&#62; sysout(sys);
Input(s)
        1: u_1
        2: u_2

Output(s):
        1: y_1
        2: y_2
        3: y_3

state-space form:
3 continuous states, 0 discrete states
State(s):
        1: volts
        2: amps
        3: joules

A matrix: 3 x 3
   1   2   3
   4   5   6
   7   8  10
B matrix: 3 x 2
  0  0
  0  1
  1  0
C matrix: 3 x 3
  1  0  0
  0  1  0
  0  0  1
D matrix: 3 x 3
  0  0
  0  0
  0  0
</PRE>

<P>
Notice that the @math{D} matrix is constructed  by default to the
correct dimensions.  Default input and output signals names were assigned
since none were given.
</DL>

</P>

<P>
@anchor{doc-sys2ss}
<DL>
<DT><U>Function File:</U> [<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>, <VAR>tsam</VAR>, <VAR>n</VAR>, <VAR>nz</VAR>, <VAR>stname</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>, <VAR>yd</VAR>] = <B>sys2ss</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX992"></A>
Extract state space representation from system data structure.

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>sys</VAR> system data structure

</P>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<DT><VAR>b</VAR>
<DD>
<DT><VAR>c</VAR>
<DD>
<DT><VAR>d</VAR>
<DD>
state space matrices for sys

<DT><VAR>tsam</VAR>
<DD>
sampling time of sys (0 if continuous)

<DT><VAR>n</VAR>
<DD>
<DT><VAR>nz</VAR>
<DD>
number of continuous, discrete states (discrete states come
last in state vector <VAR>x</VAR>)

<DT><VAR>stname</VAR>
<DD>
<DT><VAR>inname</VAR>
<DD>
<DT><VAR>outname</VAR>
<DD>
signal names (lists of strings);  names of states,
inputs, and outputs, respectively

<DT><VAR>yd</VAR>
<DD>
binary vector; <VAR>yd</VAR>(<VAR>ii</VAR>) is 1 if output <VAR>y</VAR>(<VAR>ii</VAR>)$
is discrete (sampled); otherwise  <VAR>yd</VAR>(<VAR>ii</VAR>) 0.

</DL>
<P>
A warning massage is printed if the system is a mixed
continuous and discrete system

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys=tf2sys([1 2],[3 4 5]);
octave:2&#62; [a,b,c,d] = sys2ss(sys)
a =
   0.00000   1.00000
  -1.66667  -1.33333
b =
  0
  1
c = 0.66667  0.33333
d = 0
</PRE>

</DL>



<H3><A NAME="SEC185" HREF="octave_toc.html#TOC185">Transfer function system interface functions</A></H3>

<P>
@anchor{doc-tf2sys}
<DL>
<DT><U>Function File:</U>  <B>tf2sys</B> <I>(<VAR>num</VAR>, <VAR>den</VAR>, <VAR>tsam</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>)</I>
<DD><A NAME="IDX993"></A>
build system data structure from transfer function format data

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>num</VAR>
<DD>
<DT><VAR>den</VAR>
<DD>
coefficients of numerator/denominator polynomials
<DT><VAR>tsam</VAR>
<DD>
sampling interval. default: 0 (continuous time)
<DT><VAR>inname</VAR>
<DD>
<DT><VAR>outname</VAR>
<DD>
input/output signal names; may be a string or list with a single string
entry.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>sys</VAR> = system data structure

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys=tf2sys([2 1],[1 2 1],0.1);
octave:2&#62; sysout(sys)
Input(s)
        1: u_1
Output(s):
        1: y_1 (discrete)
Sampling interval: 0.1
transfer function form:
2*z^1 + 1
-----------------
1*z^2 + 2*z^1 + 1
</PRE>

</DL>

<P>
@anchor{doc-sys2tf}
<DL>
<DT><U>Function File:</U> [<VAR>num</VAR>, <VAR>den</VAR>, <VAR>tsam</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>] = <B>sys2tf</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX994"></A>
Extract transfer function data from a system data structure

</P>
<P>
See tf2sys for parameter descriptions.

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
octave:2&#62; [num,den] = sys2tf(sys)
num = 1.0000  -3.0000
den = 1.0000   1.1000  -4.3000
</PRE>

</DL>



<H3><A NAME="SEC186" HREF="octave_toc.html#TOC186">Zero-pole system interface functions</A></H3>

<P>
@anchor{doc-zp2sys}
<DL>
<DT><U>Function File:</U>  <B>zp2sys</B> <I>(<VAR>zer</VAR>, <VAR>pol</VAR>, <VAR>k</VAR>, <VAR>tsam</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>)</I>
<DD><A NAME="IDX995"></A>
Create system data structure from zero-pole data.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>zer</VAR>
<DD>
vector of system zeros
<DT><VAR>pol</VAR>
<DD>
vector of system poles
<DT><VAR>k</VAR>
<DD>
scalar leading coefficient
<DT><VAR>tsam</VAR>
<DD>
sampling period. default: 0 (continuous system)
<DT><VAR>inname</VAR>
<DD>
<DT><VAR>outname</VAR>
<DD>
input/output signal names (lists of strings)
</DL>

<P>
<STRONG>Outputs</STRONG>
sys: system data structure

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys=zp2sys([1 -1],[-2 -2 0],1);
octave:2&#62; sysout(sys)
Input(s)
        1: u_1
Output(s):
        1: y_1
zero-pole form:
1 (s - 1) (s + 1)
-----------------
s (s + 2) (s + 2)
</PRE>

</DL>

<P>
@anchor{doc-sys2zp}
<DL>
<DT><U>Function File:</U> [<VAR>zer</VAR>, <VAR>pol</VAR>, <VAR>k</VAR>, <VAR>tsam</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>] = <B>sys2zp</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX996"></A>
Extract zero/pole/leading coefficient information from a system data
structure

</P>
<P>
See zp2sys for parameter descriptions.

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
octave:2&#62; [zer,pol,k] = sys2zp(sys)
zer = 3.0000
pol =
  -2.6953
   1.5953
k = 1
</PRE>

</DL>



<H3><A NAME="SEC187" HREF="octave_toc.html#TOC187">Data structure access functions</A></H3>

<P>
@anchor{doc-syschnames}
<DL>
<DT><U>Function File:</U>  <B>syschnames</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>, <VAR>list</VAR>, <VAR>names</VAR>)</I>
<DD><A NAME="IDX997"></A>
Superseded by <CODE>syssetsignals</CODE>
</DL>

</P>

<P>
@anchor{doc-syschtsam}
<DL>
<DT><U>Function File:</U>  <B>syschtsam</B> <I>(<VAR>sys</VAR>, <VAR>tsam</VAR>)</I>
<DD><A NAME="IDX998"></A>
This function changes the sampling time (tsam) of the system.  Exits with
an error if sys is purely continuous time.
</DL>

</P>

<P>
@anchor{doc-sysdimensions}
<DL>
<DT><U>Function File:</U> [<VAR>n</VAR>, <VAR>nz</VAR>, <VAR>m</VAR>, <VAR>p</VAR>, <VAR>yd</VAR>] = <B>sysdimensions</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX999"></A>
return the number of states, inputs, and/or outputs in the system
<VAR>sys</VAR>.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure

<DT><VAR>opt</VAR>
<DD>
String indicating which dimensions are desired.  Values:
<DL COMPACT>

<DT><CODE>"all"</CODE>
<DD>
(default) return all parameters as specified under Outputs below.

<DT><CODE>"cst"</CODE>
<DD>
return <VAR>n</VAR>= number of continuous states

<DT><CODE>"dst"</CODE>
<DD>
return <VAR>n</VAR>= number of discrete states

<DT><CODE>"in"</CODE>
<DD>
return <VAR>n</VAR>= number of inputs

<DT><CODE>"out"</CODE>
<DD>
return <VAR>n</VAR>= number of outputs
</DL>
</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>n</VAR>
<DD>
 number of continuous states (or individual requested dimension as specified
by <VAR>opt</VAR>).
<DT><VAR>nz</VAR>
<DD>
 number of discrete states
<DT><VAR>m</VAR>
<DD>
 number of system inputs
<DT><VAR>p</VAR>
<DD>
 number of system outputs
<DT><VAR>yd</VAR>
<DD>
 binary vector; <VAR>yd</VAR>(<VAR>ii</VAR>) is nonzero if output <VAR>ii</VAR> is
discrete.
@math{yd(ii) = 0} if output <VAR>ii</VAR> is continous
</DL>
</DL>
<P>
@seealso{sysgetsignals and sysgettsam}

</P>

<P>
@anchor{doc-sysgetsignals}
<DL>
<DT><U>Function File:</U> [<VAR>stname</VAR>, <VAR>inname</VAR>, <VAR>outname</VAR>, <VAR>yd</VAR>] = <B>sysgetsignals</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1000"></A>
<DT><U>@deftypefnx{Function File}:</U> <VAR>siglist</VAR> = <B>sysgetsignals</B> <I>(<VAR>sys</VAR>, <VAR>sigid</VAR>)</I>
<DD><A NAME="IDX1001"></A>
<DT><U>@deftypefnx{Function File}:</U> <VAR>signame</VAR> = <B>sysgetsignals</B> <I>(<VAR>sys</VAR>, <VAR>sigid</VAR>, <VAR>signum</VAR>, <VAR>strflg</VAR>)</I>
<DD><A NAME="IDX1002"></A>
Get signal names from a system

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure for the state space system

<DT><VAR>sigid</VAR>
<DD>
signal id.  String.  Must be one of
<DL COMPACT>

<DT><CODE>"in"</CODE>
<DD>
input signals
<DT><CODE>"out"</CODE>
<DD>
output signals
<DT><CODE>"st"</CODE>
<DD>
stage signals
<DT><CODE>"yd"</CODE>
<DD>
value of logical vector <VAR>yd</VAR>
</DL>

<DT><VAR>signum</VAR>
<DD>
index(indices) or name(s) or signals; see <CODE>sysidx</CODE>

<DT><VAR>strflg</VAR>
<DD>
flag to return a string instead of a list;  Values:
<DL COMPACT>

<DT><CODE>0</CODE>
<DD>
(default) return a list (even if signum specifies an individual signal)

<DT><CODE>1</CODE>
<DD>
return a string.  Exits with an error if signum does not specify an 
individual signal.
</DL>

</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT>@bullet{If <VAR>sigid</VAR> is not specified}
<DD>
<DL COMPACT>

<DT><VAR>stname</VAR>
<DD>
<DT><VAR>inname</VAR>
<DD>
<DT><VAR>outname</VAR>
<DD>
signal names (lists of strings);  names of states,
inputs, and outputs, respectively
<DT><VAR>yd</VAR>
<DD>
binary vector; <VAR>yd</VAR>(<VAR>ii</VAR>) is nonzero if output <VAR>ii</VAR> is
discrete.
</DL>

<DT>@bullet{If <VAR>sigid</VAR> is specified but <VAR>signum</VAR> is not specified, then}
<DD>
<DL COMPACT>

<DT><CODE>sigid="in"</CODE>
<DD>
<VAR>siglist</VAR> is set to the list of input names

<DT><CODE>sigid="out"</CODE>
<DD>
<VAR>siglist</VAR> is set to the list of output names

<DT><CODE>sigid="st"</CODE>
<DD>
<VAR>siglist</VAR> is set to the list of state names

stage signals
<DT><CODE>sigid="yd"</CODE>
<DD>
<VAR>siglist</VAR> is set to logical vector indicating discrete outputs;
<VAR>siglist</VAR>(<VAR>ii</VAR>) = 0 indicates that output <VAR>ii</VAR> is continuous
(unsampled), otherwise it is discrete.

</DL>

<DT>@bullet{if the first three input arguments are specified, then <VAR>signame</VAR> is}
<DD>
a list of the specified signal names (<VAR>sigid</VAR> is <CODE>"in"</CODE>,
<CODE>"out"</CODE>, or <CODE>"st"</CODE>), or else the logical flag
indicating whether output(s) <VAR>signum</VAR> is(are) discrete (<VAR>sigval</VAR>=1)
or continuous (<VAR>sigval</VAR>=0).
</DL>

<P>
<STRONG>Examples</STRONG> (From <CODE>sysrepdemo</CODE>)

<PRE>
octave&#62; sys=ss2sys(rand(4),rand(4,2),rand(3,4));
octave&#62; [Ast,Ain,Aout,Ayd] = sysgetsignals(sys) i  # get all signal names
Ast =
(
  [1] = x_1
  [2] = x_2
  [3] = x_3
  [4] = x_4
)
Ain =
(
  [1] = u_1
  [2] = u_2
)
Aout =
(
  [1] = y_1
  [2] = y_2
  [3] = y_3
)
Ayd =

  0  0  0
octave&#62; Ain = sysgetsignals(sys,"in")   # get only input signal names
Ain =
(
  [1] = u_1
  [2] = u_2
)
octave&#62; Aout = sysgetsignals(sys,"out",2)   # get name of output 2 (in list)
Aout =
(
  [1] = y_2
)
octave&#62; Aout = sysgetsignals(sys,"out",2,1)  # get name of output 2 (as string)
Aout = y_2
</PRE>

</DL>

<P>
@anchor{doc-sysgettype}
<DL>
<DT><U>Function File:</U>  <B>sysgettype</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1003"></A>
return the initial system type of the system

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>sys</VAR>: system data structure

</P>
<P>
<STRONG>Outputs</STRONG>
<VAR>systype</VAR>: string indicating how the structure was initially
constructed:
values: <CODE>"ss"</CODE>, <CODE>"zp"</CODE>, or <CODE>"tf"</CODE>

</P>
<P>
<STRONG>Note</STRONG> FIR initialized systems return <CODE>systype="tf"</CODE>.
</DL>

</P>

<P>
@anchor{doc-syssetsignals}
<DL>
<DT><U>Function File:</U>  <B>syssetsignals</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>, <VAR>names</VAR>, <VAR>sig_idx</VAR>)</I>
<DD><A NAME="IDX1004"></A>
change the names of selected inputs, outputs and states.
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure

<DT><VAR>opt</VAR>
<DD>
change default name (output)

<DL COMPACT>

<DT><CODE>"out"</CODE>
<DD>
change selected output names
<DT><CODE>"in"</CODE>
<DD>
change selected input names
<DT><CODE>"st"</CODE>
<DD>
change selected state names
<DT><CODE>"yd"</CODE>
<DD>
change selected outputs from discrete to continuous or
from continuous to discrete.
</DL>

<DT><VAR>names</VAR>
<DD>
<DL COMPACT>

<DT><CODE>opt = "out", "in", or "st"</CODE>
<DD>
string or string array containing desired signal names or values.
<DT><CODE>opt = "yd"</CODE>
<DD>
To desired output continuous/discrete flag.
Set name to 0 for continuous, or 1 for discrete.
</DL>
<DT><VAR>sig_idx</VAR>
<DD>
indices or names of outputs, yd, inputs, or
states whose respective names/values should be changed.

Default: replace entire list of names/entire yd vector.
</DL>
<P>
<STRONG>Outputs</STRONG>
<VAR>retsys=sys</VAR> with appropriate signal names changed
(or yd values, where appropriate)

</P>
<P>
<STRONG>Example</STRONG>

<PRE>
octave:1&#62; sys=ss2sys([1 2; 3 4],[5;6],[7 8]);
octave:2&#62; sys = syssetsignals(sys,"st",str2mat("Posx","Velx"));
octave:3&#62; sysout(sys)
Input(s)
        1: u_1
Output(s):
        1: y_1
state-space form:
2 continuous states, 0 discrete states
State(s):
        1: Posx
        2: Velx
A matrix: 2 x 2
  1  2
  3  4
B matrix: 2 x 1
  5
  6
C matrix: 1 x 2
  7  8
D matrix: 1 x 1
0
</PRE>

</DL>

<P>
@anchor{doc-sysupdate}
<DL>
<DT><U>Function File:</U>  <B>sysupdate</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1005"></A>
Update the internal representation of a system.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys:</VAR>
<DD>
system data structure
<DT><VAR>opt</VAR>
<DD>
string:
<DL COMPACT>

<DT><CODE>"tf"</CODE>
<DD>
update transfer function form
<DT><CODE>"zp"</CODE>
<DD>
update zero-pole form
<DT><CODE>"ss"</CODE>
<DD>
update state space form
<DT><CODE>"all"</CODE>
<DD>
all of the above
</DL>
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>retsys</VAR>: contains union of data in sys and requested data.
If requested data in sys is already up to date then retsys=sys.

</P>
<P>
Conversion to <CODE>tf</CODE> or <CODE>zp</CODE> exits with an error if the system is
mixed continuous/digital.
</DL>
@seealso{tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, and sys2zp}

</P>

<P>
 function [systype, nout, nin, ncstates, ndstates] = minfo(inmat)

</P>
<P>
MINFO:  Determines the type of system matrix.  INMAT can be
        a varying(*), system, constant, and empty matrix.

</P>
<P>
   Returns:
     systype can be one of:
           varying, system, constant, and empty
     nout is the number of outputs of the system
     nin is the number of inputs of the system
     ncstates is the number of continuous states of the system
      ndstates is the number of discrete states of the system

</P>

<P>
@anchor{doc-sysgettsam}
<DL>
<DT><U>Function File:</U>  <B>sysgettsam</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1006"></A>
Return the sampling time of the system <VAR>sys</VAR>.
</DL>

</P>



<H3><A NAME="SEC188" HREF="octave_toc.html#TOC188">Data structure internal functions</A></H3>



<H2><A NAME="SEC189" HREF="octave_toc.html#TOC189">System display functions</A></H2>

<P>
@anchor{doc-sysout}
<DL>
<DT><U>Function File:</U>  <B>sysout</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1007"></A>
print out a system data structure in desired format
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure
<DT><VAR>opt</VAR>
<DD>
Display option
<DL COMPACT>

<DT><CODE>[]</CODE>
<DD>
primary system form (default)
<DT><CODE>"ss"</CODE>
<DD>
state space form
<DT><CODE>"tf"</CODE>
<DD>
transfer function form
<DT><CODE>"zp"</CODE>
<DD>
zero-pole form
<DT><CODE>"all"</CODE>
<DD>
all of the above
</DL>
</DL>
</DL>

<P>
@anchor{doc-tfout}
<DL>
<DT><U>Function File:</U>  <B>tfout</B> <I>(<VAR>num</VAR>, <VAR>denom</VAR>, <VAR>x</VAR>)</I>
<DD><A NAME="IDX1008"></A>
Print formatted transfer function @math{n(s)/d(s)} to the screen.
<VAR>x</VAR> defaults to the string <CODE>"s"</CODE>
</DL>
@seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
filter, polyderiv, polyinteg, and polyout}

</P>

<P>
@anchor{doc-zpout}
<DL>
<DT><U>Function File:</U>  <B>zpout</B> <I>(<VAR>zer</VAR>, <VAR>pol</VAR>, <VAR>k</VAR>, <VAR>x</VAR>)</I>
<DD><A NAME="IDX1009"></A>
print formatted zero-pole form to the screen.
<VAR>x</VAR> defaults to the string <CODE>"s"</CODE>
</DL>
@seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
filter, polyderiv, polyinteg, and polyout}

</P>



<H2><A NAME="SEC190" HREF="octave_toc.html#TOC190">Block Diagram Manipulations</A></H2>

<P>
See section <A HREF="octave_29.html#SEC193">System Analysis-Time Domain</A>.

</P>
<P>
Unless otherwise noted, all parameters (input,output) are
system data structures.

</P>
<P>
@anchor{doc-bddemo}
<DL>
<DT><U>Function File:</U>  <B>bddemo</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1010"></A>
Octave Controls toolbox demo: Block Diagram Manipulations demo
</DL>

</P>

<P>
@anchor{doc-buildssic}
<DL>
<DT><U>Function File:</U>  <B>buildssic</B> <I>(<VAR>clst</VAR>, <VAR>ulst</VAR>, <VAR>olst</VAR>, <VAR>ilst</VAR>, <VAR>s1</VAR>, <VAR>s2</VAR>, <VAR>s3</VAR>, <VAR>s4</VAR>, <VAR>s5</VAR>, <VAR>s6</VAR>, <VAR>s7</VAR>, <VAR>s8</VAR>)</I>
<DD><A NAME="IDX1011"></A>

</P>
<P>
Form an arbitrary complex (open or closed loop) system in
state-space form from several systems. "<CODE>buildssic</CODE>" can
easily (despite it's cryptic syntax) integrate transfer functions
from a complex block diagram into a single system with one call.
This function is especially useful for building open loop
interconnections for H_infinity and H2 designs or for closing
loops with these controllers.

</P>
<P>
Although this function is general purpose, the use of "<CODE>sysgroup</CODE>"
"<CODE>sysmult</CODE>", "<CODE>sysconnect</CODE>" and the like is recommended for
standard operations since they can handle mixed discrete and continuous
systems and also the names of inputs, outputs, and states.

</P>
<P>
The parameters consist of 4 lists that describe the connections
outputs and inputs and up to 8 systems s1-s8.
Format of the lists:
<DL COMPACT>

<DT><VAR>clst</VAR>
<DD>
connection list, describes the input signal of
each system. The maximum number of rows of Clst is
equal to the sum of all inputs of s1-s8.

Example:
<CODE>[1 2 -1; 2 1 0]</CODE> ==&#62; new input 1 is old inpout 1
+ output 2 - output 1, new input 2 is old input 2
+ output 1. The order of rows is arbitrary.

<DT><VAR>ulst</VAR>
<DD>
if not empty the old inputs in vector Ulst will
be appended to the outputs. You need this if you
want to "pull out" the input of a system. Elements
are input numbers of s1-s8.

<DT><VAR>olst</VAR>
<DD>
output list, specifiy the outputs of the resulting
systems. Elements are output numbers of s1-s8.
The numbers are alowed to be negative and may
appear in any order. An empty matrix means
all outputs.

<DT><VAR>ilst</VAR>
<DD>
input list, specifiy the inputs of the resulting
systems. Elements are input numbers of s1-s8.
The numbers are alowed to be negative and may
appear in any order. An empty matrix means
all inputs.
</DL>

<P>
Example:  Very simple closed loop system.

<PRE>
w        e  +-----+   u  +-----+
 ---&#62;o--*--&#62;|  K  |--*--&#62;|  G  |--*---&#62; y
     ^  |   +-----+  |   +-----+  |
   - |  |            |            |
     |  |            +----------------&#62; u
     |  |                         |
     |  +-------------------------|---&#62; e
     |                            |
     +----------------------------+
</PRE>

<P>
The closed loop system GW can be optained by

<PRE>
GW = buildssic([1 2; 2 -1], 2, [1 2 3], 2, G, K);
</PRE>

<DL COMPACT>

<DT><VAR>clst</VAR>
<DD>
(1. row) connect input 1 (G) with output 2 (K).
(2. row) connect input 2 (K) with neg. output 1 (G).
<DT><VAR>ulst</VAR>
<DD>
append input of (2) K to the number of outputs.
<DT><VAR>olst</VAR>
<DD>
Outputs are output of 1 (G), 2 (K) and appended output 3 (from Ulst).
<DT><VAR>ilst</VAR>
<DD>
the only input is 2 (K).
</DL>

<P>
Here is a real example:

<PRE>
                         +----+
    --------------------&#62;| W1 |---&#62; v1
z   |                    +----+
----|-------------+                   || GW   ||     =&#62; min.
    |             |                        vz   infty
    |    +---+    v      +----+
    *---&#62;| G |---&#62;O--*--&#62;| W2 |---&#62; v2
    |    +---+       |   +----+
    |                |
    |                v
   u                  y
</PRE>

<P>
The closed loop system GW from [z; u]' to [v1; v2; y]' can be
obtained by (all SISO systems):

<PRE>
GW = buildssic([1, 4; 2, 4; 3, 1], 3, [2, 3, 5],
               [3, 4], G, W1, W2, One);
</PRE>

<P>
where "One" is a unity gain (auxillary) function with order 0.
(e.g. <CODE>One = ugain(1);</CODE>)
</DL>

</P>

<P>
@anchor{doc-jet707}
<DL>
<DT><U>Function File:</U>  <B>jet707</B> <I>()</I>
<DD><A NAME="IDX1012"></A>
Creates linearized state space model of a Boeing 707-321 aircraft
at v=80m/s. (M = 0.26, Ga0 = -3 deg, alpha0 = 4 deg, kappa = 50 deg)
System inputs:   (1) thrust   and (2) elevator angle
System outputs:  (1) airspeed and (2) pitch angle
Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
</DL>
@seealso{ord2}

</P>

<P>
@anchor{doc-ord2}
<DL>
<DT><U>Function File:</U>  <B>ord2</B> <I>(<VAR>nfreq</VAR>, <VAR>damp</VAR>, <VAR>gain</VAR>)</I>
<DD><A NAME="IDX1013"></A>
Creates a continuous 2nd order system with parameters:
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>nfreq</VAR>
<DD>
natural frequency [Hz]. (not in rad/s)
<DT><VAR>damp</VAR>
<DD>
damping coefficient
<DT><VAR>gain</VAR>
<DD>
dc-gain
This is steady state value only for damp &#62; 0.
gain is assumed to be 1.0 if ommitted.
</DL>
<P>
<STRONG>Outputs</STRONG>
<VAR>outsys</VAR>
system data structure has representation with @math{w = 2 * pi * nfreq}:

<PRE>
    /                                        \
    | / -2w*damp -w \  / w \                 |
G = | |             |, |   |, [ 0  gain ], 0 |
    | \   w       0 /  \ 0 /                 |
    \                                        /
</PRE>

<P>
<STRONG>See also</STRONG> <CODE>jet707</CODE> (MIMO example, Boeing 707-321
aircraft model)
</DL>

</P>

<P>
@anchor{doc-sysadd}
<DL>
<DT><U>Function File:</U>  <B>sysadd</B> <I>(<VAR>gsys</VAR>, <VAR>hsys</VAR>)</I>
<DD><A NAME="IDX1014"></A>
returns <VAR>sys</VAR> = <VAR>gsys</VAR> + <VAR>hsys</VAR>.

<UL>
<LI>Exits with

an error if <VAR>gsys</VAR> and <VAR>hsys</VAR> are not compatibly dimensioned.
<LI>Prints a warning message is system states have identical names;

duplicate names are given a suffix to make them unique.
<LI><VAR>sys</VAR> input/output names are taken from <VAR>gsys</VAR>.

</UL>


<PRE>
          ________
     ----|  gsys  |---
u   |    ----------  +|
-----                (_)----&#62; y
    |     ________   +|
     ----|  hsys  |---
          --------
</PRE>

</DL>

<P>
@anchor{doc-sysappend}
<DL>
<DT><U>Function File:</U>  <B>sysappend</B> <I>(<VAR>sys</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>, <VAR>outname</VAR>, <VAR>inname</VAR>, <VAR>yd</VAR>)</I>
<DD><A NAME="IDX1015"></A>
appends new inputs and/or outputs to a system

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure

<DT><VAR>b</VAR>
<DD>
matrix to be appended to sys "B" matrix (empty if none)

<DT><VAR>c</VAR>
<DD>
matrix to be appended to sys "C" matrix (empty if none)

<DT><VAR>d</VAR>
<DD>
revised sys d matrix (can be passed as [] if the revised d is all zeros)

<DT><VAR>outname</VAR>
<DD>
list of names for new outputs

<DT><VAR>inname</VAR>
<DD>
list of names for new inputs

<DT><VAR>yd</VAR>
<DD>
binary vector; @math{yd(ii)=0} indicates a continuous output;
@math{yd(ii)=1} indicates a discrete output.
</DL>

<P>
<STRONG>Outputs</STRONG> <VAR>sys</VAR>

<PRE>
   sys.b := [sys.b , b]
   sys.c := [sys.c  ]
            [ c     ]
   sys.d := [sys.d | D12 ]
            [D21   | D22 ]
</PRE>

<P>
where @math{D12}, @math{D21}, and @math{D22} are the appropriate dimensioned
blocks of the input parameter <VAR>d</VAR>.

<UL>
<LI>The leading block @math{D11} of <VAR>d</VAR> is ignored.

<LI>If <VAR>inname</VAR> and <VAR>outname</VAR> are not given as arguments,

     the new inputs and outputs are be assigned default names.
<LI><VAR>yd</VAR> is a binary vector of length rows(c) that indicates

     continuous/sampled outputs.  Default value for <VAR>yd</VAR> is:

<LI><VAR>sys</VAR> = continuous or mixed

<VAR>yd</VAR> = <CODE>zeros(1,rows(c))</CODE>

<LI><VAR>sys</VAR> = discrete

<VAR>yd</VAR> = <CODE>ones(1,rows(c))</CODE>
</UL>

</DL>

<P>
@anchor{doc-sysconnect}
<DL>
<DT><U>Function File:</U>  <B>sysconnect</B> <I>(<VAR>sys</VAR>, <VAR>out_idx</VAR>, <VAR>in_idx</VAR>, <VAR>order</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1016"></A>
Close the loop from specified outputs to respective specified inputs

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure
<DT><VAR>out_idx</VAR>
<DD>
<DT><VAR>in_idx</VAR>
<DD>
names or indices of signals to connect (see <CODE>sysidx</CODE>).
The output specified by @math{out_idx(ii)} is connected to the input
specified by @math{in_idx(ii)}.
<DT><VAR>order</VAR>
<DD>
logical flag (default = 0)
<DL COMPACT>

<DT><CODE>0</CODE>
<DD>
leave inputs and outputs in their original order
<DT><CODE>1</CODE>
<DD>
permute inputs and outputs to the order shown in the diagram below
</DL>
<DT><VAR>tol</VAR>
<DD>
tolerance for singularities in algebraic loops default: 200<VAR>eps</VAR>
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>sys</VAR>: resulting closed loop system.

</P>
<P>
<STRONG>Method</STRONG>
<CODE>sysconnect</CODE> internally permutes selected inputs, outputs as shown
below, closes the loop, and then permutes inputs and outputs back to their
original order

<PRE>
                 ____________________
 u_1       -----&#62;|                  |----&#62; y_1
                 |        sys       |
         old u_2 |                  |
u_2* ----&#62;(+)---&#62;|                  |-----&#62;y_2
(in_idx)   ^     -------------------|    | (out_idx)
           |                             |
           -------------------------------
</PRE>

<P>
The input that has the summing junction added to it has an * added to
the end  of the input name.
</DL>

</P>

<P>
@anchor{doc-syscont}
<DL>
<DT><U>Function File:</U> [<VAR>csys</VAR>, <VAR>acd</VAR>, <VAR>ccd</VAR>] = <B>syscont</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1017"></A>
Extract the purely continuous subsystem of an input system.

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>sys</VAR> is a system data structure

</P>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>csys</VAR>
<DD>
is the purely continuous input/output connections of <VAR>sys</VAR>
<DT><VAR>acd</VAR>
<DD>
<DT><VAR>ccd</VAR>
<DD>
connections from discrete states to continuous states,
discrete states to continuous outputs, respectively.

returns <VAR>csys</VAR> empty if no continuous/continous path exists
</DL>
</DL>

<P>
@anchor{doc-sysdisc}
<DL>
<DT><U>Function File:</U> [<VAR>dsys</VAR>, <VAR>adc</VAR>, <VAR>cdc</VAR>] = <B>sysdisc</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1018"></A>

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>sys</VAR> = system data structure

</P>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>dsys</VAR>
<DD>
purely discrete portion of sys (returned empty if there is
no purely discrete path from inputs to outputs)
<DT><VAR>adc</VAR>
<DD>
<DT><VAR>cdc</VAR>
<DD>
connections from continuous states to discrete states and discrete
outputs, respectively.
</DL>
</DL>

<P>
@anchor{doc-sysdup}
<DL>
<DT><U>Function File:</U>  <B>sysdup</B> <I>(<VAR>asys</VAR>, <VAR>out_idx</VAR>, <VAR>in_idx</VAR>)</I>
<DD><A NAME="IDX1019"></A>
Duplicate specified input/output connections of a system

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>asys</VAR>
<DD>
system data structure
<DT><VAR>out_idx</VAR>
<DD>
<DT><VAR>in_idx</VAR>
<DD>
indices or names of desired signals (see <CODE>sigidx</CODE>).
duplicates are made of <CODE>y(out_idx(ii))</CODE> and <CODE>u(in_idx(ii))</CODE>.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>retsys</VAR>: resulting closed loop system:
duplicated i/o names are appended with a <CODE>"+"</CODE> suffix.

</P>

<P>
<STRONG>Method</STRONG>
<CODE>sysdup</CODE> creates copies of selected inputs and outputs as
shown below.  u1/y1 is the set of original inputs/outputs, and
u2,y2 is the set of duplicated inputs/outputs in the order specified
in <VAR>in_idx</VAR>, <VAR>out_idx</VAR>, respectively

<PRE>
          ____________________
u1  -----&#62;|                  |----&#62; y1
          |       asys       |
u2 ------&#62;|                  |-----&#62;y2
(in_idx)  -------------------| (out_idx)
</PRE>

</DL>
<P>
 

</P>
<P>
@anchor{doc-sysgroup}
<DL>
<DT><U>Function File:</U>  <B>sysgroup</B> <I>(<VAR>asys</VAR>, <VAR>bsys</VAR>)</I>
<DD><A NAME="IDX1020"></A>
Combines two systems into a single system

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>asys</VAR>, <VAR>bsys</VAR>: system data structures

</P>
<P>
<STRONG>Outputs</STRONG>
@math{sys = block diag(asys,bsys)}

<PRE>
         __________________
         |    ________    |
u1 -----&#62;|--&#62; | asys |---&#62;|----&#62; y1
         |    --------    |
         |    ________    |
u2 -----&#62;|--&#62; | bsys |---&#62;|----&#62; y2
         |    --------    |
         ------------------
              Ksys
</PRE>

<P>
The function also rearranges the internal state-space realization of <VAR>sys</VAR>
so that the
continuous states come first and the discrete states come last.
If there are duplicate names, the second name has a unique suffix appended
on to the end of the name.
</DL>

</P>

<P>
@anchor{doc-sysmult}
<DL>
<DT><U>Function File:</U>  <B>sysmult</B> <I>(<VAR>asys</VAR>, <VAR>bsys</VAR>)</I>
<DD><A NAME="IDX1021"></A>
Compute @math{sys = Asys*Bsys} (series connection):

<PRE>
u   ----------     ----------
---&#62;|  bsys  |----&#62;|  asys  |---&#62;
    ----------     ----------
</PRE>

<P>
A warning occurs if there is direct feed-through
from an input of Bsys or a continuous state of <VAR>bsys</VAR> through a
discrete output of Bsys to a continuous state or output in <VAR>asys</VAR>
(system data structure does not recognize discrete inputs).
</DL>

</P>

<P>
@anchor{doc-sysprune}
<DL>
<DT><U>Function File:</U>  <B>sysprune</B> <I>(<VAR>asys</VAR>, <VAR>out_idx</VAR>, <VAR>in_idx</VAR>)</I>
<DD><A NAME="IDX1022"></A>
Extract specified inputs/outputs from a system

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>asys</VAR>
<DD>
system data structure
<DT><VAR>out_idx</VAR>
<DD>
<DT><VAR>in_idx</VAR>
<DD>
Indices or signal names of the outputs and inputs to be kept in the returned
system; remaining connections are "pruned" off.
May select as [] (empty matrix) to specify all outputs/inputs.


<PRE>
retsys = sysprune(Asys,[1:3,4],"u_1");
retsys = sysprune(Asys,list("tx","ty","tz"), 4);
</PRE>

</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>retsys</VAR>: resulting system

<PRE>
           ____________________
u1 -------&#62;|                  |----&#62; y1
 (in_idx)  |       Asys       | (out_idx)
u2 -------&#62;|                  |----| y2
  (deleted)-------------------- (deleted)
</PRE>

</DL>

<P>
@anchor{doc-sysreorder}
<DL>
<DT><U>Function File:</U>  <B>sysreorder</B> <I>(<VAR>vlen</VAR>, <VAR>list</VAR>)</I>
<DD><A NAME="IDX1023"></A>

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>vlen</VAR>=vector length, <VAR>list</VAR>= a subset of <CODE>[1:vlen]</CODE>,

</P>
<P>
<STRONG>Outputs</STRONG>
<VAR>pv</VAR>: a permutation vector to order elements of <CODE>[1:vlen]</CODE> in
<CODE>list</CODE> to the end of a vector.

</P>
<P>
Used internally by <CODE>sysconnect</CODE> to permute vector elements to their
desired locations.
</DL>

</P>

<P>
@anchor{doc-sysscale}
<DL>
<DT><U>Function File:</U>  <B>sysscale</B> <I>(<VAR>sys</VAR>, <VAR>outscale</VAR>, <VAR>inscale</VAR>, <VAR>outname</VAR>, <VAR>inname</VAR>)</I>
<DD><A NAME="IDX1024"></A>
scale inputs/outputs of a system.

</P>
<P>
<STRONG>Inputs</STRONG>
sys: structured system
outscale, inscale: constant matrices of appropriate dimension

</P>
<P>
<STRONG>Outputs</STRONG>
<VAR>sys</VAR>: resulting open loop system:

<PRE>
      -----------    -------    -----------
u ---&#62;| inscale |---&#62;| sys |---&#62;| outscale |---&#62; y
      -----------    -------    -----------
</PRE>

<P>
If the input names and output names (each a list of strings)
are not given and the scaling matrices
are not square, then default names will be given to the inputs and/or
outputs.

</P>
<P>
A warning message is printed if outscale attempts to add continuous
system outputs to discrete system outputs; otherwise <VAR>yd</VAR> is
set appropriately in the returned value of <VAR>sys</VAR>.
</DL>

</P>

<P>
@anchor{doc-syssub}
<DL>
<DT><U>Function File:</U>  <B>syssub</B> <I>(<VAR>gsys</VAR>, <VAR>hsys</VAR>)</I>
<DD><A NAME="IDX1025"></A>
Return @math{sys = Gsys - Hsys}.

</P>
<P>
Method: <VAR>gsys</VAR> and <VAR>hsys</VAR> are connected in parallel
The input vector is connected to both systems; the outputs are
subtracted.  Returned system names are those of <VAR>gsys</VAR>.

<PRE>
         +--------+
    +---&#62;|  gsys  |---+
    |    +--------+   |
    |                +|
u --+                (_)--&#62; y
    |                -|
    |    +--------+   |
    +---&#62;|  hsys  |---+
         +--------+
</PRE>

</DL>

<P>
@anchor{doc-ugain}
<DL>
<DT><U>Function File:</U>  <B>ugain</B> <I>(<VAR>n</VAR>)</I>
<DD><A NAME="IDX1026"></A>
Creates a system with unity gain, no states.
This trivial system is sometimes needed to create arbitrary
complex systems from simple systems with buildssic.
Watch out if you are forming sampled systems since "ugain"
does not contain a sampling period.
</DL>
@seealso{hinfdemo and jet707}

</P>

<P>
@anchor{doc-wgt1o}
<DL>
<DT><U>Function File:</U>  <B>wgt1o</B> <I>(<VAR>vl</VAR>, <VAR>vh</VAR>, <VAR>fc</VAR>)</I>
<DD><A NAME="IDX1027"></A>
State space description of a first order weighting function.

</P>
<P>
Weighting function are needed by the H2/H_infinity design procedure.
These function are part of thye augmented plant P (see hinfdemo
for an applicattion example).

</P>
<P>
vl = Gain at low frequencies

</P>
<P>
vh = Gain at high frequencies

</P>
<P>
fc = Corner frequency (in Hz, *not* in rad/sec)
</DL>

</P>

<P>
@anchor{doc-parallel}
<DL>
<DT><U>Function File:</U>  <B>parallel</B> <I>(<VAR>asys</VAR>, <VAR>bsys</VAR>)</I>
<DD><A NAME="IDX1028"></A>
Forms the parallel connection of two systems.

</P>
<P>
             ____________________
             |      ________    |
    u  -----&#62;|----&#62; | asys |---&#62;|----&#62; y1
        |    |      --------    |
        |    |      ________    |
        |---&#62;|----&#62; | bsys |---&#62;|----&#62; y2
             |      --------    |
             --------------------
                  ksys
</DL>

</P>

<P>
@anchor{doc-sysmin}
<DL>
<DT><U>Function File:</U> [<VAR>retsys</VAR>, <VAR>nc</VAR>, <VAR>no</VAR>] = <B>sysmin</B> <I>(<VAR>sys</VAR>, <VAR>flg</VAR>)</I>
<DD><A NAME="IDX1029"></A>
return a minimal (or reduced order) system
inputs:
  sys: system data structure
  flg: 0 [default] return minimal system; state names lost
     : 1           return system with physical states removed that
                   are either uncontrollable or unobservable
                   (cannot reduce further without discarding physical
                   meaning of states)
outputs:
  retsys: returned system
  nc: number of controllable states in the returned system
  no: number of observable states in the returned system
  cflg: is_controllable(retsys)
  oflg: is_observable(retsys)
</DL>

</P>



<H2><A NAME="SEC191" HREF="octave_toc.html#TOC191">Numerical Functions</A></H2>

<P>
@anchor{doc-are}
<DL>
<DT><U>Function File:</U>  <B>are</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1030"></A>
Solve the algebraic Riccati equation

<PRE>
a' * x + x * a - x * b * x + c = 0
</PRE>

<P>
<STRONG>Inputs</STRONG>
for identically dimensioned square matrices
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<VAR>n</VAR>x<VAR>n</VAR> matrix.
<DT><VAR>b</VAR>
<DD>
<VAR>n</VAR>x<VAR>n</VAR> matrix or <VAR>n</VAR>x<VAR>m</VAR> matrix; in the latter case
<VAR>b</VAR> is replaced by @math{b:=b*b'}.
<DT><VAR>c</VAR>
<DD>
<VAR>n</VAR>x<VAR>n</VAR> matrix or <VAR>p</VAR>x<VAR>m</VAR> matrix; in the latter case
<VAR>c</VAR> is replaced by @math{c:=c'*c}.
<DT><VAR>opt</VAR>
<DD>
(optional argument; default = <CODE>"B"</CODE>):
String option passed to <CODE>balance</CODE> prior to ordered Schur decomposition.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>x</VAR>: solution of the ARE.

</P>
<P>
<STRONG>Method</STRONG>
Laub's Schur method (IEEE Transactions on
Automatic Control, 1979) is applied to the appropriate Hamiltonian
matrix.

</P>
</DL>
<P>
@seealso{balance and dare}

</P>

<P>
@anchor{doc-dare}
<DL>
<DT><U>Function File:</U>  <B>dare</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>r</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1031"></A>

</P>
<P>
Return the solution, <VAR>x</VAR> of the discrete-time algebraic Riccati
equation

<PRE>
a' x a - x + a' x b (r + b' x b)^(-1) b' x a + c = 0
</PRE>

<P>

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<VAR>n</VAR> by <VAR>n</VAR>.

<DT><VAR>b</VAR>
<DD>
<VAR>n</VAR> by <VAR>m</VAR>.

<DT><VAR>c</VAR>
<DD>
<VAR>n</VAR> by <VAR>n</VAR>, symmetric positive semidefinite, or <VAR>p</VAR> by <VAR>n</VAR>.
In the latter case @math{c:=c'*c} is used.

<DT><VAR>r</VAR>
<DD>
<VAR>m</VAR> by <VAR>m</VAR>, symmetric positive definite (invertible).

<DT><VAR>opt</VAR>
<DD>
(optional argument; default = <CODE>"B"</CODE>):
String option passed to <CODE>balance</CODE> prior to ordered <VAR>QZ</VAR> decomposition.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>x</VAR> solution of DARE.

</P>
<P>
<STRONG>Method</STRONG>
Generalized eigenvalue approach (Van Dooren; SIAM J.
 Sci. Stat. Comput., Vol 2) applied  to the appropriate symplectic pencil.

</P>
<P>
 See also: Ran and Rodman, "Stable Hermitian Solutions of Discrete
 Algebraic Riccati Equations," Mathematics of Control, Signals and
 Systems, Vol 5, no 2 (1992)  pp 165-194.

</P>
</DL>
<P>
@seealso{balance and are}

</P>

<P>
@anchor{doc-dre}
<DL>
<DT><U>Function File:</U> [<VAR>tvals</VAR>, <VAR>plist</VAR>] = <B>dre</B> <I>(<VAR>sys</VAR>, <VAR>q</VAR>, <VAR>r</VAR>, <VAR>qf</VAR>, <VAR>t0</VAR>, <VAR>tf</VAR>, <VAR>ptol</VAR>, <VAR>maxits</VAR>);</I>
<DD><A NAME="IDX1032"></A>
Solve the differential Riccati equation

<PRE>
  -d P/dt = A'P + P A - P B inv(R) B' P + Q
  P(tf) = Qf
</PRE>

<P>
for the LTI system sys.  Solution of standard LTI
state feedback optimization

<PRE>
  min \int_{t_0}^{t_f} x' Q x + u' R u dt + x(t_f)' Qf x(t_f)
</PRE>

<P>
optimal input is

<PRE>
  u = - inv(R) B' P(t) x
</PRE>

<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
continuous time system data structure
<DT><VAR>q</VAR>
<DD>
state integral penalty
<DT><VAR>r</VAR>
<DD>
input integral penalty
<DT><VAR>qf</VAR>
<DD>
state terminal penalty
<DT><VAR>t0</VAR>
<DD>
<DT><VAR>tf</VAR>
<DD>
limits on the integral
<DT><VAR>ptol</VAR>
<DD>
tolerance (used to select time samples; see below); default = 0.1
<DT><VAR>maxits</VAR>
<DD>
number of refinement iterations (default=10)
</DL>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>tvals</VAR>
<DD>
time values at which <VAR>p</VAR>(<VAR>t</VAR>) is computed
<DT><VAR>plist</VAR>
<DD>
list values of <VAR>p</VAR>(<VAR>t</VAR>); nth (<VAR>plist</VAR>, <VAR>ii</VAR>)
is <VAR>p</VAR>(<VAR>tvals</VAR>(<VAR>ii</VAR>)).

<DT><VAR>tvals</VAR>
<DD>

<PRE>
is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || &#60; Ptol
for ii=2:length(tvals)
</PRE>

</DL>
</DL>

<P>
@anchor{doc-dgram}
<DL>
<DT><U>Function File:</U>  <B>dgram</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1033"></A>
Return controllability grammian of discrete time system

<PRE>
  x(k+1) = a x(k) + b u(k)
</PRE>

<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<VAR>n</VAR> by <VAR>n</VAR> matrix
<DT><VAR>b</VAR>
<DD>
<VAR>n</VAR> by <VAR>m</VAR> matrix
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>m</VAR> (<VAR>n</VAR> by <VAR>n</VAR>) satisfies

<PRE>
 a m a' - m + b*b' = 0
</PRE>

</DL>

<P>
@anchor{doc-dlyap}
<DL>
<DT><U>Function File:</U>  <B>dlyap</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1034"></A>
Solve the discrete-time Lyapunov equation

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<VAR>n</VAR> by <VAR>n</VAR> matrix
<DT><VAR>b</VAR>
<DD>
  Matrix: <VAR>n</VAR> by <VAR>n</VAR>, <VAR>n</VAR> by <VAR>m</VAR>, or <VAR>p</VAR> by <VAR>n</VAR>.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>x</VAR>: matrix satisfying appropriate discrete time Lyapunov equation.
Options:

<UL>
<LI><VAR>b</VAR> is square: solve <CODE>a x a' - x + b = 0</CODE>

<LI><VAR>b</VAR> is not square: <VAR>x</VAR> satisfies either


<PRE>
a x a' - x + b b' = 0
</PRE>

or

<PRE>
a' x a - x + b' b = 0,
</PRE>

whichever is appropriate.
</UL>

<P>
<STRONG>Method</STRONG>
Uses Schur decomposition method as in Kitagawa,
<CITE>An Algorithm for Solving the Matrix Equation @math{X = F X F' + S</CITE>},
International Journal of Control, Volume 25, Number 5, pages 745--753
(1977).

</P>
<P>
Column-by-column solution method as suggested in
Hammarling, <CITE>Numerical Solution of the Stable, Non-Negative
Definite Lyapunov Equation</CITE>, IMA Journal of Numerical Analysis, Volume
2, pages 303--323 (1982).
</DL>

</P>

<P>
@anchor{doc-gram}
<DL>
<DT><U>Function File:</U>  <B>gram</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1035"></A>
Return controllability grammian <VAR>m</VAR> of the continuous time system
@math{dx/dt = a x + b u}.

</P>
<P>
<VAR>m</VAR> satisfies @math{a m + m a' + b b' = 0}.
</DL>

</P>

<P>
@anchor{doc-lyap}
<DL>
<DT><U>Function File:</U>  <B>lyap</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>)</I>
<DD><A NAME="IDX1036"></A>
<DT><U>Function File:</U>  <B>lyap</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1037"></A>
Solve the Lyapunov (or Sylvester) equation via the Bartels-Stewart
algorithm (Communications of the ACM, 1972).

</P>
<P>
If <VAR>a</VAR>, <VAR>b</VAR>, and <VAR>c</VAR> are specified, then <CODE>lyap</CODE> returns
the solution of the  Sylvester equation

<PRE>
    a x + x b + c = 0
</PRE>

<P>
If only <CODE>(a, b)</CODE> are specified, then <CODE>lyap</CODE> returns the
solution of the Lyapunov equation

<PRE>
    a' x + x a + b = 0
</PRE>

<P>
If <VAR>b</VAR> is not square, then <CODE>lyap</CODE> returns the solution of either

<PRE>
    a' x + x a + b' b = 0
</PRE>

<P>
or

<PRE>
    a x + x a' + b b' = 0
</PRE>

<P>
whichever is appropriate.

</P>
<P>
Solves by using the Bartels-Stewart algorithm (1972).
</DL>

</P>

<P>
@anchor{doc-qzval}
<DL>
<DT><U>Function File:</U>  <B>qzval</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1038"></A>
Compute generalized eigenvalues of the matrix pencil

<PRE>
(A - lambda B).
</PRE>

<P>
<VAR>a</VAR> and <VAR>b</VAR> must be real matrices.

</P>
<P>
<STRONG>Note</STRONG> <CODE>qzval</CODE> is obsolete; use <CODE>qz</CODE> instead.
</DL>

</P>

<P>
@anchor{doc-zgfmul}
<DL>
<DT><U>Function File:</U>  <B>zgfmul</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>, <VAR>x</VAR>)</I>
<DD><A NAME="IDX1039"></A>
Compute product of zgep incidence matrix @math{F} with vector <VAR>x</VAR>.
Used by zgepbal (in zgscal) as part of generalized conjugate gradient
iteration.
</DL>

</P>

<P>
@anchor{doc-zgfslv}
<DL>
<DT><U>Function File:</U>  <B>zgfslv</B> <I>(<VAR>n</VAR>, <VAR>m</VAR>, <VAR>p</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1040"></A>
Solve system of equations for dense zgep problem.
</DL>

</P>

<P>
@anchor{doc-zginit}
<DL>
<DT><U>Function File:</U>  <B>zginit</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>)</I>
<DD><A NAME="IDX1041"></A>
Construct right hand side vector zz
for the zero-computation generalized eigenvalue problem
balancing procedure.  Called by zgepbal.
</DL>

</P>

<P>
@anchor{doc-zgreduce}
<DL>
<DT><U>Function File:</U>  <B>zgreduce</B> <I>(<VAR>sys</VAR>, <VAR>meps</VAR>)</I>
<DD><A NAME="IDX1042"></A>
Implementation of procedure REDUCE in (Emami-Naeini and Van Dooren,
Automatica, # 1982).
</DL>

</P>

<P>
@anchor{doc-zgrownorm}
<DL>
<DT><U>Function File:</U> [<VAR>nonz</VAR>, <VAR>zer</VAR>] = <B>zgrownorm</B> <I>(<VAR>mat</VAR>, <VAR>meps</VAR>)</I>
<DD><A NAME="IDX1043"></A>
Return <VAR>nonz</VAR> = number of rows of <VAR>mat</VAR> whose two norm
exceeds <VAR>meps</VAR>, and <VAR>zer</VAR> = number of rows of mat whose two
norm is less than <VAR>meps</VAR>.
</DL>

</P>

<P>
@anchor{doc-zgscal}
<DL>
<DT><U>Function File:</U>  <B>zgscal</B> <I>(<VAR>f</VAR>, <VAR>z</VAR>, <VAR>n</VAR>, <VAR>m</VAR>, <VAR>p</VAR>)</I>
<DD><A NAME="IDX1044"></A>
Generalized conjugate gradient iteration to
solve zero-computation generalized eigenvalue problem balancing equation
@math{fx=z};
called by <CODE>zgepbal</CODE>
</DL>

</P>

<P>
@anchor{doc-zgsgiv}
<DL>
<DT><U>Function File:</U> [a, b] = <B>zgsgiv</B> <I>(<VAR>c</VAR>, <VAR>s</VAR>, <VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1045"></A>
Apply givens rotation c,s to row vectors <VAR>a</VAR>, <VAR>b</VAR>.
No longer used in zero-balancing (__zgpbal__); kept for backward
compatibility.
</DL>

</P>

<P>
@anchor{doc-zgshsr}
<DL>
<DT><U>Function File:</U>  <B>zgshsr</B> <I>(<VAR>y</VAR>)</I>
<DD><A NAME="IDX1046"></A>
apply householder vector based on @math{e^(m)} to
(column vector) y.
Called by zgfslv
</DL>

</P>

<P>
References:
<DL COMPACT>

<DT><STRONG>ZGEP</STRONG>
<DD>
 Hodel, "Computation of Zeros with Balancing," 1992, Linear Algebra
 and its Applications
<DT><STRONG><STRONG>Generalized CG</STRONG></STRONG>
<DD>
 Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
</DL>



<H2><A NAME="SEC192" HREF="octave_toc.html#TOC192">System Analysis-Properties</A></H2>

<P>
@anchor{doc-analdemo}
<DL>
<DT><U>Function File:</U>  <B>analdemo</B> <I>()</I>
<DD><A NAME="IDX1047"></A>
Octave Controls toolbox demo: State Space analysis demo
</DL>

</P>

<P>
@anchor{doc-abcddim}
<DL>
<DT><U>Function File:</U> [<VAR>n</VAR>, <VAR>m</VAR>, <VAR>p</VAR>] = <B>abcddim</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>)</I>
<DD><A NAME="IDX1048"></A>
Check for compatibility of the dimensions of the matrices defining
the linear system
[A, B, C, D] corresponding to

</P>

<PRE>
dx/dt = a x + b u
y = c x + d u
</PRE>

<P>
or a similar discrete-time system.

</P>
<P>
If the matrices are compatibly dimensioned, then <CODE>abcddim</CODE> returns

</P>
<DL COMPACT>

<DT><VAR>n</VAR>
<DD>
The number of system states.

<DT><VAR>m</VAR>
<DD>
The number of system inputs.

<DT><VAR>p</VAR>
<DD>
The number of system outputs.
</DL>

<P>
Otherwise <CODE>abcddim</CODE> returns <VAR>n</VAR> = <VAR>m</VAR> = <VAR>p</VAR> = -1.

</P>
<P>
Note: n = 0 (pure gain block) is returned without warning.

</P>
</DL>
<P>
@seealso{is_abcd}

</P>

<P>
@anchor{doc-ctrb}
<DL>
<DT><U>Function File:</U>  <B>ctrb</B> <I>(<VAR>sys</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1049"></A>
<DT><U>Function File:</U>  <B>ctrb</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1050"></A>
Build controllability matrix

<PRE>
             2       n-1
Qs = [ B AB A B ... A   B ]
</PRE>

<P>
of a system data structure or the pair (<VAR>a</VAR>, <VAR>b</VAR>).

</P>
<P>
<STRONG>Note</STRONG> <CODE>ctrb</CODE> forms the controllability matrix.
The numerical properties of <CODE>is_controllable</CODE>
are much better for controllability tests.
</DL>

</P>

<P>
@anchor{doc-h2norm}
<DL>
<DT><U>Function Fil:</U>  <B>h2norm</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1051"></A>
Computes the H2 norm of a system data structure (continuous time only)

</P>
<P>
Reference:
Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
H2 and Hinf Control Problems", IEEE TAC August 1989
</DL>

</P>

<P>
@anchor{doc-hinfnorm}
<DL>
<DT><U>Function File:</U> [<VAR>g</VAR>, <VAR>gmin</VAR>, <VAR>gmax</VAR>] = <B>hinfnorm</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>, <VAR>gmin</VAR>, <VAR>gmax</VAR>, <VAR>ptol</VAR>)</I>
<DD><A NAME="IDX1052"></A>
 Computes the H infinity norm of a system data structure.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure
<DT><VAR>tol</VAR>
<DD>
H infinity norm search tolerance (default: 0.001)
<DT><VAR>gmin</VAR>
<DD>
minimum value for norm search (default: 1e-9)
<DT><VAR>gmax</VAR>
<DD>
maximum value for norm search (default: 1e+9)
<DT><VAR>ptol</VAR>
<DD>
pole tolerance:

<UL>
<LI>if sys is continuous, poles with

|real(pole)| &#60; ptol*||H|| (H is appropriate Hamiltonian)
are considered to be on the imaginary axis.

<LI>if sys is discrete, poles with

|abs(pole)-1| &#60; ptol*||[s1,s2]|| (appropriate symplectic pencil)
are considered to be on the unit circle

<LI>Default: 1e-9

</UL>

</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>g</VAR>
<DD>
Computed gain, within <VAR>tol</VAR> of actual gain.  <VAR>g</VAR> is returned as Inf
if the system is unstable.
<DT><VAR>gmin</VAR>
<DD>
<DT><VAR>gmax</VAR>
<DD>
Actual system gain lies in the interval [<VAR>gmin</VAR>, <VAR>gmax</VAR>]
</DL>

<P>
References:
Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
H2 and Hinf control problems", IEEE TAC August 1989
Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
Int. J. Control, vol 54, #5, 1991
Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
</DL>

</P>

<P>
@anchor{doc-obsv}
<DL>
<DT><U>Function File:</U>  <B>obsv</B> <I>(<VAR>sys</VAR>, <VAR>c</VAR>)</I>
<DD><A NAME="IDX1053"></A>
Build observability matrix

<PRE>
     | C        |
     | CA       |
Qb = | CA^2     |
     | ...      |
     | CA^(n-1) |
</PRE>

<P>
of a system data structure or the pair (A, C).

</P>
<P>
Note: <CODE>obsv()</CODE> forms the observability matrix.

</P>
<P>
The numerical properties of is_observable()
are much better for observability tests.
</DL>

</P>

<P>
@anchor{doc-pzmap}
<DL>
<DT><U>Function File:</U> [<VAR>zer</VAR>, <VAR>pol</VAR>]= <B>pzmap</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1054"></A>
Plots the zeros and poles of a system in the complex plane.
<STRONG>Inputs</STRONG>
<VAR>sys</VAR> system data structure

</P>
<P>
<STRONG>Outputs</STRONG>
if omitted, the poles and zeros are plotted on the screen.
otherwise, pol, zer are returned as the system poles and zeros.
(see sys2zp for a preferable function call)
</DL>

</P>

<P>
@anchor{doc-is_abcd}
<DL>
<DT><U>Function File:</U>  <B>is_abcd</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>)</I>
<DD><A NAME="IDX1055"></A>
 Returns <VAR>retval</VAR> = 1 if the dimensions of <VAR>a</VAR>, <VAR>b</VAR>,
<VAR>c</VAR>, <VAR>d</VAR> are compatible, otherwise <VAR>retval</VAR> = 0 with an
 appropriate diagnostic message printed to the screen.  The matrices
 b, c, or d may be omitted.
</DL>
@seealso{abcddim}

</P>

<P>
@anchor{doc-is_controllable}
<DL>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_controllable</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1056"></A>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_controllable</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1057"></A>
Logical check for system controllability.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure
<DT><VAR>a</VAR>
<DD>
<DT><VAR>b</VAR>
<DD>
<VAR>n</VAR> by <VAR>n</VAR>, <VAR>n</VAR> by <VAR>m</VAR> matrices, respectively
<DT><VAR>tol</VAR>
<DD>
optional roundoff paramter.  default value: <CODE>10*eps</CODE>
</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>retval</VAR>
<DD>
Logical flag; returns true (1) if the system <VAR>sys</VAR> or the
pair (<VAR>a</VAR>,<VAR>b</VAR>) is controllable, whichever was passed as input
arguments.
<DT><VAR>U</VAR>
<DD>
 U is an orthogonal basis of the controllable subspace.
</DL>

<P>
<STRONG>Method</STRONG>
Controllability is determined by applying Arnoldi iteration with
complete re-orthogonalization to obtain an orthogonal basis of the
Krylov subspace

<PRE>
span ([b,a*b,...,a^{n-1}*b]).
</PRE>

<P>
The Arnoldi iteration is executed with <CODE>krylov</CODE> if the system
has a single input; otherwise a block Arnoldi iteration is performed
with <CODE>krylovb</CODE>.
</DL>
@seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
is_observable, is_stabilizable, is_detectable, krylov, and krylovb}

</P>

<P>
@anchor{doc-is_detectable}
<DL>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_detectable</B> <I>(<VAR>a</VAR>, <VAR>c</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1058"></A>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_detectable</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1059"></A>
Test for detactability (observability of unstable modes) of
(<VAR>a</VAR>,<VAR>c</VAR>).

</P>
<P>
Returns 1 if the system <VAR>a</VAR> or the pair (<VAR>a</VAR>,<VAR>c</VAR>)is
detectable, 0 if not.

</P>
<P>
<STRONG>See</STRONG> <CODE>is_stabilizable</CODE> for detailed description of
arguments and computational method.

</P>
<P>
Default: tol = 10*norm(a,'fro')*eps

</P>
</DL>
<P>
@seealso{is_stabilizable, size, rows, columns, length, is_matrix,
is_scalar, and is_vector}

</P>

<P>
@anchor{doc-is_dgkf}
<DL>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>dgkf_struct</VAR> ] = <B>is_dgkf</B> <I>(<VAR>asys</VAR>, <VAR>nu</VAR>, <VAR>ny</VAR>, <VAR>tol</VAR> )</I>
<DD><A NAME="IDX1060"></A>
Determine whether a continuous time state space system meets
assumptions of DGKF algorithm.
Partitions system into:

<PRE>
[dx/dt] = [A  | Bw  Bu  ][w]
[ z   ]   [Cz | Dzw Dzu ][u]
[ y   ]   [Cy | Dyw Dyu ]
</PRE>

<P>
or similar discrete-time system.
If necessary, orthogonal transformations <VAR>qw</VAR>, <VAR>qz</VAR> and nonsingular
transformations <VAR>ru</VAR>, <VAR>ry</VAR> are applied to respective vectors
<VAR>w</VAR>, <VAR>z</VAR>, <VAR>u</VAR>, <VAR>y</VAR> in order to satisfy DGKF assumptions.
Loop shifting is used if <VAR>dyu</VAR> block is nonzero.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>asys</VAR>
<DD>
system data structure
<DT><VAR>nu</VAR>
<DD>
number of controlled inputs
<DT><VAR>ny</VAR>
<DD>
number of measured outputs
<DT><VAR>tol</VAR>
<DD>
threshhold for 0.  Default: 200<VAR>eps</VAR>
</DL>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>retval</VAR>
<DD>
true(1) if system passes check, false(0) otherwise
<DT><VAR>dgkf_struct</VAR>
<DD>
data structure of <CODE>is_dgkf</CODE> results.  Entries:
<DL COMPACT>

<DT><VAR>nw</VAR>
<DD>
<DT><VAR>nz</VAR>
<DD>
dimensions of <VAR>w</VAR>, <VAR>z</VAR>
<DT><VAR>a</VAR>
<DD>
system @math{A} matrix
<DT><VAR>bw</VAR>
<DD>
(<VAR>n</VAR> x <VAR>nw</VAR>) <VAR>qw</VAR>-transformed disturbance input matrix
<DT><VAR>bu</VAR>
<DD>
(<VAR>n</VAR> x <VAR>nu</VAR>) <VAR>ru</VAR>-transformed controlled input matrix;

<STRONG>Note</STRONG> @math{B = [Bw Bu]}
<DT><VAR>cz</VAR>
<DD>
(<VAR>nz</VAR> x <VAR>n</VAR>) Qz-transformed error output matrix
<DT><VAR>cy</VAR>
<DD>
(<VAR>ny</VAR> x <VAR>n</VAR>) <VAR>ry</VAR>-transformed measured output matrix

<STRONG>Note</STRONG> @math{C = [Cz; Cy]}
<DT><VAR>dzu</VAR>
<DD>
<DT><VAR>dyw</VAR>
<DD>
off-diagonal blocks of transformed system @math{D} matrix that enter
<VAR>z</VAR>, <VAR>y</VAR> from <VAR>u</VAR>, <VAR>w</VAR> respectively
<DT><VAR>ru</VAR>
<DD>
controlled input transformation matrix
<DT><VAR>ry</VAR>
<DD>
observed output transformation matrix
<DT><VAR>dyu_nz</VAR>
<DD>
nonzero if the <VAR>dyu</VAR> block is nonzero.
<DT><VAR>dyu</VAR>
<DD>
untransformed <VAR>dyu</VAR> block
<DT><VAR>dflg</VAR>
<DD>
nonzero if the system is discrete-time
</DL>
</DL>
<P>
<CODE>is_dgkf</CODE> exits with an error if the system is mixed
discrete/continuous

</P>
<P>
<STRONG>References</STRONG>
<DL COMPACT>

<DT><STRONG>[1]</STRONG>
<DD>
Doyle, Glover, Khargonekar, Francis, "State Space Solutions
to Standard H2 and Hinf Control Problems," IEEE TAC August 1989
<DT><STRONG>[2]</STRONG>
<DD>
Maciejowksi, J.M.: "Multivariable feedback design,"
</DL>
</DL>

<P>
@anchor{doc-is_digital}
<DL>
<DT><U>Function File:</U>  <B>is_digital</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1061"></A>
Return nonzero if system is digital;
inputs:
sys: system data structure
eflg: 0 [default] exit with an error if system is mixed (continuous and
discrete components)
    : 1 print a warning if system is mixed (continuous and discrete)
    : 2 silent operation
outputs:
DIGITAL:  0: system is purely continuous
       :  1: system is purely discrete
       : -1: system is mixed continuous and discrete
Exits with an error of sys is a mixed (continuous and discrete) system
</DL>

</P>

<P>
@anchor{doc-is_observable}
<DL>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_observable</B> <I>(<VAR>a</VAR>, <VAR>c</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1062"></A>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_observable</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1063"></A>
Logical check for system observability.

</P>
<P>
Default: tol = 10*norm(a,'fro')*eps

</P>
<P>
Returns 1 if the system <VAR>sys</VAR> or the pair (<VAR>a</VAR>,<VAR>c</VAR>) is
observable, 0 if not.

</P>
<P>
<STRONG>See</STRONG> <CODE>is_controllable</CODE> for detailed description of arguments
and default values.
</DL>
@seealso{size, rows, columns, length, is_matrix, is_scalar, and is_vector}

</P>

<P>
@anchor{doc-is_sample}
<DL>
<DT><U>Function File:</U>  <B>is_sample</B> <I>(<VAR>ts</VAR>)</I>
<DD><A NAME="IDX1064"></A>
Return true if <VAR>ts</VAR> is a valid sampling time
(real,scalar, &#62; 0)
</DL>

</P>

<P>
@anchor{doc-is_siso}
<DL>
<DT><U>Function File:</U>  <B>is_siso</B> <I>(<VAR>sys</VAR>)</I>
<DD><A NAME="IDX1065"></A>
return nonzero if the system data structure
<VAR>sys</VAR> is single-input, single-output.
</DL>

</P>

<P>
@anchor{doc-is_stabilizable}
<DL>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_stabilizable</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1066"></A>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>u</VAR>] = <B>is_stabilizable</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1067"></A>
Logical check for system stabilizability (i.e., all unstable modes are controllable).

</P>
<P>
Test for stabilizability is performed via an ordered Schur decomposition
that reveals the unstable subspace of the system <VAR>a</VAR> matrix.

</P>
<P>
Returns <CODE>retval</CODE> = 1 if the system, <VAR>a</VAR>, is stabilizable,
if the pair  (<VAR>a</VAR>, <VAR>b</VAR>) is stabilizable, or 0 if not.
<VAR>u</VAR> = orthogonal basis of controllable subspace.

</P>
<P>
Controllable subspace is determined by applying Arnoldi iteration with
complete re-orthogonalization to obtain an orthogonal basis of the
Krylov subspace.

<PRE>
  span ([b,a*b,...,a^   b]).
</PRE>

<P>
tol is a roundoff paramter, set to 200*eps if omitted.
</DL>

</P>

<P>
@anchor{doc-is_signal_list}
<DL>
<DT><U>Function File:</U>  <B>is_signal_list</B> <I>(<VAR>mylist</VAR>)</I>
<DD><A NAME="IDX1068"></A>
Return true if <VAR>mylist</VAR> is a list of individual strings.
</DL>

</P>

<P>
@anchor{doc-is_stable}
<DL>
<DT><U>Function File:</U>  <B>is_stable</B> <I>(<VAR>a</VAR>, <VAR>tol</VAR>, <VAR>dflg</VAR>)</I>
<DD><A NAME="IDX1069"></A>
<DT><U>Function File:</U>  <B>is_stable</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1070"></A>
Returns 1 if the matrix <VAR>a</VAR> or the system <VAR>sys</VAR>
is stable, or 0 if not.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>tol</VAR>
<DD>
is a roundoff paramter, set to 200*<VAR>eps</VAR> if omitted.
<DT><VAR>dflg</VAR>
<DD>
Digital system flag (not required for system data structure):
<DL COMPACT>

<DT><CODE><VAR>dflg</VAR> != 0</CODE>
<DD>
stable if eig(a) in unit circle

<DT><CODE><VAR>dflg</VAR> == 0</CODE>
<DD>
stable if eig(a) in open LHP (default)
</DL>
</DL>
</DL>
<P>
@seealso{size, rows, columns, length, is_matrix, is_scalar, is_vector
is_observable, is_stabilizable, is_detectable, krylov, and krylovb}

</P>



<H2><A NAME="SEC193" HREF="octave_toc.html#TOC193">System Analysis-Time Domain</A></H2>

<P>
@anchor{doc-c2d}
<DL>
<DT><U>Function File:</U>  <B>c2d</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>, <VAR>t</VAR>)</I>
<DD><A NAME="IDX1071"></A>
<DT><U>Function File:</U>  <B>c2d</B> <I>(<VAR>sys</VAR>, <VAR>t</VAR>)</I>
<DD><A NAME="IDX1072"></A>

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure (may have both continuous time and discrete
time subsystems)
<DT><VAR>opt</VAR>
<DD>
string argument; conversion option (optional argument;
may be omitted as shown above)
<DL COMPACT>

<DT><CODE>"ex"</CODE>
<DD>
use the matrix exponential (default)
<DT><CODE>"bi"</CODE>
<DD>
use the bilinear transformation
</DL>

<PRE>
    2(z-1)
s = -----
    T(z+1)
</PRE>

FIXME: This option exits with an error if <VAR>sys</VAR> is not purely
continuous. (The <CODE>ex</CODE> option can handle mixed systems.)
<DT><VAR>t</VAR>
<DD>
sampling time; required if sys is purely continuous.

<STRONG>Note</STRONG> If the 2nd argument is not a string, <CODE>c2d</CODE> assumes that
the 2nd argument is <VAR>t</VAR> and performs appropriate argument checks.
</DL>

<P>
<STRONG>Outputs</STRONG>
<VAR>dsys</VAR> discrete time equivalent via zero-order hold,
sample each <VAR>t</VAR> sec.

</P>
<P>
converts the system data structure describing

<PRE>
.
x = Ac x + Bc u
</PRE>

<P>
into a discrete time equivalent model

<PRE>
x[n+1] = Ad x[n] + Bd u[n]
</PRE>

<P>
via the matrix exponential or bilinear transform

</P>
<P>
<STRONG>Note</STRONG> This function adds the suffix  <CODE>_d</CODE>
to the names of the new discrete states.
</DL>

</P>

<P>
@anchor{doc-d2c}
<DL>
<DT><U>Function File:</U>  <B>d2c</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1073"></A>
<DT><U>Function File:</U>  <B>d2c</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1074"></A>
Convert discrete (sub)system to a purely continuous system.  Sampling
time used is <CODE>sysgettsam(<VAR>sys</VAR>)</CODE>

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure with discrete components
<DT><VAR>tol</VAR>
<DD>
Scalar value.
tolerance for convergence of default <CODE>"log"</CODE> option (see below)
<DT><VAR>opt</VAR>
<DD>
conversion option.  Choose from:
<DL COMPACT>

<DT><CODE>"log"</CODE>
<DD>
(default) Conversion is performed via a matrix logarithm.
Due to some problems with this computation, it is
followed by a steepest descent algorithm to identify continuous time
<VAR>a</VAR>, <VAR>b</VAR>, to get a better fit to the original data.

If called as <CODE>d2c (<VAR>sys</VAR>, <VAR>tol</VAR>)</CODE>, with <VAR>tol</VAR>
positive scalar, the <CODE>"log"</CODE> option is used.  The default value
for <VAR>tol</VAR> is <CODE>1e-8</CODE>.
<DT><CODE>"bi"</CODE>
<DD>
Conversion is performed via bilinear transform
@math{z = (1 + s T / 2)/(1 - s T / 2)} where @math{T} is the
system sampling time (see <CODE>sysgettsam</CODE>).

FIXME: bilinear option exits with an error if <VAR>sys</VAR> is not purely
discrete
</DL>
</DL>
<P>
<STRONG>Outputs</STRONG> <VAR>csys</VAR> continuous time system (same dimensions and
signal names as in <VAR>sys</VAR>).
</DL>

</P>

<P>
@anchor{doc-dmr2d}
<DL>
<DT><U>Function File:</U> [<VAR>dsys</VAR>, <VAR>fidx</VAR>] = <B>dmr2d</B> <I>(<VAR>sys</VAR>, <VAR>idx</VAR>, <VAR>sprefix</VAR>, <VAR>ts2</VAR>, <VAR>cuflg</VAR>)</I>
<DD><A NAME="IDX1075"></A>
convert a multirate digital system to a single rate digital system
states specified by <VAR>idx</VAR>, <VAR>sprefix</VAR> are sampled at <VAR>ts2</VAR>, all
others are assumed sampled at <VAR>ts1</VAR> = <CODE>sysgettsam (<VAR>sys</VAR>)</CODE>.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
discrete time system;
<CODE>dmr2d</CODE> exits with an error if <VAR>sys</VAR> is not discrete
<DT><VAR>idx</VAR>
<DD>
indices or names of states with sampling time 
<CODE>sysgettsam(<VAR>sys</VAR>)</CODE> (may be empty); see <CODE>listidx</CODE>
<DT><VAR>sprefix</VAR>
<DD>
list of string prefixes of states with sampling time
<CODE>sysgettsam(<VAR>sys</VAR>)</CODE> (may be empty)
<DT><VAR>ts2</VAR>
<DD>
sampling time of states not specified by <VAR>idx</VAR>, <VAR>sprefix</VAR>
must be an integer multiple of <CODE>sysgettsam(<VAR>sys</VAR>)</CODE>
<DT><VAR>cuflg</VAR>
<DD>
"constant u flag" if <VAR>cuflg</VAR> is nonzero then the system inputs are
assumed to be constant over the revised sampling interval <VAR>ts2</VAR>.
Otherwise, since the inputs can change during the interval
<VAR>t</VAR> in @math{[k ts2, (k+1) ts2]}, an additional set of inputs is
included in the revised B matrix so that these intersample inputs
may be included in the single-rate system.
default <VAR>cuflg</VAR> = 1.
</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>dsys</VAR>
<DD>
equivalent discrete time system with sampling time <VAR>ts2</VAR>.

The sampling time of sys is updated to <VAR>ts2</VAR>.

if <VAR>cuflg</VAR>=0 then a set of additional inputs is added to
the system with suffixes _d1, ..., _dn to indicate their
delay from the starting time k <VAR>ts2</VAR>, i.e.
u = [u_1; u_1_d1; ..., u_1_dn] where u_1_dk is the input
k*ts1 units of time after u_1 is sampled. (<VAR>ts1</VAR> is
the original sampling time of the discrete time system and
<VAR>ts2</VAR> = (n+1)*ts1)

<DT><VAR>fidx</VAR>
<DD>
indices of "formerly fast" states specified by <VAR>idx</VAR> and <VAR>sprefix</VAR>;
these states are updated to the new (slower) sampling interval <VAR>ts2</VAR>.
</DL>

<P>
<STRONG>WARNING</STRONG> Not thoroughly tested yet; especially when
<VAR>cuflg</VAR> == 0.
</DL>

</P>

<P>
@anchor{doc-damp}
<DL>
<DT><U>Function File:</U>  <B>damp</B> <I>(<VAR>p</VAR>, <VAR>tsam</VAR>)</I>
<DD><A NAME="IDX1076"></A>
Displays eigenvalues, natural frequencies and damping ratios
of the eigenvalues of a matrix <VAR>p</VAR> or the @math{A}-matrix of a
system <VAR>p</VAR>, respectively.
If <VAR>p</VAR> is a system, <VAR>tsam</VAR> must not be specified.
If <VAR>p</VAR> is a matrix and <VAR>tsam</VAR> is specified, eigenvalues
of <VAR>p</VAR> are assumed to be in <VAR>z</VAR>-domain.
</DL>
@seealso{eig}

</P>

<P>
@anchor{doc-dcgain}
<DL>
<DT><U>Function File:</U>  <B>dcgain</B> <I>(<VAR>sys</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1077"></A>
Returns dc-gain matrix. If dc-gain is infinite
an empty matrix is returned.
The argument <VAR>tol</VAR> is an optional tolerance for the condition
number of the @math{A}-Matrix in <VAR>sys</VAR> (default <VAR>tol</VAR> = 1.0e-10)
</DL>

</P>

<P>
@anchor{doc-impulse}
<DL>
<DT><U>Function File:</U> [<VAR>y</VAR>, <VAR>t</VAR>] = <B>impulse</B> <I>(<VAR>sys</VAR>, <VAR>inp</VAR>, <VAR>tstop</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX1078"></A>
Impulse response for a linear system.
The system can be discrete or multivariable (or both).
If no output arguments are specified, <CODE>impulse</CODE>
produces a plot or the impulse response data for system <VAR>sys</VAR>.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
System data structure.
<DT><VAR>inp</VAR>
<DD>
Index of input being excited
<DT><VAR>tstop</VAR>
<DD>
The argument <VAR>tstop</VAR> (scalar value) denotes the time when the
simulation should end.
<DT><VAR>n</VAR>
<DD>
the number of data values.

Both parameters <VAR>tstop</VAR> and <VAR>n</VAR> can be omitted and will be
computed from the eigenvalues of the A-Matrix.
</DL>
<P>
<STRONG>Outputs</STRONG>
<VAR>y</VAR>, <VAR>t</VAR>: impulse response
</DL>
@seealso{step and __stepimp__}

</P>

<P>
@anchor{doc-step}
<DL>
<DT><U>Function File:</U> [<VAR>y</VAR>, <VAR>t</VAR>] = <B>step</B> <I>(<VAR>sys</VAR>, <VAR>inp</VAR>, <VAR>tstop</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX1079"></A>
Step response for a linear system.
The system can be discrete or multivariable (or both).
If no output arguments are specified, <CODE>step</CODE>
produces a plot or the step response data for system <VAR>sys</VAR>.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
System data structure.
<DT><VAR>inp</VAR>
<DD>
Index of input being excited
<DT><VAR>tstop</VAR>
<DD>
The argument <VAR>tstop</VAR> (scalar value) denotes the time when the
simulation should end.
<DT><VAR>n</VAR>
<DD>
the number of data values.

Both parameters <VAR>tstop</VAR> and <VAR>n</VAR> can be omitted and will be
computed from the eigenvalues of the A-Matrix.
</DL>
<P>
<STRONG>Outputs</STRONG>
<VAR>y</VAR>, <VAR>t</VAR>: impulse response

</P>
<P>
When invoked with the output paramter y the plot is not displayed.
</DL>
@seealso{impulse and __stepimp__}

</P>



<H2><A NAME="SEC194" HREF="octave_toc.html#TOC194">System Analysis-Frequency Domain</A></H2>

<P>
<STRONG>Demonstration/tutorial script</STRONG>
@anchor{doc-frdemo}
<DL>
<DT><U>Function File:</U>  <B>frdemo</B> <I>()</I>
<DD><A NAME="IDX1080"></A>
Octave Controls toolbox demo: Frequency Response demo
</DL>

</P>

<P>
@anchor{doc-bode}
<DL>
<DT><U>Function File:</U> [<VAR>mag</VAR>, <VAR>phase</VAR>, <VAR>w</VAR>] = <B>bode</B> <I>(<VAR>sys</VAR>, <VAR>w</VAR>, <VAR>out_idx</VAR>, <VAR>in_idx</VAR>)</I>
<DD><A NAME="IDX1081"></A>
If no output arguments are given: produce Bode plots of a system; otherwise,
compute the frequency response of a system data structure

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
a system data structure (must be either purely continuous or discrete;
see is_digital)
<DT><VAR>w</VAR>
<DD>
frequency values for evaluation.

if <VAR>sys</VAR> is continuous, then bode evaluates @math{G(jw)} where
@math{G(s)} is the system transfer function.

if <VAR>sys</VAR> is discrete, then bode evaluates G(<CODE>exp</CODE>(jwT)), where

<UL>
<LI>@math{T} is the system sampling time

<LI>@math{G(z)} is the system transfer function.

</UL>

<STRONG>Default</STRONG> the default frequency range is selected as follows: (These
steps are NOT performed if <VAR>w</VAR> is specified)

<OL>
<LI>via routine __bodquist__, isolate all poles and zeros away from

<VAR>w</VAR>=0 (<VAR>jw</VAR>=0 or @math{<CODE>exp</CODE>(jwT)}=1) and select the frequency
range based on the breakpoint locations of the frequencies.
<LI>if <VAR>sys</VAR> is discrete time, the frequency range is limited

              to @math{jwT} in
[0,2 pi /T]
<LI>A "smoothing" routine is used to ensure that the plot phase does

not change excessively from point to point and that singular
points (e.g., crossovers from +/- 180) are accurately shown.

</OL>

<DT><VAR>out_idx</VAR>
<DD>
<DT><VAR>in_idx</VAR>
<DD>
The names or indices of outputs and inputs to be used in the frequency
response.  See <CODE>sysprune</CODE>.

<STRONG>Example</STRONG>

<PRE>
bode(sys,[],"y_3",list("u_1","u_4");
</PRE>

</DL>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>mag</VAR>
<DD>
<DT><VAR>phase</VAR>
<DD>
the magnitude and phase of the frequency response @math{G(jw)} or
@math{G(<CODE>exp</CODE>(jwT))} at the selected frequency values.
<DT><VAR>w</VAR>
<DD>
the vector of frequency values used
</DL>

<P>
<STRONG>Notes</STRONG>

<OL>
<LI>If no output arguments are given, e.g.,


<PRE>
bode(sys);
</PRE>

bode plots the results to the screen.  Descriptive labels are
automatically placed.

Failure to include a concluding semicolon will yield some garbage
being printed to the screen (<CODE>ans = []</CODE>).

<LI>If the requested plot is for an MIMO system, mag is set to

@math{||G(jw)||} or @math{||G(<CODE>exp</CODE>(jwT))||}
and phase information is not computed.
</OL>

</DL>

<P>
@anchor{doc-bode_bounds}
<DL>
<DT><U>Function File:</U> [<VAR>wmin</VAR>, <VAR>wmax</VAR>] = <B>bode_bounds</B> <I>(<VAR>zer</VAR>, <VAR>pol</VAR>, <VAR>dflg</VAR>, <VAR>tsam</VAR>)</I>
<DD><A NAME="IDX1082"></A>
Get default range of frequencies based on cutoff frequencies of system
poles and zeros.
Frequency range is the interval [10^wmin,10^wmax]

</P>
<P>
Used internally in __freqresp__ (<CODE>bode</CODE>, <CODE>nyquist</CODE>)
</DL>

</P>

<P>
@anchor{doc-freqchkw}
<DL>
<DT><U>Function File:</U>  <B>freqchkw</B> <I>(<VAR>w</VAR>)</I>
<DD><A NAME="IDX1083"></A>
Used by <CODE>__freqresp__</CODE> to check that input frequency vector <VAR>w</VAR>
is valid.
Returns boolean value.
</DL>

</P>

<P>
@anchor{doc-ltifr}
<DL>
<DT><U>Function File:</U>  <B>ltifr</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>w</VAR>)</I>
<DD><A NAME="IDX1084"></A>
<DT><U>Function File:</U>  <B>ltifr</B> <I>(<VAR>sys</VAR>, <VAR>w</VAR>)</I>
<DD><A NAME="IDX1085"></A>
Linear time invariant frequency response of single input systems
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>a</VAR>
<DD>
<DT><VAR>b</VAR>
<DD>
coefficient matrices of @math{dx/dt = A x + B u}
<DT><VAR>sys</VAR>
<DD>
system data structure
<DT><VAR>w</VAR>
<DD>
vector of frequencies
</DL>
<P>
<STRONG>Outputs</STRONG>
<VAR>out</VAR>

<PRE>
                           -1
            G(s) = (jw I-A) B
</PRE>

<P>
for complex frequencies @math{s = jw}.
</DL>

</P>

<P>
@anchor{doc-nyquist}
<DL>
<DT><U>Function File:</U> [<VAR>realp</VAR>, <VAR>imagp</VAR>, <VAR>w</VAR>] = <B>nyquist</B> <I>(<VAR>sys</VAR>, <VAR>w</VAR>, <VAR>out_idx</VAR>, <VAR>in_idx</VAR>, <VAR>atol</VAR>)</I>
<DD><A NAME="IDX1086"></A>
<DT><U>Function File:</U>  <B>nyquist</B> <I>(<VAR>sys</VAR>, <VAR>w</VAR>, <VAR>out_idx</VAR>, <VAR>in_idx</VAR>, <VAR>atol</VAR>)</I>
<DD><A NAME="IDX1087"></A>
Produce Nyquist plots of a system; if no output arguments are given, Nyquist
plot is printed to the screen.

</P>
<P>
Compute the frequency response of a system.
<STRONG>Inputs</STRONG> (pass as empty to get default values)
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure (must be either purely continuous or discrete;
see is_digital)
<DT><VAR>w</VAR>
<DD>
frequency values for evaluation.
if sys is continuous, then bode evaluates @math{G(jw)}
if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where
@math{T} is the system sampling time.
<DT><VAR>default</VAR>
<DD>
the default frequency range is selected as follows: (These
steps are NOT performed if <VAR>w</VAR> is specified)
</DL>

<OL>
<LI>via routine __bodquist__, isolate all poles and zeros away from

<VAR>w</VAR>=0 (<VAR>jw</VAR>=0 or @math{exp(<VAR>jwT</VAR>)=1}) and select the frequency
range based on the breakpoint locations of the frequencies.
<LI>if <VAR>sys</VAR> is discrete time, the frequency range is limited

to <VAR>jwT</VAR> in
[0,2p*pi]
<LI>A "smoothing" routine is used to ensure that the plot phase does

not change excessively from point to point and that singular
points (e.g., crossovers from +/- 180) are accurately shown.
</OL>

<P>
outputs, inputs: names or indices of the output(s) and input(s) to be 
used in the frequency response; see sysprune.

</P>
<P>
<STRONG>Inputs</STRONG> (pass as empty to get default values)
<DL COMPACT>

<DT><VAR>atol</VAR>
<DD>
for interactive nyquist plots: atol is a change-in-slope tolerance
for the of asymptotes (default = 0; 1e-2 is a good choice).  This allows
the user to "zoom in" on portions of the Nyquist plot too small to be
seen with large asymptotes.
</DL>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>realp</VAR>
<DD>
<DT><VAR>imagp</VAR>
<DD>
the real and imaginary parts of the frequency response
@math{G(jw)} or @math{G(exp(jwT))} at the selected frequency values.
<DT><VAR>w</VAR>
<DD>
the vector of frequency values used
</DL>

<P>
If no output arguments are given, nyquist plots the results to the screen.
If <VAR>atol</VAR> != 0 and asymptotes are detected then the user is asked
interactively if they wish to zoom in (remove asymptotes)
Descriptive labels are automatically placed.

</P>
<P>
Note: if the requested plot is for an MIMO system, a warning message is
presented; the returned information is of the magnitude
||G(jw)|| or ||G(exp(jwT))|| only; phase information is not computed.
</DL>

</P>

<P>
@anchor{doc-tzero}
<DL>
<DT><U>Function File:</U>  <B>tzero</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1088"></A>
<DT><U>Function File:</U>  <B>tzero</B> <I>(<VAR>sys</VAR>, <VAR>opt</VAR>)</I>
<DD><A NAME="IDX1089"></A>
Compute transmission zeros of a continuous

<PRE>
.
x = Ax + Bu
y = Cx + Du
</PRE>

<P>
or discrete

<PRE>
x(k+1) = A x(k) + B u(k)
y(k)   = C x(k) + D u(k)
</PRE>

<P>
system.
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>zer</VAR>
<DD>
 transmission zeros of the system
<DT><VAR>gain</VAR>
<DD>
leading coefficient (pole-zero form) of SISO transfer function
returns gain=0 if system is multivariable
</DL>
<P>
<STRONG>References</STRONG>

<OL>
<LI>Emami-Naeini and Van Dooren, Automatica, 1982.

<LI>Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.

</OL>

</DL>

<P>
@anchor{doc-tzero2}
<DL>
<DT><U>Function File:</U>  <B>tzero2</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>, <VAR>bal</VAR>)</I>
<DD><A NAME="IDX1090"></A>
Compute the transmission zeros of a, b, c, d.

</P>
<P>
bal = balancing option (see balance); default is "B".

</P>
<P>
Needs to incorporate <CODE>mvzero</CODE> algorithm to isolate finite zeros; use
<CODE>tzero</CODE> instead.
</DL>

</P>



<H2><A NAME="SEC195" HREF="octave_toc.html#TOC195">Controller Design</A></H2>

<P>
@anchor{doc-dgkfdemo}
<DL>
<DT><U>Function File:</U>  <B>dgkfdemo</B> <I>()</I>
<DD><A NAME="IDX1091"></A>
Octave Controls toolbox demo: H2/Hinfinity options demos
</DL>

</P>

<P>
@anchor{doc-hinfdemo}
<DL>
<DT><U>Function File:</U>  <B>hinfdemo</B> <I>()</I>
<DD><A NAME="IDX1092"></A>

</P>
<P>
H_infinity design demos for continuous SISO and MIMO systems and a
discrete system.  The SISO system is difficult to control because it
is non minimum phase and unstable.  The second design example
controls the "jet707" plant, the linearized state space model of a
Boeing 707-321 aircraft at v=80m/s (M = 0.26, Ga0 = -3 deg, alpha0 =
4 deg, kappa = 50 deg).  Inputs: (1) thrust and (2) elevator angle
outputs: (1) airspeed and (2) pitch angle. The discrete system is a
stable and second order.

</P>
<DL COMPACT>

<DT>SISO plant
<DD>

<PRE>
                s - 2
     G(s) = --------------
            (s + 2)(s - 1)

                              +----+
         --------------------&#62;| W1 |---&#62; v1
     z   |                    +----+
     ----|-------------+                   || T   ||     =&#62; min.
         |             |                       vz   infty
         |    +---+    v   y  +----+
       u *---&#62;| G |---&#62;O--*--&#62;| W2 |---&#62; v2
         |    +---+       |   +----+
         |                |
         |    +---+       |
         -----| K |&#60;-------
              +---+
</PRE>

W1 und W2 are the robustness and performance weighting
functions

<DT>MIMO plant
<DD>
The optimal controller minimizes the H_infinity norm of the
augmented plant P (mixed-sensitivity problem):

<PRE>
     w
      1 -----------+
                   |                   +----+
               +----------------------&#62;| W1 |----&#62; z1
     w         |   |                   +----+
      2 ------------------------+
               |   |            |
               |   v   +----+   v      +----+
            +--*--&#62;o--&#62;| G  |--&#62;o--*--&#62;| W2 |---&#62; z2
            |          +----+      |   +----+
            |                      |
            ^                      v
             u (from                 y (to K)
               controller
               K)

                  +    +           +    +
                  | z  |           | w  |
                  |  1 |           |  1 |
                  | z  | = [ P ] * | w  |
                  |  2 |           |  2 |
                  | y  |           | u  |
                  +    +           +    +
</PRE>

<DT>DISCRETE SYSTEM
<DD>
This is not a true discrete design. The design is carried out
in continuous time while the effect of sampling is described by
a bilinear transformation of the sampled system.
This method works quite well if the sampling period is "small"
compared to the plant time constants.

<DT>The continuous plant
<DD>

<PRE>
                   1
     G (s) = --------------
      k      (s + 2)(s + 1)

</PRE>

is discretised with a ZOH (Sampling period = Ts = 1 second):

<PRE>

               0.199788z + 0.073498
     G(s) = --------------------------
            (z - 0.36788)(z - 0.13534)

                              +----+
         --------------------&#62;| W1 |---&#62; v1
     z   |                    +----+
     ----|-------------+                   || T   ||     =&#62; min.
         |             |                       vz   infty
         |    +---+    v      +----+
         *---&#62;| G |---&#62;O--*--&#62;| W2 |---&#62; v2
         |    +---+       |   +----+
         |                |
         |    +---+       |
         -----| K |&#60;-------
              +---+
</PRE>

W1 and W2 are the robustness and performancs weighting
functions
</DL>
</DL>

<P>
@anchor{doc-dlqe}
<DL>
<DT><U>Function File:</U> [<VAR>l</VAR>, <VAR>m</VAR>, <VAR>p</VAR>, <VAR>e</VAR>] = <B>dlqe</B> <I>(<VAR>a</VAR>, <VAR>g</VAR>, <VAR>c</VAR>, <VAR>sigw</VAR>, <VAR>sigv</VAR>, <VAR>z</VAR>)</I>
<DD><A NAME="IDX1093"></A>
Construct the linear quadratic estimator (Kalman filter) for the
discrete time system

</P>

<PRE>
x[k+1] = A x[k] + B u[k] + G w[k]
  y[k] = C x[k] + D u[k] + v[k]
</PRE>

<P>
where <VAR>w</VAR>, <VAR>v</VAR> are zero-mean gaussian noise processes with
respective intensities <CODE><VAR>sigw</VAR> = cov (<VAR>w</VAR>, <VAR>w</VAR>)</CODE> and
<CODE><VAR>sigv</VAR> = cov (<VAR>v</VAR>, <VAR>v</VAR>)</CODE>.

</P>
<P>
If specified, <VAR>z</VAR> is <CODE>cov (<VAR>w</VAR>, <VAR>v</VAR>)</CODE>.  Otherwise
<CODE>cov (<VAR>w</VAR>, <VAR>v</VAR>) = 0</CODE>.

</P>
<P>
The observer structure is

</P>

<PRE>
z[k|k] = z[k|k-1] + L (y[k] - C z[k|k-1] - D u[k])
z[k+1|k] = A z[k|k] + B u[k]
</PRE>

<P>
The following values are returned:

</P>
<DL COMPACT>

<DT><VAR>l</VAR>
<DD>
The observer gain,
(<VAR>a</VAR> - <VAR>a</VAR><VAR>l</VAR><VAR>c</VAR>).
is stable.

<DT><VAR>m</VAR>
<DD>
The Riccati equation solution.

<DT><VAR>p</VAR>
<DD>
The estimate error covariance after the measurement update.

<DT><VAR>e</VAR>
<DD>
The closed loop poles of
(<VAR>a</VAR> - <VAR>a</VAR><VAR>l</VAR><VAR>c</VAR>).
</DL>
</DL>

<P>
@anchor{doc-dlqr}
<DL>
<DT><U>Function File:</U> [<VAR>k</VAR>, <VAR>p</VAR>, <VAR>e</VAR>] = <B>dlqr</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>q</VAR>, <VAR>r</VAR>, <VAR>z</VAR>)</I>
<DD><A NAME="IDX1094"></A>
Construct the linear quadratic regulator for the discrete time system

</P>

<PRE>
x[k+1] = A x[k] + B u[k]
</PRE>

<P>
to minimize the cost functional

</P>

<PRE>
J = Sum (x' Q x + u' R u)
</PRE>

<P>
<VAR>z</VAR> omitted or

</P>

<PRE>
J = Sum (x' Q x + u' R u + 2 x' Z u)
</PRE>

<P>
<VAR>z</VAR> included.

</P>
<P>
The following values are returned:

</P>
<DL COMPACT>

<DT><VAR>k</VAR>
<DD>
The state feedback gain,
(<VAR>a</VAR> - <VAR>b</VAR><VAR>k</VAR>)
is stable.

<DT><VAR>p</VAR>
<DD>
The solution of algebraic Riccati equation.

<DT><VAR>e</VAR>
<DD>
The closed loop poles of
(<VAR>a</VAR> - <VAR>b</VAR><VAR>k</VAR>).
</DL>
</DL>

<P>
@anchor{doc-dkalman}
<DL>
<DT><U>Function File:</U> [<VAR>Lp</VAR>, <VAR>Lf</VAR>, <VAR>P</VAR>, <VAR>Z</VAR>] = <B>dkalman</B> <I>(<VAR>A</VAR>, <VAR>G</VAR>, <VAR>C</VAR>, <VAR>Qw</VAR>, <VAR>Rv</VAR>, <VAR>S</VAR>)</I>
<DD><A NAME="IDX1095"></A>
Construct the linear quadratic estimator (Kalman predictor) for the
discrete time system

</P>

<PRE>
x[k+1] = A x[k] + B u[k] + G w[k]
  y[k] = C x[k] + D u[k] + v[k]
</PRE>

<P>
where <VAR>w</VAR>, <VAR>v</VAR> are zero-mean gaussian noise processes with
respective intensities <CODE><VAR>Qw</VAR> = cov (<VAR>w</VAR>, <VAR>w</VAR>)</CODE> and
<CODE><VAR>Rv</VAR> = cov (<VAR>v</VAR>, <VAR>v</VAR>)</CODE>.

</P>
<P>
If specified, <VAR>S</VAR> is <CODE>cov (<VAR>w</VAR>, <VAR>v</VAR>)</CODE>.  Otherwise
<CODE>cov (<VAR>w</VAR>, <VAR>v</VAR>) = 0</CODE>.

</P>
<P>
The observer structure is

</P>

<PRE>
x[k+1|k] = A x[k|k-1] + B u[k] + LP (y[k] - C x[k|k-1] - D u[k])
x[k|k] = x[k|k-1] + LF (y[k] - C x[k|k-1] - D u[k])
</PRE>

<P>
The following values are returned:

</P>
<DL COMPACT>

<DT><VAR>Lp</VAR>
<DD>
The predictor gain,
(<VAR>A</VAR> - <VAR>Lp</VAR> <VAR>C</VAR>)
is stable.

<DT><VAR>Lf</VAR>
<DD>
The filter gain.

<DT><VAR>P</VAR>
<DD>
The Riccati solution. 

P = E [(x - x[n|n-1])(x - x[n|n-1])']

<DT><VAR>Z</VAR>
<DD>
The updated error covariance matrix.

Z = E [(x - x[n|n])(x - x[n|n])']
</DL>
</DL>

<P>
@anchor{doc-h2syn}
<DL>
<DT><U>Function File:</U> {[K}, <B><VAR>gain</VAR>,</B> <I><VAR>kc</VAR>, <VAR>kf</VAR>, <VAR>pc</VAR>, <VAR>pf</VAR>] = h2syn (<VAR>asys</VAR>, <VAR>nu</VAR>, <VAR>ny</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1096"></A>
Design H2 optimal controller per procedure in
Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
H2 and Hinf Control Problems", IEEE TAC August 1989

</P>
<P>
Discrete time control per Zhou, Doyle, and Glover, ROBUST AND OPTIMAL
CONTROL, Prentice-Hall, 1996

</P>
<P>
<STRONG>Inputs</STRONG> input system is passed as either
<DL COMPACT>

<DT><VAR>asys</VAR>
<DD>
system data structure (see ss2sys, sys2ss)

<UL>
<LI>controller is implemented for continuous time systems

<LI>controller is NOT implemented for discrete time systems

</UL>

<DT><VAR>nu</VAR>
<DD>
number of controlled inputs
<DT><VAR>ny</VAR>
<DD>
number of measured outputs
<DT><VAR>tol</VAR>
<DD>
threshhold for 0.  Default: 200*eps
</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>k</VAR>
<DD>
system controller
<DT><VAR>gain</VAR>
<DD>
optimal closed loop gain
<DT><VAR>kc</VAR>
<DD>
full information control (packed)
<DT><VAR>kf</VAR>
<DD>
state estimator (packed)
<DT><VAR>pc</VAR>
<DD>
ARE solution matrix for regulator subproblem
<DT><VAR>pf</VAR>
<DD>
ARE solution matrix for filter subproblem
</DL>
</DL>

<P>
@anchor{doc-hinf_ctr}
<DL>
<DT><U>Function File:</U>  <B>hinf_ctr</B> <I>(<VAR>dgs</VAR>, <VAR>f</VAR>, <VAR>h</VAR>, <VAR>z</VAR>, <VAR>g</VAR>)</I>
<DD><A NAME="IDX1097"></A>
Called by <CODE>hinfsyn</CODE> to compute the H_inf optimal controller.

</P>
<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>dgs</VAR>
<DD>
data structure returned by <CODE>is_dgkf</CODE>
<DT><VAR>f</VAR>
<DD>
<DT><VAR>h</VAR>
<DD>
feedback and filter gain (not partitioned)
<DT><VAR>g</VAR>
<DD>
final gamma value
</DL>
<P>
<STRONG>Outputs</STRONG>
controller (system data structure)

</P>
<P>
Do not attempt to use this at home; no argument checking performed.
</DL>

</P>

<P>
@anchor{doc-hinfsyn}
<DL>
<DT><U>Function File:</U> [<VAR>k</VAR>, <VAR>g</VAR>, <VAR>gw</VAR>, <VAR>xinf</VAR>, <VAR>yinf</VAR>] = <B>hinfsyn</B> <I>(<VAR>asys</VAR>, <VAR>nu</VAR>, <VAR>ny</VAR>, <VAR>gmin</VAR>, <VAR>gmax</VAR>, <VAR>gtol</VAR>, <VAR>ptol</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX1098"></A>

</P>
<P>
<STRONG>Inputs</STRONG> input system is passed as either
<DL COMPACT>

<DT><VAR>asys</VAR>
<DD>
system data structure (see ss2sys, sys2ss)

<UL>
<LI>controller is implemented for continuous time systems

<LI>controller is NOT implemented for discrete time systems  (see

bilinear transforms in <CODE>c2d</CODE>, <CODE>d2c</CODE>)
</UL>

<DT><VAR>nu</VAR>
<DD>
number of controlled inputs
<DT><VAR>ny</VAR>
<DD>
number of measured outputs
<DT><VAR>gmin</VAR>
<DD>
initial lower bound on H-infinity optimal gain
<DT><VAR>gmax</VAR>
<DD>
initial upper bound on H-infinity optimal gain
<DT><VAR>gtol</VAR>
<DD>
gain threshhold.  Routine quits when gmax/gmin &#60; 1+tol
<DT><VAR>ptol</VAR>
<DD>
poles with abs(real(pole)) &#60; ptol*||H|| (H is appropriate
Hamiltonian) are considered to be on the imaginary axis.
Default: 1e-9
<DT><VAR>tol</VAR>
<DD>
threshhold for 0.  Default: 200*eps

<VAR>gmax</VAR>, <VAR>min</VAR>, <VAR>tol</VAR>, and <VAR>tol</VAR> must all be postive scalars.
</DL>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>k</VAR>
<DD>
system controller
<DT><VAR>g</VAR>
<DD>
designed gain value
<DT><VAR>gw</VAR>
<DD>
closed loop system
<DT><VAR>xinf</VAR>
<DD>
ARE solution matrix for regulator subproblem
<DT><VAR>yinf</VAR>
<DD>
ARE solution matrix for filter subproblem
</DL>


<OL>
<LI>Doyle, Glover, Khargonekar, Francis, "State Space Solutions

to Standard H2 and Hinf Control Problems," IEEE TAC August 1989

<LI>Maciejowksi, J.M., "Multivariable feedback design,"

Addison-Wesley, 1989, ISBN 0-201-18243-2

<LI>Keith Glover and John C. Doyle, "State-space formulae for all

stabilizing controllers that satisfy and h-infinity-norm bound
and relations to risk sensitivity,"
Systems &#38; Control Letters 11, Oct. 1988, pp 167-172.
</OL>

</DL>

<P>
@anchor{doc-hinfsyn_chk}
<DL>
<DT><U>Function File:</U> [<VAR>retval</VAR>, <VAR>pc</VAR>, <VAR>pf</VAR>] = <B>hinfsyn_chk</B> <I>(<VAR>a</VAR>, <VAR>b1</VAR>, <VAR>b2</VAR>, <VAR>c1</VAR>, <VAR>c2</VAR>, <VAR>d12</VAR>, <VAR>d21</VAR>, <VAR>g</VAR>, <VAR>ptol</VAR>)</I>
<DD><A NAME="IDX1099"></A>
Called by <CODE>hinfsyn</CODE> to see if gain <VAR>g</VAR> satisfies conditions in
Theorem 3 of
Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
H2 and Hinf Control Problems", IEEE TAC August 1989

</P>
<P>
<STRONG>Warning</STRONG> Do not attempt to use this at home; no argument
checking performed.

</P>
<P>
<STRONG>Inputs</STRONG> as returned by <CODE>is_dgkf</CODE>, except for:
<DL COMPACT>

<DT><VAR>g</VAR>
<DD>
candidate gain level
<DT><VAR>ptol</VAR>
<DD>
 as in <CODE>hinfsyn</CODE>
</DL>

<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>retval</VAR>
<DD>
 1 if g exceeds optimal Hinf closed loop gain, else 0
<DT><VAR>pc</VAR>
<DD>
 solution of "regulator" H-inf ARE
<DT><VAR>pf</VAR>
<DD>
 solution of "filter" H-inf ARE
</DL>
<P>
Do not attempt to use this at home; no argument checking performed.
</DL>

</P>

<P>
@anchor{doc-hinfsyn_ric}
<DL>
<DT><U>Function File:</U> [<VAR>xinf</VAR>, <VAR>x_ha_err</VAR>] = <B>hinfsyn_ric</B> <I>(<VAR>a</VAR>, <VAR>bb</VAR>, <VAR>c1</VAR>, <VAR>d1dot</VAR>, <VAR>r</VAR>, <VAR>ptol</VAR>)</I>
<DD><A NAME="IDX1100"></A>
Forms

<PRE>
xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
Ha = [A 0*A; -C1'*C1 -A'] - xx;
</PRE>

<P>
and solves associated Riccati equation.
The error code <VAR>x_ha_err</VAR> indicates one of the following
conditions:
<DL COMPACT>

<DT>0
<DD>
successful
<DT>1
<DD>
<VAR>xinf</VAR> has imaginary eigenvalues
<DT>2
<DD>
<VAR>hx</VAR> not Hamiltonian
<DT>3
<DD>
<VAR>xinf</VAR> has infinite eigenvalues (numerical overflow)
<DT>4
<DD>
<VAR>xinf</VAR> not symmetric
<DT>5
<DD>
<VAR>xinf</VAR> not positive definite
<DT>6
<DD>
<VAR>r</VAR> is singular
</DL>
</DL>

<P>
@anchor{doc-lqe}
<DL>
<DT><U>Function File:</U> [<VAR>k</VAR>, <VAR>p</VAR>, <VAR>e</VAR>] = <B>lqe</B> <I>(<VAR>a</VAR>, <VAR>g</VAR>, <VAR>c</VAR>, <VAR>sigw</VAR>, <VAR>sigv</VAR>, <VAR>z</VAR>)</I>
<DD><A NAME="IDX1101"></A>
Construct the linear quadratic estimator (Kalman filter) for the
continuous time system

</P>

<PRE>
dx
-- = a x + b u
dt

y = c x + d u
</PRE>

<P>
where <VAR>w</VAR> and <VAR>v</VAR> are zero-mean gaussian noise processes with
respective intensities

</P>

<PRE>
sigw = cov (w, w)
sigv = cov (v, v)
</PRE>

<P>
The optional argument <VAR>z</VAR> is the cross-covariance
<CODE>cov (<VAR>w</VAR>, <VAR>v</VAR>)</CODE>.  If it is omitted,
<CODE>cov (<VAR>w</VAR>, <VAR>v</VAR>) = 0</CODE> is assumed.

</P>
<P>
Observer structure is <CODE>dz/dt = A z + B u + k (y - C z - D u)</CODE>

</P>
<P>
The following values are returned:

</P>
<DL COMPACT>

<DT><VAR>k</VAR>
<DD>
The observer gain,
(<VAR>a</VAR> - <VAR>k</VAR><VAR>c</VAR>)
is stable.

<DT><VAR>p</VAR>
<DD>
The solution of algebraic Riccati equation.

<DT><VAR>e</VAR>
<DD>
The vector of closed loop poles of
(<VAR>a</VAR> - <VAR>k</VAR><VAR>c</VAR>).
</DL>
</DL>

<P>
@anchor{doc-lqg}
<DL>
<DT><U>Function File:</U> [<VAR>k</VAR>, <VAR>q1</VAR>, <VAR>p1</VAR>, <VAR>ee</VAR>, <VAR>er</VAR>] = <B>lqg</B> <I>(<VAR>sys</VAR>, <VAR>sigw</VAR>, <VAR>sigv</VAR>, <VAR>q</VAR>, <VAR>r</VAR>, <VAR>in_idx</VAR>)</I>
<DD><A NAME="IDX1102"></A>
Design a linear-quadratic-gaussian optimal controller for the system

<PRE>
dx/dt = A x + B u + G w       [w]=N(0,[Sigw 0    ])
    y = C x + v               [v]  (    0   Sigv ])
</PRE>

<P>
or

<PRE>
x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
  y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])
</PRE>

<P>
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>sys</VAR>
<DD>
system data structure
<DT><VAR>sigw</VAR>
<DD>
<DT><VAR>sigv</VAR>
<DD>
intensities of independent Gaussian noise processes (as above)
<DT><VAR>q</VAR>
<DD>
<DT><VAR>r</VAR>
<DD>
state, control weighting respectively.  Control ARE is
<DT><VAR>in_idx</VAR>
<DD>
names or indices of controlled inputs (see <CODE>sysidx</CODE>, <CODE>listidx</CODE>)

default: last dim(R) inputs are assumed to be controlled inputs, all
others are assumed to be noise inputs.
</DL>
<P>
<STRONG>Outputs</STRONG>
<DL COMPACT>

<DT><VAR>k</VAR>
<DD>
system data structure format LQG optimal controller (Obtain A,B,C
matrices with <CODE>sys2ss</CODE>, <CODE>sys2tf</CODE>, or <CODE>sys2zp</CODE> as
appropriate)
<DT><VAR>p1</VAR>
<DD>
Solution of control (state feedback) algebraic Riccati equation
<DT><VAR>q1</VAR>
<DD>
Solution of estimation algebraic Riccati equation
<DT><VAR>ee</VAR>
<DD>
estimator poles
<DT><VAR>es</VAR>
<DD>
controller poles
</DL>
</DL>
<P>
@seealso{h2syn, lqe, and lqr}

</P>

<P>
@anchor{doc-lqr}
<DL>
<DT><U>Function File:</U> [<VAR>k</VAR>, <VAR>p</VAR>, <VAR>e</VAR>] = <B>lqr</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>q</VAR>, <VAR>r</VAR>, <VAR>z</VAR>)</I>
<DD><A NAME="IDX1103"></A>
construct the linear quadratic regulator for the continuous time system

</P>

<PRE>
dx
-- = A x + B u
dt
</PRE>

<P>
to minimize the cost functional

</P>

<PRE>
      infinity
      /
  J = |  x' Q x + u' R u
     /
    t=0
</PRE>

<P>
<VAR>z</VAR> omitted or

</P>

<PRE>
      infinity
      /
  J = |  x' Q x + u' R u + 2 x' Z u
     /
    t=0
</PRE>

<P>
<VAR>z</VAR> included.

</P>
<P>
The following values are returned:

</P>
<DL COMPACT>

<DT><VAR>k</VAR>
<DD>
The state feedback gain,
(<VAR>a</VAR> - <VAR>b</VAR><VAR>k</VAR>)
is stable and minimizes the cost functional

<DT><VAR>p</VAR>
<DD>
The stabilizing solution of appropriate algebraic Riccati equation.

<DT><VAR>e</VAR>
<DD>
The vector of the closed loop poles of
(<VAR>a</VAR> - <VAR>b</VAR><VAR>k</VAR>).
</DL>

<P>
<STRONG>Reference</STRONG>
Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC METHODS,
Prentice-Hall, 1990, pp. 56-58
</DL>

</P>

<P>
@anchor{doc-lsim}
<DL>
<DT><U>Function File:</U>  <B>lsim</B> <I>(<VAR>sys</VAR>, <VAR>u</VAR>, <VAR>t</VAR>, <VAR>x0</VAR>)</I>
<DD><A NAME="IDX1104"></A>
Produce output for a linear simulation of a system

</P>
<P>
Produces a plot for the output of the system, sys.

</P>
<P>
U is an array that contains the system's inputs.  Each column in u
corresponds to a different time step.  Each row in u corresponds to a
different input.  T is an array that contains the time index of the
system.  T should be regularly spaced.  If initial conditions are required
on the system, the x0 vector should be added to the argument list.

</P>
<P>
When the lsim function is invoked with output parameters:
[y,x] = lsim(sys,u,t,[x0])
a plot is not displayed, however, the data is returned in y = system output
and x = system states.
</DL>

</P>

<P>
@anchor{doc-place}
<DL>
<DT><U>Function File:</U>  <B>place</B> <I>(<VAR>sys</VAR>, <VAR>p</VAR>)</I>
<DD><A NAME="IDX1105"></A>
Computes the matrix  K such that if the state
is feedback with gain K, then the eigenvalues  of the closed loop
system (i.e. A-BK) are those specified in the vector <VAR>p</VAR>.

</P>
<P>
Version: Beta (May-1997): If you have any comments, please let me know.
(see the file place.m for my address)
</DL>

</P>



<H2><A NAME="SEC196" HREF="octave_toc.html#TOC196">Miscellaneous Functions (Not yet properly filed/documented)</A></H2>

<P>
@anchor{doc-axis2dlim}
<DL>
<DT><U>@deftypefn{Function File}:</U>  <B>axis2dlim</B> <I>(<VAR>axdata</VAR>)</I>
<DD><A NAME="IDX1106"></A>
determine axis limits for 2-d data(column vectors); leaves a 10% margin
around the plots.
puts in margins of +/- 0.1 if data is one dimensional (or a single point)

</P>
<P>
<STRONG>Inputs</STRONG>
<VAR>axdata</VAR> nx2 matrix of data [x,y]

</P>
<P>
<STRONG>Outputs</STRONG>
<VAR>axvec</VAR> vector of axis limits appropriate for call to axis() function
</DL>

</P>

<P>
@anchor{doc-moddemo}
<DL>
<DT><U>Function File:</U>  <B>moddemo</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1107"></A>
Octave Controls toolbox demo: Model Manipulations demo
</DL>

</P>

<P>
@anchor{doc-prompt}
<DL>
<DT><U>Function File:</U>  <B>prompt</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1108"></A>

<PRE>
function prompt([str])
Prompt user to continue
str: input string. Default value: "\n ---- Press a key to continue ---"
</PRE>

</DL>

<P>
@anchor{doc-rldemo}
<DL>
<DT><U>Function File:</U>  <B>rldemo</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1109"></A>
Octave Controls toolbox demo: Root Locus demo
</DL>

</P>

<P>
@anchor{doc-rlocus}
<DL>
<DT><U>Function File:</U>  <B>rlocus</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1110"></A>

<PRE>
[rldata, k] = rlocus(sys[,increment,min_k,max_k])
Displays root locus plot of the specified SISO system.

       -----   --     --------
   ---&#62;| + |---|k|----&#62;| SISO |-----------&#62;
       -----   --     --------        |
       - ^                             |
         |_____________________________|

inputs: sys = system data structure
min_k, max_k,increment: minimum, maximum values of k and
the increment used in computing gain values
Outputs: plots the root locus to the screen.
rldata: Data points plotted column 1: real values, column 2: imaginary
values)
k: gains for real axis break points.
</PRE>

</DL>

<P>
@anchor{doc-sortcom}
<DL>
<DT><U>Function File:</U>  <B>sortcom</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1111"></A>

<PRE>
[yy,idx] = sortcom(xx[,opt]): sort a complex vector
xx: complex vector
opt: sorting option:
 "re": real part (default)
 "mag": by magnitude
 "im": by imaginary part

if opt != "im" then complex conjugate pairs are grouped together,
a - jb followed by a + jb.
yy: sorted values
idx: permutation vector: yy = xx(idx)
</PRE>

</DL>

<P>
@anchor{doc-ss2tf}
<DL>
<DT><U>Function File:</U>  <B>ss2tf</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1112"></A>

<PRE>
[num,den] = ss2tf(a,b,c,d)
Conversion from tranfer function to state-space.
The state space system
      .
      x = Ax + Bu
      y = Cx + Du

is converted to a transfer function

                num(s)
          G(s)=-------
                den(s)

used internally in system data structure format manipulations
</PRE>

</DL>

<P>
@anchor{doc-ss2zp}
<DL>
<DT><U>Function File:</U>  <B>ss2zp</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1113"></A>

<PRE>
Converts a state space representation to a set of poles and zeros.

[pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space
system (a,b,c,d).  K is a gain associated with the zeros.

used internally in system data structure format manipulations
</PRE>

</DL>

<P>
@anchor{doc-starp}
<DL>
<DT><U>Function File:</U>  <B>starp</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1114"></A>

<PRE>

sys = starp(P, K, ny, nu)

Redheffer star product or upper/lower LFT, respectively.

               +-------+
     ---------&#62;|       |---------&#62;
               |   P   |
          +---&#62;|       |---+  ny
          |    +-------+   |
          +-------------------+
                           |  |
          +----------------+  |
          |                   |
          |    +-------+      |
          +---&#62;|       |------+ nu
               |   K   |
     ---------&#62;|       |---------&#62;
               +-------+

If ny and nu "consume" all inputs and outputs of K then the result
is a lower fractional transformation. If ny and nu "consume" all
inputs and outputs of P then the result is an upper fractional
transformation.

ny and/or nu may be negative (= negative feedback)
</PRE>

</DL>

<P>
@anchor{doc-tf2ss}
<DL>
<DT><U>Function File:</U>  <B>tf2ss</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1115"></A>

<PRE>
Conversion from tranfer function to state-space.
The state space system
      .
      x = Ax + Bu
      y = Cx + Du

is obtained from a transfer function

                num(s)
          G(s)=-------
                den(s)

via the function call [a,b,c,d] = tf2ss(num,den).
The vector 'den' must contain only one row, whereas the vector 'num'
may contain as many rows as there are outputs of the system 'y'.
The state space system matrices obtained from this function will be
in controllable canonical form as described in "Modern Control Theory",
[Brogan, 1991].

</PRE>

</DL>

<P>
@anchor{doc-tf2zp}
<DL>
<DT><U>Function File:</U>  <B>tf2zp</B> <I>(<VAR>inputs</VAR>)</I>
<DD><A NAME="IDX1116"></A>
Converts transfer functions to poles / zeros.

</P>
<P>
[zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
defined by num/den.  K is a gain associated with the system zeros.
</DL>

</P>

<P>
@anchor{doc-zp2ss}
<DL>
<DT><U>Function File:</U> [<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>] = <B>zp2ss</B> <I>(<VAR>zer</VAR>, <VAR>pol</VAR>, <VAR>k</VAR>)</I>
<DD><A NAME="IDX1117"></A>
Conversion from zero / pole to state space.
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>zer</VAR>
<DD>
<DT><VAR>pol</VAR>
<DD>
vectors of (possibly) complex poles and zeros of a transfer
function.  Complex values must come in conjugate pairs
(i.e., x+jy in zer means that x-jy is also in zer)
<DT><VAR>k</VAR>
<DD>
real scalar (leading coefficient)
</DL>
<P>
<STRONG>Outputs</STRONG>
<VAR>a</VAR>, <VAR>b</VAR>, <VAR>c</VAR>, <VAR>d</VAR>
The state space system

<PRE>
.
x = Ax + Bu
y = Cx + Du
</PRE>

<P>
is obtained from a vector of zeros and a vector of poles via the
function call <CODE>[a,b,c,d] = zp2ss(zer,pol,k)</CODE>.
The vectors <SAMP>`zer'</SAMP> and
<SAMP>`pol'</SAMP> may either be row or column vectors.  Each zero and pole that
has an imaginary part must have a conjugate in the list.
The number of zeros must not exceed the number of poles.
<SAMP>`k'</SAMP> is <CODE>zp</CODE>-form leading coefficient.
</DL>

</P>

<P>
@anchor{doc-zp2tf}
<DL>
<DT><U>Function File:</U> [<VAR>num</VAR>, <VAR>den</VAR>] = <B>zp2tf</B> <I>(<VAR>zer</VAR>, <VAR>pol</VAR>, <VAR>k</VAR>)</I>
<DD><A NAME="IDX1118"></A>
Converts zeros / poles to a transfer function.
<STRONG>Inputs</STRONG>
<DL COMPACT>

<DT><VAR>zer</VAR>
<DD>
<DT><VAR>pol</VAR>
<DD>
vectors of (possibly complex) poles and zeros of a transfer
function.  Complex values should appear in conjugate pairs
<DT><VAR>k</VAR>
<DD>
real scalar (leading coefficient)
</DL>
<P>
<CODE>[num,den] = zp2tf(zer,pol,k)</CODE> forms the transfer function
<CODE>num/den</CODE> from the vectors of poles and zeros.
</DL>

</P>

<P><HR><P>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_28.html">previous</A>, <A HREF="octave_30.html">next</A>, <A HREF="octave_44.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
</BODY>
</HTML>
