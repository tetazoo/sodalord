<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from octave.texi on 1 May 2002 -->

<TITLE>GNU Octave - Polynomial Manipulations</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_27.html">previous</A>, <A HREF="octave_29.html">next</A>, <A HREF="octave_44.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC175" HREF="octave_toc.html#TOC175">Polynomial Manipulations</A></H1>

<P>
In Octave, a polynomial is represented by its coefficients (arranged
in descending order).  For example, a vector
 $c$
of length
 <VAR>N</VAR>

</P>

<PRE>
p(x) = <VAR>c</VAR>(1) x^<VAR>N</VAR> + ... + <VAR>c</VAR>(<VAR>N</VAR>) x + <VAR>c</VAR>(<VAR>N</VAR>+1).
</PRE>

<P>
@anchor{doc-compan}
<DL>
<DT><U>Function File:</U>  <B>compan</B> <I>(<VAR>c</VAR>)</I>
<DD><A NAME="IDX973"></A>
Compute the companion matrix corresponding to polynomial coefficient
vector <VAR>c</VAR>.

</P>
<P>
The companion matrix is

</P>

<PRE>
     _                                                        _
    |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
    |       1            0      ...       0             0      |
    |       0            1      ...       0             0      |
A = |       .            .   .            .             .      |
    |       .            .       .        .             .      |
    |       .            .           .    .             .      |
    |_      0            0      ...       1             0     _|
</PRE>

<P>
The eigenvalues of the companion matrix are equal to the roots of the
polynomial.
</DL>
@seealso{poly, roots, residue, conv, deconv, polyval, polyderiv, and
polyinteg}

</P>

<P>
@anchor{doc-conv}
<DL>
<DT><U>Function File:</U>  <B>conv</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX974"></A>
Convolve two vectors.

</P>
<P>
<CODE>y = conv (a, b)</CODE> returns a vector of length equal to
<CODE>length (a) + length (b) - 1</CODE>.
If <VAR>a</VAR> and <VAR>b</VAR> are polynomial coefficient vectors, <CODE>conv</CODE>
returns the coefficients of the product polynomial.
</DL>
@seealso{deconv, poly, roots, residue, polyval, polyderiv, and polyinteg}

</P>

<P>
@anchor{doc-deconv}
<DL>
<DT><U>Function File:</U>  <B>deconv</B> <I>(<VAR>y</VAR>, <VAR>a</VAR>)</I>
<DD><A NAME="IDX975"></A>
Deconvolve two vectors.

</P>
<P>
<CODE>[b, r] = deconv (y, a)</CODE> solves for <VAR>b</VAR> and <VAR>r</VAR> such that
<CODE>y = conv (a, b) + r</CODE>.

</P>
<P>
If <VAR>y</VAR> and <VAR>a</VAR> are polynomial coefficient vectors, <VAR>b</VAR> will
contain the coefficients of the polynomial quotient and <VAR>r</VAR> will be
a remander polynomial of lowest order.
</DL>
@seealso{conv, poly, roots, residue, polyval, polyderiv, and polyinteg}

</P>

<P>
@anchor{doc-poly}
<DL>
<DT><U>Function File:</U>  <B>poly</B> <I>(<VAR>a</VAR>)</I>
<DD><A NAME="IDX976"></A>
If <VAR>a</VAR> is a square @math{N}-by-@math{N} matrix, <CODE>poly (<VAR>a</VAR>)</CODE>
is the row vector of the coefficients of <CODE>det (z * eye (N) - a)</CODE>,
the characteristic polynomial of <VAR>a</VAR>.  If <VAR>x</VAR> is a vector,
<CODE>poly (<VAR>x</VAR>)</CODE> is a vector of coefficients of the polynomial
whose roots are the elements of <VAR>x</VAR>.
</DL>

</P>

<P>
@anchor{doc-polyderiv}
<DL>
<DT><U>Function File:</U>  <B>polyderiv</B> <I>(<VAR>c</VAR>)</I>
<DD><A NAME="IDX977"></A>
Return the coefficients of the derivative of the polynomial whose
coefficients are given by vector <VAR>c</VAR>.
</DL>
@seealso{poly, polyinteg, polyreduce, roots, conv, deconv, residue,
filter, polyval, and polyvalm}

</P>

<P>
@anchor{doc-polyfit}
<DL>
<DT><U>Function File:</U> [<VAR>p</VAR>, <VAR>yf</VAR>] = <B>polyfit</B> <I>(<VAR>x</VAR>, <VAR>y</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX978"></A>
Return the coefficients of a polynomial <VAR>p</VAR>(<VAR>x</VAR>) of degree
<VAR>n</VAR> that minimizes
<CODE>sumsq (p(x(i)) - y(i))</CODE>,
 to best fit the data in the least squares sense.

</P>
<P>
The polynomial coefficients are returned in a row vector if <VAR>x</VAR>
and <VAR>y</VAR> are both row vectors; otherwise, they are returned in a
column vector.

</P>
<P>
If two output arguments are requested, the second contains the values of
the polynomial for each value of <VAR>x</VAR>.
</DL>

</P>

<P>
@anchor{doc-polyinteg}
<DL>
<DT><U>Function File:</U>  <B>polyinteg</B> <I>(<VAR>c</VAR>)</I>
<DD><A NAME="IDX979"></A>
Return the coefficients of the integral of the polynomial whose
coefficients are represented by the vector <VAR>c</VAR>.

</P>
<P>
The constant of integration is set to zero.
</DL>
@seealso{poly, polyderiv, polyreduce, roots, conv, deconv, residue,
filter, polyval, and polyvalm}

</P>

<P>
@anchor{doc-polyreduce}
<DL>
<DT><U>Function File:</U>  <B>polyreduce</B> <I>(<VAR>c</VAR>)</I>
<DD><A NAME="IDX980"></A>
Reduces a polynomial coefficient vector to a minimum number of terms by
stripping off any leading zeros.
</DL>
@seealso{poly, roots, conv, deconv, residue, filter, polyval,
polyvalm, polyderiv, and polyinteg}

</P>

<P>
@anchor{doc-polyval}
<DL>
<DT><U>Function File:</U>  <B>polyval</B> <I>(<VAR>c</VAR>, <VAR>x</VAR>)</I>
<DD><A NAME="IDX981"></A>
Evaluate a polynomial.

</P>
<P>
<CODE>polyval (<VAR>c</VAR>, <VAR>x</VAR>)</CODE> will evaluate the polynomial at the
specified value of <VAR>x</VAR>.

</P>
<P>
If <VAR>x</VAR> is a vector or matrix, the polynomial is evaluated at each of
the elements of <VAR>x</VAR>.
</DL>
@seealso{polyvalm, poly, roots, conv, deconv, residue, filter,
polyderiv, and polyinteg}

</P>

<P>
@anchor{doc-polyvalm}
<DL>
<DT><U>Function File:</U>  <B>polyvalm</B> <I>(<VAR>c</VAR>, <VAR>x</VAR>)</I>
<DD><A NAME="IDX982"></A>
Evaluate a polynomial in the matrix sense.

</P>
<P>
<CODE>polyvalm (<VAR>c</VAR>, <VAR>x</VAR>)</CODE> will evaluate the polynomial in the
matrix sense, i.e. matrix multiplication is used instead of element by
element multiplication as is used in polyval.

</P>
<P>
The argument <VAR>x</VAR> must be a square matrix.
</DL>
@seealso{polyval, poly, roots, conv, deconv, residue, filter,
polyderiv, and polyinteg}

</P>

<P>
@anchor{doc-residue}
<DL>
<DT><U>Function File:</U>  <B>residue</B> <I>(<VAR>b</VAR>, <VAR>a</VAR>, <VAR>tol</VAR>)</I>
<DD><A NAME="IDX983"></A>
If <VAR>b</VAR> and <VAR>a</VAR> are vectors of polynomial coefficients, then
residue calculates the partial fraction expansion corresponding to the
ratio of the two polynomials.
<A NAME="IDX984"></A>

</P>
<P>
The function <CODE>residue</CODE> returns <VAR>r</VAR>, <VAR>p</VAR>, <VAR>k</VAR>, and
<VAR>e</VAR>, where the vector <VAR>r</VAR> contains the residue terms, <VAR>p</VAR>
contains the pole values, <VAR>k</VAR> contains the coefficients of a direct
polynomial term (if it exists) and <VAR>e</VAR> is a vector containing the
powers of the denominators in the partial fraction terms.

</P>
<P>
Assuming <VAR>b</VAR> and <VAR>a</VAR> represent polynomials
 P (s) and Q(s)
 we have:

</P>

<PRE>
 P(s)    M       r(m)         N
 ---- = SUM -------------  + SUM k(i)*s^(N-i)
 Q(s)   m=1 (s-p(m))^e(m)    i=1
</PRE>

<P>
where @math{M} is the number of poles (the length of the <VAR>r</VAR>,
<VAR>p</VAR>, and <VAR>e</VAR> vectors) and @math{N} is the length of the
<VAR>k</VAR> vector.

</P>
<P>
The argument <VAR>tol</VAR> is optional, and if not specified, a default
value of 0.001 is assumed.  The tolerance value is used to determine
whether poles with small imaginary components are declared real.  It is
also used to determine if two poles are distinct.  If the ratio of the
imaginary part of a pole to the real part is less than <VAR>tol</VAR>, the
imaginary part is discarded.  If two poles are farther apart than
<VAR>tol</VAR> they are distinct.  For example,

</P>

<PRE>
 b = [1, 1, 1];
 a = [1, -5, 8, -4];
 [r, p, k, e] = residue (b, a);
=> r = [-2, 7, 3]
=> p = [2, 2, 1]
=> k = [](0x0)
=> e = [1, 2, 1]
</PRE>

<P>
which implies the following partial fraction expansion

</P>

<PRE>
        s^2 + s + 1       -2        7        3
   ------------------- = ----- + ------- + -----
   s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
</PRE>

</DL>
<P>
@seealso{poly, roots, conv, deconv, polyval, polyderiv, and polyinteg}

</P>

<P>
@anchor{doc-roots}
<DL>
<DT><U>Function File:</U>  <B>roots</B> <I>(<VAR>v</VAR>)</I>
<DD><A NAME="IDX985"></A>

</P>
<P>
For a vector <VAR>v</VAR> with @math{N} components, return
the roots of the polynomial

</P>

<PRE>
v(1) * z^(N-1) + ... + v(N-1) * z + v(N).
</PRE>

</DL>

<P>
@anchor{doc-polyout}
<DL>
<DT><U>Function File:</U> polyout <B>(<VAR>c</VAR>,</B> <I><VAR>x</VAR>)</I>
<DD><A NAME="IDX986"></A>
Write formatted polynomial

<PRE>
   c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
</PRE>

<P>
 and return it as a string or write it to the screen (if
<VAR>nargout</VAR> is zero).
<VAR>x</VAR> defaults to the string <CODE>"s"</CODE>
</DL>
@seealso{polyval, polyvalm, poly, roots, conv, deconv, residue,
filter, polyderiv, and polyinteg}

</P>

<P><HR><P>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_27.html">previous</A>, <A HREF="octave_29.html">next</A>, <A HREF="octave_44.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
</BODY>
</HTML>
