 XDEFUN_DLD_INTERNAL (balance, args, nargout, 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})\n@deftypefnx {Loadable Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})\n@deftypefnx {Loadable Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb}] =} balance (@var{a}, @var{b}, @var{opt})\n\n@code{[dd, aa] = balance (a)} returns @code{aa = dd \\ a * dd}.\n@code{aa} is a matrix whose row and column norms are roughly equal in\nmagnitude, and @code{dd} = @code{p * d}, where @code{p} is a permutation\nmatrix and @code{d} is a diagonal matrix of powers of two.  This allows\nthe equilibration to be computed without roundoff.  Results of\neigenvalue calculation are typically improved by balancing first.\n\n@code{[cc, dd, aa, bb] = balance (a, b)} returns @code{aa = cc*a*dd} and\n@code{bb = cc*b*dd)}, where @code{aa} and @code{bb} have non-zero\nelements of approximately the same magnitude and @code{cc} and @code{dd}\nare permuted diagonal matrices as in @code{dd} for the algebraic\neigenvalue problem.\n\nThe eigenvalue balancing option @code{opt} is selected as follows:\n\n@table @asis\n@item @code{\"N\"}, @code{\"n\"}\nNo balancing; arguments copied, transformation(s) set to identity.\n\n@item @code{\"P\"}, @code{\"p\"}\nPermute argument(s) to isolate eigenvalues where possible.\n\n@item @code{\"S\"}, @code{\"s\"}\nScale to improve accuracy of computed eigenvalues.\n\n@item @code{\"B\"}, @code{\"b\"}\nPermute and scale, in that order. Rows/columns of a (and b)\nthat are isolated by permutation are not scaled.  This is the default\nbehavior.\n@end table\n\nAlgebraic eigenvalue balancing uses standard @sc{Lapack} routines.\n\nGeneralized eigenvalue problem balancing uses Ward's algorithm\n(SIAM Journal on Scientific and Statistical Computing, 1981).\n@end deftypefn") 
