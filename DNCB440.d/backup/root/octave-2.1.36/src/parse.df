 XDEFUN_INTERNAL (source, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} source (@var{file})\nParse and execute the contents of @var{file}.  This is equivalent to\nexecuting commands from a script file, but without requiring the file to\nbe named @file{@var{file}.m}.\n@end deftypefn") 
 XDEFUN_INTERNAL (feval, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} feval (@var{name}, @dots{})\nEvaluate the function named @var{name}.  Any arguments after the first\nare passed on to the named function.  For example,\n\n@example\nfeval (\"acos\", -1)\n     @result{} 3.1416\n@end example\n\n@noindent\ncalls the function @code{acos} with the argument @samp{-1}.\n\nThe function @code{feval} is necessary in order to be able to write\nfunctions that call user-supplied functions, because Octave does not\nhave a way to declare a pointer to a function (like C) or to declare a\nspecial kind of variable that can be used to hold the name of a function\n(like @code{EXTERNAL} in Fortran).  Instead, you must refer to functions\nby name, and use @code{feval} to call them.\n@end deftypefn") 
 XDEFUN_INTERNAL (eval, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} eval (@var{try}, @var{catch})\nParse the string @var{try} and evaluate it as if it were an Octave\nprogram, returning the last value computed.  If that fails, evaluate\nthe string @var{catch}.  The string @var{try} is evaluated in the\ncurrent context, so any results remain available after @code{eval}\nreturns.  For example,\n\n@example\n@group\neval (\"a = 13\")\n     @print{} a = 13\n     @result{} 13\n@end group\n@end example\n\nIn this case, the value of the evaluated expression is printed and it is\nalso returned returned from @code{eval}.  Just as with any other\nexpression, you can turn printing off by ending the expression in a\nsemicolon.  For example,\n\n@example\neval (\"a = 13;\")\n     @result{} 13\n@end example\n\nIn this example, the variable @code{a} has been given the value 13, but\nthe value of the expression is not printed.  You can also turn off\nautomatic printing for all expressions executed by @code{eval} using the\nvariable @code{default_eval_print_flag}.\n@end deftypefn") 
   XDEFVAR_INTERNAL("default_eval_print_flag", SBV_default_eval_print_flag, 1.0, false, default_eval_print_flag, "-*- texinfo -*-\n@defvr {Built-in Variable} default_eval_print_flag\nIf the value of this variable is nonzero, Octave prints the results of\ncommands executed by @code{eval} that do not end with semicolons.  If it\nis zero, automatic printing is suppressed.  The default value is 1.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_assign_as_truth_value", SBV_warn_assign_as_truth_value, 1.0, false, warn_assign_as_truth_value, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_assign_as_truth_value\nIf the value of @code{warn_assign_as_truth_value} is nonzero, a\nwarning is issued for statements like\n\n@example\nif (s = t)\n  ...\n@end example\n\n@noindent\nsince such statements are not common, and it is likely that the intent\nwas to write\n\n@example\nif (s == t)\n  ...\n@end example\n\n@noindent\ninstead.\n\nThere are times when it is useful to write code that contains\nassignments within the condition of a @code{while} or @code{if}\nstatement.  For example, statements like\n\n@example\nwhile (c = getc())\n  ...\n@end example\n\n@noindent\nare common in C programming.\n\nIt is possible to avoid all warnings about such statements by setting\n@code{warn_assign_as_truth_value} to 0, but that may also\nlet real errors like\n\n@example\nif (x = 1)  # intended to test (x == 1)!\n  ...\n@end example\n\n@noindent\nslip by.\n\nIn such cases, it is possible suppress errors for specific statements by\nwriting them with an extra set of parentheses.  For example, writing the\nprevious example as\n\n@example\nwhile ((c = getc()))\n  ...\n@end example\n\n@noindent\nwill prevent the warning from being printed for this statement, while\nallowing Octave to warn about other assignments used in conditional\ncontexts.\n\nThe default value of @code{warn_assign_as_truth_value} is 1.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_function_name_clash", SBV_warn_function_name_clash, 1.0, false, warn_function_name_clash, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_function_name_clash\nIf the value of @code{warn_function_name_clash} is nonzero, a warning is\nissued when Octave finds that the name of a function defined in a\nfunction file differs from the name of the file.  (If the names\ndisagree, the name declared inside the file is ignored.)  If the value\nis 0, the warning is omitted.  The default value is 1.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_future_time_stamp", SBV_warn_future_time_stamp, 1.0, false, warn_future_time_stamp, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_future_time_stamp\nIf the value of this variable is nonzero, Octave will print a warning\nif it finds a function file with a time stamp that is in the future.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_missing_semicolon", SBV_warn_missing_semicolon, 0.0, false, warn_missing_semicolon, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_missing_semicolon\nIf the value of this variable is nonzero, Octave will warn when\nstatements in function definitions don't end in semicolons.  The default\nvalue is 0.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_variable_switch_label", SBV_warn_variable_switch_label, 0.0, false, warn_variable_switch_label, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_variable_switch_label\nIf the value of this variable is nonzero, Octave will print a warning if\na switch label is not a constant or constant expression\n@end defvr") ;
