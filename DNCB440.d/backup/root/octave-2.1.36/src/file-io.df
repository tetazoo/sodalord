 XDEFUN_INTERNAL (is_stream, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} is_stream (@var{x})\nReturn true if @var{x} is a stream object.  Otherwise, return false.\n@end deftypefn") 
 XDEFUN_INTERNAL (fclose, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fclose (@var{fid})\nCloses the specified file.  If an error is encountered while trying to\nclose the file, an error message is printed and @code{fclose} returns\n0.  Otherwise, it returns 1.\n@end deftypefn") 
 XDEFUN_INTERNAL (fflush, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fflush (@var{fid})\nFlush output to @var{fid}.  This is useful for ensuring that all\npending output makes it to the screen before some other event occurs.\nFor example, it is always a good idea to flush the standard output\nstream before calling @code{input}.\n@end deftypefn") 
 XDEFUN_INTERNAL (fgetl, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fgetl (@var{fid}, @var{len})\nRead characters from a file, stopping after a newline, or EOF,\nor @var{len} characters have been read.  The characters read, excluding\nthe possible trailing newline, are returned as a string.\n\nIf @var{len} is omitted, @code{fgetl} reads until the next newline\ncharacter.\n\nIf there are no more characters to read, @code{fgetl} returns @minus{}1.\n@end deftypefn") 
 XDEFUN_INTERNAL (fgets, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fgets (@var{fid}, @var{len})\nRead characters from a file, stopping after a newline, or EOF,\nor @var{len} characters have been read.  The characters read, including\nthe possible trailing newline, are returned as a string.\n\nIf @var{len} is omitted, @code{fgets} reads until the next newline\ncharacter.\n\nIf there are no more characters to read, @code{fgets} returns @minus{}1.\n@end deftypefn") 
 XDEFUN_INTERNAL (fopen, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} fopen (@var{name}, @var{mode}, @var{arch})\n@deftypefnx {Built-in Function} {@var{fid_list} =} fopen (\"all\")\n@deftypefnx {Built-in Function} {@var{file} =} fopen (@var{fid})\nThe first form of the @code{fopen} function opens the named file with\nthe specified mode (read-write, read-only, etc.) and architecture\ninterpretation (IEEE big endian, IEEE little endian, etc.), and returns\nan integer value that may be used to refer to the file later.  If an\nerror occurs, @var{fid} is set to @minus{}1 and @var{msg} contains the\ncorresponding system error message.  The @var{mode} is a one or two\ncharacter string that specifies whether the file is to be opened for\nreading, writing, or both.\n\nThe second form of the @code{fopen} function returns a vector of file ids\ncorresponding to all the currently open files, excluding the\n@code{stdin}, @code{stdout}, and @code{stderr} streams.\n\nThe third form of the @code{fopen} function returns the name of a\ncurrently open file given its file id.\n\nFor example,\n\n@example\nmyfile = fopen (\"splat.dat\", \"r\", \"ieee-le\");\n@end example\n\n@noindent\nopens the file @file{splat.dat} for reading.  If necessary, binary\nnumeric values will be read assuming they are stored in IEEE format with\nthe least significant bit first, and then converted to the native\nrepresentation.\n\nOpening a file that is already open simply opens it again and returns a\nseparate file id.  It is not an error to open a file several times,\nthough writing to the same file through several different file ids may\nproduce unexpected results.\n\nThe possible values @samp{mode} may have are\n\n@table @asis\n@item @samp{r}\nOpen a file for reading.\n\n@item @samp{w}\nOpen a file for writing.  The previous contents are discared.\n\n@item @samp{a}\nOpen or create a file for writing at the end of the file.\n\n@item @samp{r+}\nOpen an existing file for reading and writing.\n\n@item @samp{w+}\nOpen a file for reading or writing.  The previous contents are\ndiscarded.\n\n@item @samp{a+}\nOpen or create a file for reading or writing at the end of the\nfile.\n@end table\n\nThe parameter @var{arch} is a string specifying the default data format\nfor the file.  Valid values for @var{arch} are:\n\n@table @asis\n@samp{native}\nThe format of the current machine (this is the default).\n\n@samp{ieee-le}\nIEEE big endian format.\n\n@samp{ieee-be}\nIEEE little endian format.\n\n@samp{vaxd}\nVAX D floating format.\n\n@samp{vaxg}\nVAX G floating format.\n\n@samp{cray}\nCray floating format.\n@end table\n\n@noindent\nhowever, conversions are currently only supported for @samp{native}\n@samp{ieee-be}, and @samp{ieee-le} formats.\n@end deftypefn") 
 XDEFUN_INTERNAL (freport, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} freport ()\nPrint a list of which files have been opened, and whether they are open\nfor reading, writing, or both.  For example,\n\n@example\n@group\nfreport ()\n\n     @print{}  number  mode  name\n     @print{} \n     @print{}       0     r  stdin\n     @print{}       1     w  stdout\n     @print{}       2     w  stderr\n     @print{}       3     r  myfile\n@end group\n@end example\n@end deftypefn") 
 XDEFUN_INTERNAL (frewind, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} frewind (@var{fid})\nMove the file pointer to the beginning of the file @var{fid}, returning\n1 for success, and 0 if an error was encountered.  It is equivalent to\n@code{fseek (@var{fid}, 0, SEEK_SET)}.\n@end deftypefn") 
 XDEFUN_INTERNAL (fseek, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\nSet the file pointer to any location within the file @var{fid}.  The\npointer is positioned @var{offset} characters from the @var{origin},\nwhich may be one of the predefined variables @code{SEEK_CUR} (current\nposition), @code{SEEK_SET} (beginning), or @code{SEEK_END} (end of\nfile). If @var{origin} is omitted, @code{SEEK_SET} is assumed.  The\noffset must be zero, or a value returned by @code{ftell} (in which case\n@var{origin} must be @code{SEEK_SET}.\n@end deftypefn") 
 XDEFUN_INTERNAL (ftell, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} ftell (@var{fid})\nReturn the position of the file pointer as the number of characters\nfrom the beginning of the file @var{fid}.\n@end deftypefn") 
 XDEFUN_INTERNAL (fprintf, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\nThis function is just like @code{printf}, except that the output is\nwritten to the stream @var{fid} instead of @code{stdout}.\n@end deftypefn") 
 XDEFUN_INTERNAL (fputs, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} fputs (@var{fid}, @var{string})\nWrite a string to a file with no formatting.\n@end deftypefn") 
 XDEFUN_INTERNAL (sprintf, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\nThis is like @code{printf}, except that the output is returned as a\nstring.  Unlike the C library function, which requires you to provide a\nsuitably sized string as an argument, Octave's @code{sprintf} function\nreturns the string, automatically sized to hold all of the items\nconverted.\n@end deftypefn") 
 XDEFUN_INTERNAL (fscanf, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{size})\n@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] = } fscanf (@var{fid}, @var{template}, \"C\")\nIn the first form, read from @var{fid} according to @var{template},\nreturning the result in the matrix @var{val}.\n\nThe optional argument @var{size} specifies the amount of data to read\nand may be one of\n\n@table @code\n@item Inf\nRead as much as possible, returning a column vector.\n\n@item @var{nr}\nRead up to @var{nr} elements, returning a column vector.\n\n@item [@var{nr}, Inf]\nRead as much as possible, returning a matrix with @var{nr} rows.  If the\nnumber of elements read is not an exact multiple of @var{nr}, the last\ncolumn is padded with zeros.\n\n@item [@var{nr}, @var{nc}]\nRead up to @code{@var{nr} * @var{nc}} elements, returning a matrix with\n@var{nr} rows.  If the number of elements read is not an exact multiple\nof @var{nr}, the last column is padded with zeros.\n@end table\n\n@noindent\nIf @var{size} is omitted, a value of @code{Inf} is assumed.\n\nA string is returned if @var{template} specifies only character\nconversions.\n\nThe number of items successfully read is returned in @var{count}.\n\nIn the second form, read from @var{fid} according to @var{template},\nwith each conversion specifier in @var{template} corresponding to a\nsingle scalar return value.  This form is more `C-like', and also\ncompatible with previous versions of Octave.  The number of successful\nconversions is returned in @var{count}\n@end deftypefn") 
 XDEFUN_INTERNAL (sscanf, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] = } sscanf (@var{string}, @var{template}, \"C\")\nThis is like @code{fscanf}, except that the characters are taken from the\nstring @var{string} instead of from a stream.  Reaching the end of the\nstring is treated as an end-of-file condition.\n@end deftypefn") 
 XDEFUN_INTERNAL (scanf, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n@deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}]] = } scanf (@var{template}, \"C\")\nThis is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\nIt is currently not useful to call @code{scanf} in interactive\nprograms.\n@end deftypefn") 
 XDEFUN_INTERNAL (fread, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip}, @var{arch})\nRead binary data of type @var{precision} from the specified file ID\n@var{fid}.\n\nThe optional argument @var{size} specifies the amount of data to read\nand may be one of\n\n@table @code\n@item Inf\nRead as much as possible, returning a column vector.\n\n@item @var{nr}\nRead up to @var{nr} elements, returning a column vector.\n\n@item [@var{nr}, Inf]\nRead as much as possible, returning a matrix with @var{nr} rows.  If the\nnumber of elements read is not an exact multiple of @var{nr}, the last\ncolumn is padded with zeros.\n\n@item [@var{nr}, @var{nc}]\nRead up to @code{@var{nr} * @var{nc}} elements, returning a matrix with\n@var{nr} rows.  If the number of elements read is not an exact multiple\nof @var{nr}, the last column is padded with zeros.\n@end table\n\n@noindent\nIf @var{size} is omitted, a value of @code{Inf} is assumed.\n\nThe optional argument @var{precision} is a string specifying the type of\ndata to read and may be one of\n\n@table @code\n@item \"char\"\n@itemx \"char*1\"\n@itemx \"integer*1\"\n@itemx \"int8\"\nSingle character.\n\n@item \"signed char\"\n@itemx \"schar\"\nSigned character.\n\n@item \"unsigned char\"\n@itemx \"uchar\"\nUnsigned character.\n\n@item \"short\"\nShort integer.\n\n@item \"unsigned short\"\n@itemx \"ushort\"\nUnsigned short integer.\n\n@item \"int\"\nInteger.\n\n@item \"unsigned int\"\n@itemx \"uint\"\nUnsigned integer.\n\n@item \"long\"\nLong integer.\n\n@item \"unsigned long\"\n@itemx \"ulong\"\nUnsigned long integer.\n\n@item \"float\"\n@itemx \"float32\"\n@itemx \"real*4\"\nSingle precision float.\n\n@item \"double\"\n@itemx \"float64\"\n@itemx \"real*8\"\nDouble precision float.\n\n@item \"integer*2\"\n@itemx \"int16\"\nTwo byte integer.\n\n@item \"integer*4\"\n@itemx \"int32\"\nFour byte integer.\n@end table\n\n@noindent\nThe default precision is @code{\"uchar\"}.\n\nThe optional argument @var{skip} specifies the number of bytes to skip\nbefore each element is read.  If it is not specified, a value of 0 is\nassumed.\n\nThe optional argument @var{arch} is a string specifying the data format\nfor the file.  Valid values are\n\n@table @code\n@item \"native\"\nThe format of the current machine.\n\n@item \"ieee-le\"\nIEEE big endian.\n\n@item \"ieee-be\"\nIEEE little endian.\n\n@item \"vaxd\"\nVAX D floating format.\n\n@item \"vaxg\"\nVAX G floating format.\n\n@item \"cray\"\nCray floating format.\n@end table\n\n@noindent\nConversions are currently only supported for @code{\"ieee-be\"} and\n@code{\"ieee-le\"} formats.\n\nThe data read from the file is returned in @var{val}, and the number of\nvalues read is returned in @code{count}\n@end deftypefn") 
 XDEFUN_INTERNAL (fwrite, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {@var{count} =} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip}, @var{arch})\nWrite data in binary form of type @var{precision} to the specified file\nID @var{fid}, returning the number of values successfully written to the\nfile.\n\nThe argument @var{data} is a matrix of values that are to be written to\nthe file.  The values are extracted in column-major order.\n\nThe remaining arguments @var{precision}, @var{skip}, and @var{arch} are\noptional, and are interpreted as described for @code{fread}.\n\nThe behavior of @code{fwrite} is undefined if the values in @var{data}\nare too large to fit in the specified precision.\n@end deftypefn") 
 XDEFUN_INTERNAL (feof, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} feof (@var{fid})\nReturn 1 if an end-of-file condition has been encountered for a given\nfile and 0 otherwise.  Note that it will only return 1 if the end of the\nfile has already been encountered, not if the next read operation will\nresult in an end-of-file condition.\n@end deftypefn") 
 XDEFUN_INTERNAL (ferror, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} ferror (@var{fid})\nReturn 1 if an error condition has been encountered for a given file\nand 0 otherwise.  Note that it will only return 1 if an error has\nalready been encountered, not if the next operation will result in an\nerror condition.\n@end deftypefn") 
 XDEFUN_INTERNAL (popen, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {fid =} popen (@var{command}, @var{mode})\nStart a process and create a pipe.  The name of the command to run is\ngiven by @var{command}.  The file identifier corresponding to the input\nor output stream of the process is returned in @var{fid}.  The argument\n@var{mode} may be\n\n@table @code\n@item \"r\"\nThe pipe will be connected to the standard output of the process, and\nopen for reading.\n\n@item \"w\"\nThe pipe will be connected to the standard input of the process, and\nopen for writing.\n@end table\n\nFor example,\n\n@example\n@group\nfid = popen (\"ls -ltr / | tail -3\", \"r\");\nwhile (isstr (s = fgets (fid)))\n  fputs (stdout, s);\nendwhile\n     @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n     @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n     @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n@end group\n@end example\n@end deftypefn") 
 XDEFUN_INTERNAL (pclose, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} pclose (@var{fid})\nClose a file identifier that was opened by @code{popen}.  You may also\nuse @code{fclose} for the same purpose.\n@end deftypefn") 
 XDEFUN_INTERNAL (tmpnam, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} tmpnam ()\nReturn a unique temporary file name as a string.\n\nSince the named file is not opened, by @code{tmpnam}, it\nis possible (though relatively unlikely) that it will not be available\nby the time your program attempts to open it.\n@end deftypefn") 
 XDEFALIAS_INTERNAL(octave_tmp_file_name, tmpnam) ;
 XDEFUN_INTERNAL (umask, args,, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} umask (@var{mask})\nSet the permission mask for file creation.  The parameter @var{mask}\n is an integer, interpreted as an octal number.  If successful,\n returns the previous value of the mask (as an integer to be\n interpreted as an octal number); otherwise an error message is printed.\n@end deftypefn") 
   XDEFCONST_INTERNAL("SEEK_SET", -1.0, "-*- texinfo -*-\n@defvr {Built-in Variable} SEEK_SET\n@defvrx {Built-in Variable} SEEK_CUR\n@defvrx {Built-in Variable} SEEK_END\nThese variables may be used as the optional third argument for the\nfunction @code{fseek}.\n\n@table @code\n@item SEEK_SET\nPosition file relative to the beginning.\n\n@item SEEK_CUR\nPosition file relative to the current position.\n\n@item SEEK_END\nused with fseek to position file relative to the end.\n@end table\n@end defvr") ;
   XDEFCONST_INTERNAL("SEEK_CUR", 0.0, "-*- texinfo -*-\n@defvr {Built-in Variable} SEEK_CUR\nSee SEEK_SET.\n@end defvr") ;
   XDEFCONST_INTERNAL("SEEK_END", 1.0, "-*- texinfo -*-\n@defvr {Built-in Variable} SEEK_END\nSee SEEK_SET.\n@end defvr") ;
   XDEFCONST_INTERNAL("stdin", stdin_file, "-*- texinfo -*-\n@defvr {Built-in Variable} stdin\nThe standard input stream (file id 0).  When Octave is used\ninteractively, this is filtered through the command line editing\nfunctions.\n@end defvr") ;
   XDEFCONST_INTERNAL("stdout", stdout_file, "-*- texinfo -*-\n@defvr {Built-in Variable} stdout\nThe standard output stream (file id 1).  Data written to the\nstandard output is normally filtered through the pager.\n@end defvr") ;
   XDEFCONST_INTERNAL("stderr", stderr_file, "-*- texinfo -*-\n@defvr {Built-in Variable} stderr\nThe standard error stream (file id 2).  Even if paging is turned on,\nthe standard error is not sent to the pager.  It is useful for error\nmessages and prompts.\n@end defvr") ;
