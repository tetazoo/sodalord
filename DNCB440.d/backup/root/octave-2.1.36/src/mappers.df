   XDEFUN_MAPPER_INTERNAL(abs, 0, 0, 0, std::fabs, abs, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} abs (@var{z})\nCompute the magnitude of @var{z}, defined as\n@iftex\n@tex\n$|z| = \\sqrt{x^2 + y^2}$.\n@end tex\n@end iftex\n@ifinfo\n|@var{z}| = @code{sqrt (x^2 + y^2)}.\n@end ifinfo\n\nFor example,\n\n@example\n@group\nabs (3 + 4i)\n     @result{} 5\n@end group\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(acos, 0, 0, 0, std::acos, 0, acos, -1.0, 1.0, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} acos (@var{x})\nCompute the inverse cosine of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(acosh, 0, 0, 0, acosh, 0, acosh, 1.0, 1.7976931348623157e+308, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} acosh (@var{x})\nCompute the inverse hyperbolic cosine of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(angle, 0, 0, 0, arg, arg, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} angle (@var{z})\nSee arg.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(arg, 0, 0, 0, arg, arg, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} arg (@var{z})\n@deftypefnx {Mapping Function} {} angle (@var{z})\nCompute the argument of @var{z}, defined as\n@iftex\n@tex\n$\\theta = \\tan^{-1}(y/x)$.\n@end tex\n@end iftex\n@ifinfo\n@var{theta} = @code{atan (@var{y}/@var{x})}.\n@end ifinfo\n\n@noindent\nin radians. \n\nFor example,\n\n@example\n@group\narg (3 + 4i)\n     @result{} 0.92730\n@end group\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(asin, 0, 0, 0, std::asin, 0, asin, -1.0, 1.0, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} asin (@var{x})\nCompute the inverse sine of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(asinh, 0, 0, 0, asinh, 0, asinh, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} asinh (@var{x})\nOmpute the inverse hyperbolic sine of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(atan, 0, 0, 0, std::atan, 0, atan, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} atan (@var{x})\nCompute the inverse tangent of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(atanh, 0, 0, 0, atanh, 0, atanh, -1.0, 1.0, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} atanh (@var{x})\nCompute the inverse hyperbolic tanget of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(ceil, 0, 0, 0, std::ceil, 0, ceil, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} ceil (@var{x})\nReturn the smallest integer not less than @var{x}.  If @var{x} is\ncomplex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(conj, 0, 0, 0, xconj, 0, xconj, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} conj (@var{z})\nReturn the complex conjugate of @var{z}, defined as\n@iftex\n@tex\n$\\bar{z} = x - iy$.\n@end tex\n@end iftex\n@ifinfo\n@code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n@end ifinfo\n@end deftypefn\n@seealso{real and imag}") ;
   XDEFUN_MAPPER_INTERNAL(cos, 0, 0, 0, std::cos, 0, cos, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} cos (@var{x})\nCompute the cosine of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(cosh, 0, 0, 0, std::cosh, 0, cosh, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} cosh (@var{x})\nCompute the hyperbolic cosine of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(erf, 0, 0, 0, xerf, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} erf (@var{z})\nComputes the error function,\n@iftex\n@tex\n$$\n {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n$$\n@end tex\n@end iftex\n@ifinfo\n\n@smallexample\n                         z\n                        /\nerf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n                        /\n                     t=0\n@end smallexample\n@end ifinfo\n@end deftypefn\n@seealso{erfc and erfinv}") ;
   XDEFUN_MAPPER_INTERNAL(erfc, 0, 0, 0, xerfc, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} erfc (@var{z})\nComputes the complementary error function,\n@iftex\n@tex\n$1 - {\\rm erf} (z)$.\n@end tex\n@end iftex\n@ifinfo\n@code{1 - erf (@var{z})}.\n@end ifinfo\n@end deftypefn\n\n@seealso{erf and erfinv}") ;
   XDEFUN_MAPPER_INTERNAL(exp, 0, 0, 0, std::exp, 0, exp, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} exp (@var{x})\nCompute the exponential of @var{x}.  To compute the matrix exponential,\nsee @ref{Linear Algebra}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(finite, 0, xfinite, xfinite, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} finite (@var{x})\nReturn 1 for elements of @var{x} that are finite values and zero\notherwise. For example,\n\n@example\n@group\nfinite ([13, Inf, NaN])\n     @result{} [ 1, 0, 0 ]\n@end group\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(fix, 0, 0, 0, fix, 0, fix, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} fix (@var{x})\nTruncate @var{x} toward zero.  If @var{x} is complex, return\n@code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(floor, 0, 0, 0, std::floor, 0, floor, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} floor (@var{x})\nReturn the largest integer not greater than @var{x}.  If @var{x} is\ncomplex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(gamma, 0, 0, 0, xgamma, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} gamma (@var{z})\nComputes the Gamma function,\n@iftex\n@tex\n$$\n \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n$$\n@end tex\n@end iftex\n@ifinfo\n\n@example\n            infinity\n            /\ngamma (z) = | t^(z-1) exp (-t) dt.\n            /\n         t=0\n@end example\n@end ifinfo\n@end deftypefn\n\n@seealso{gammai and lgamma}") ;
   XDEFUN_MAPPER_INTERNAL(imag, 0, 0, 0, imag, ximag, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} imag (@var{z})\nReturn the imaginary part of @var{z} as a real number.\n@end deftypefn\n\n@seealso{real and conj}") ;
   XDEFUN_MAPPER_INTERNAL(isalnum, xisalnum, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isalnum (@var{s})\nReturn 1 for characters that are letters or digits (@code{isalpha\n(@var{a})} or @code{isdigit (@var{a})} is true).\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isalpha, xisalpha, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isalpha (@var{s})\nReturn true for characters that are letters (@code{isupper (@var{a})}\nor @code{islower (@var{})} is true).\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isascii, xisascii, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isascii (@var{s})\nReturn 1 for characters that are ASCII (in the range 0 to 127 decimal).\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(iscntrl, xiscntrl, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} iscntrl (@var{s})\nReturn 1 for control characters.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isdigit, xisdigit, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isdigit (@var{s})\nReturn 1 for characters that are decimal digits.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isinf, 0, xisinf, xisinf, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isinf (@var{x})\nReturn 1 for elements of @var{x} that are infinite and zero\notherwise. For example,\n\n@example\n@group\nisinf ([13, Inf, NaN])\n     @result{} [ 0, 1, 0 ]\n@end group\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isgraph, xisgraph, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isgraph (@var{s})\nReturn 1 for printable characters (but not the space character).\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(islower, xislower, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} islower (@var{s})\nReturn 1 for characters that are lower case letters.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isnan, 0, xisnan, xisnan, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isnan (@var{x})\nReturn 1 for elements of @var{x} that are NaN values and zero\notherwise. For example,\n\n@example\n@group\nisnan ([13, Inf, NaN])\n     @result{} [ 0, 0, 1 ]\n@end group\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isprint, xisprint, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isprint (@var{s})\nReturn 1 for printable characters (including the space character).\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(ispunct, xispunct, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} ispunct (@var{s})\nReturn 1 for punctuation characters.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isspace, xisspace, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isspace (@var{s})\nReturn 1 for whitespace characters (space, formfeed, newline,\ncarriage return, tab, and vertical tab).\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isupper, xisupper, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isupper (@var{s})\nReturn 1 for upper case letters.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(isxdigit, xisxdigit, 0, 0, 0, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} isxdigit (@var{s})\nReturn 1 for characters that are hexadecimal digits.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(lgamma, 0, 0, 0, xlgamma, 0, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} lgamma (@var{a}, @var{x})\n@deftypefnx {Mapping Function} {} gammaln (@var{a}, @var{x})\nReturn the natural logarithm of the gamma function.\n@end deftypefn\n@seealso{gamma and gammai}") ;
   XDEFUN_MAPPER_INTERNAL(log, 0, 0, 0, std::log, 0, log, 0.0, 1.7976931348623157e+308, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} log (@var{x})\nCompute the natural logarithm for each element of @var{x}.  To compute the\nmatrix logarithm, see @ref{Linear Algebra}.\n@end deftypefn\n@seealso{log2, log10, logspace, and exp}") ;
   XDEFUN_MAPPER_INTERNAL(log10, 0, 0, 0, std::log10, 0, log10, 0.0, 1.7976931348623157e+308, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} log10 (@var{x})\nCompute the base-10 logarithm for each element of @var{x}.\n@end deftypefn\n@seealso{log, log2, logspace, and exp}") ;
   XDEFUN_MAPPER_INTERNAL(real, 0, 0, 0, real, xreal, 0, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} real (@var{z})\nReturn the real part of @var{z}.\n@end deftypefn\n@seealso{imag and conj}") ;
   XDEFUN_MAPPER_INTERNAL(round, 0, 0, 0, round, 0, round, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} round (@var{x})\nReturn the integer nearest to @var{x}.  If @var{x} is complex, return\n@code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n@end deftypefn\n@seealso{rem}") ;
   XDEFUN_MAPPER_INTERNAL(sign, 0, 0, 0, signum, 0, signum, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} sign (@var{x})\nCompute the @dfn{signum} function, which is defined as\n@iftex\n@tex\n$$\n{\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n$$\n@end tex\n@end iftex\n@ifinfo\n\n@example\n           -1, x < 0;\nsign (x) =  0, x = 0;\n            1, x > 0.\n@end example\n@end ifinfo\n\nFor complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(sin, 0, 0, 0, std::sin, 0, sin, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} sin (@var{x})\nCompute the sin of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(sinh, 0, 0, 0, std::sinh, 0, sinh, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} sinh (@var{x})\nCompute the inverse hyperbolic sin of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(sqrt, 0, 0, 0, std::sqrt, 0, sqrt, 0.0, 1.7976931348623157e+308, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} sqrt (@var{x})\nCompute the square root of @var{x}.  If @var{x} is negative, a complex\nresult is returned.  To compute the matrix square root, see\n@ref{Linear Algebra}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(tan, 0, 0, 0, std::tan, 0, tan, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} tan (@var{z})\nCompute tanget of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(tanh, 0, 0, 0, std::tanh, 0, tanh, 0.0, 0.0, 0, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} tanh (@var{x})\nCompute hyperbolic tangent of each element of @var{x}.\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(toascii, xtoascii, 0, 0, 0, 0, 0, 0.0, 0.0, 1, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} toascii (@var{s})\nReturn ASCII representation of @var{s} in a matrix.  For example,\n\n@example\n@group\ntoascii (\"ASCII\")\n     @result{} [ 65, 83, 67, 73, 73 ]\n@end group\n\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(tolower, xtolower, 0, 0, 0, 0, 0, 0.0, 0.0, 2, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} tolower (@var{s})\nReturn a copy of the string @var{s}, with each upper-case character\nreplaced by the corresponding lower-case one; nonalphabetic characters\nare left unchanged.  For example,\n\n@example\ntolower (\"MiXeD cAsE 123\")\n     @result{} \"mixed case 123\"\n@end example\n@end deftypefn") ;
   XDEFUN_MAPPER_INTERNAL(toupper, xtoupper, 0, 0, 0, 0, 0, 0.0, 0.0, 2, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} toupper (@var{s})\nReturn a copy of the string @var{s}, with each  lower-case character\nreplaced by the corresponding upper-case one; nonalphabetic characters\nare left unchanged.  For example,\n\n@example\n@group\ntoupper (\"MiXeD cAsE 123\")\n     @result{} \"MIXED CASE 123\"\n@end group\n@end example\n@end deftypefn") ;
   XDEFALIAS_INTERNAL(gammaln, lgamma) ;
   XDEFALIAS_INTERNAL(isfinite, finite) ;
