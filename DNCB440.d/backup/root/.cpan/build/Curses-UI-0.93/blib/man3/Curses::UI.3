.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Curses::UI 3"
.TH Curses::UI 3 "2003-10-15" "perl v5.8.3" "User Contributed Perl Documentation"
.SH "NAME"
Curses::UI \- A curses based OO user interface framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Here's the obligatory \*(L"Hello, world!\*(R" example.
.PP
.Vb 3
\&    use Curses::UI;
\&    my $cui = new Curses::UI;
\&    $cui->dialog("Hello, world!");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Curses::UI can be used for the development of curses
based user interfaces. Currently, it contains the 
following classes:
.PP
\&\fBBase elements\fR
.IP "* Curses::UI::Widget" 4
.IX Item "Curses::UI::Widget"
.PD 0
.IP "* Curses::UI::Container" 4
.IX Item "Curses::UI::Container"
.IP "* Curses::UI::Color" 4
.IX Item "Curses::UI::Color"
.PD
.PP
\&\fBWidgets\fR
.IP "* Curses::UI::Buttonbox" 4
.IX Item "Curses::UI::Buttonbox"
.PD 0
.IP "* Curses::UI::Calendar" 4
.IX Item "Curses::UI::Calendar"
.IP "* Curses::UI::Checkbox" 4
.IX Item "Curses::UI::Checkbox"
.IP "* Curses::UI::Label" 4
.IX Item "Curses::UI::Label"
.IP "* Curses::UI::Listbox" 4
.IX Item "Curses::UI::Listbox"
.IP "* Curses::UI::Menubar" 4
.IX Item "Curses::UI::Menubar"
.IP "* Curses::UI::MenuListbox (used by Curses::UI::Menubar)" 4
.IX Item "Curses::UI::MenuListbox (used by Curses::UI::Menubar)"
.IP "* Curses::UI::PasswordEntry" 4
.IX Item "Curses::UI::PasswordEntry"
.IP "* Curses::UI::Popupmenu" 4
.IX Item "Curses::UI::Popupmenu"
.IP "* Curses::UI::Progressbar" 4
.IX Item "Curses::UI::Progressbar"
.IP "* Curses::UI::Radiobuttonbox" 4
.IX Item "Curses::UI::Radiobuttonbox"
.IP "* Curses::UI::SearchEntry (used by Curses::UI::Searchable)" 4
.IX Item "Curses::UI::SearchEntry (used by Curses::UI::Searchable)"
.IP "* Curses::UI::TextEditor" 4
.IX Item "Curses::UI::TextEditor"
.IP "* Curses::UI::TextEntry" 4
.IX Item "Curses::UI::TextEntry"
.IP "* Curses::UI::TextViewer" 4
.IX Item "Curses::UI::TextViewer"
.IP "* Curses::UI::Window" 4
.IX Item "Curses::UI::Window"
.PD
.PP
\&\fBDialogs\fR
.IP "* Curses::UI::Dialog::Basic" 4
.IX Item "Curses::UI::Dialog::Basic"
.PD 0
.IP "* Curses::UI::Dialog::Error" 4
.IX Item "Curses::UI::Dialog::Error"
.IP "* Curses::UI::Dialog::Filebrowser" 4
.IX Item "Curses::UI::Dialog::Filebrowser"
.IP "* Curses::UI::Dialog::Status" 4
.IX Item "Curses::UI::Dialog::Status"
.PD
.PP
\&\fBSupport classes\fR
.IP "* Curses::UI::Common" 4
.IX Item "Curses::UI::Common"
.PD 0
.IP "* Curses::UI::Searchable" 4
.IX Item "Curses::UI::Searchable"
.PD
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-compat\fR < \s-1BOOLEAN\s0 >" 4
.IX Item "-compat < BOOLEAN >"
If the \fB\-compat\fR option is set to a true value, the Curses::UI
program will run in compatibility mode. This means that only
very simple characters will be used for creating the widgets.
By default this option is set to false.
.IP "\fB\-clear_on_exit\fR < \s-1BOOLEAN\s0 >" 4
.IX Item "-clear_on_exit < BOOLEAN >"
If the \fB\-clear_on_exit\fR option is set to a true value,
a Curses::UI program will call the \*(L"clear\*(R" program on exit
(through the \s-1DESTROY\s0 method of Curses::UI). By default
this option is set to false.
.IP "\fB\-mouse_support\fR < \s-1BOOLEAN\s0 >" 4
.IX Item "-mouse_support < BOOLEAN >"
If the \fB\-mouse_support\fR option is set to a false value
mouse support will be disabled. This is used to override
the auto determined value and to disable mouse support.
.IP "\fB\-userdata\fR < \s-1SCALAR\s0 >" 4
.IX Item "-userdata < SCALAR >"
This option specifies a user data that can be retrieved with
the \fBuserdata\fR() method.  It is usefull to store application's
internal data that otherwise would not be accessible in callbacks.
.IP "\fB\-color_support\fR < \s-1BOOLEAN\s0 >" 4
.IX Item "-color_support < BOOLEAN >"
If this option is set to a true value Curses::UI will try to
determine if color is available on the terminal and if so enable
it.
.IP "\fB\-default_colors\fR < \s-1BOOLEAN\s0 >" 4
.IX Item "-default_colors < BOOLEAN >"
If \-default_colors is set to a true value Curses::UI will try
to enable color support without changing the original terminal
settings.
.SH "METHODS"
.IX Header "METHODS"
The \s-1UI\s0 is a descendant of Curses::UI::Container, so you can use the
Container methods. Here's an overview of the methods that are specific
for Curses::UI.
.IP "\fBnew\fR ( \s-1OPTIONS\s0 )" 4
.IX Item "new ( OPTIONS )"
Create a new Curses::UI instance. See the \s-1OPTIONS\s0 section above 
to find out what options can be used.
.IP "\fBleave_curses\fR ( )" 4
.IX Item "leave_curses ( )"
Temporarily leaves curses mode and recovers normal terminal
mode.
.IP "\fBreset_curses\fR ( )" 4
.IX Item "reset_curses ( )"
Return to curses mode after \fB\f(BIleave_curses()\fB\fR.
.IP "\fBadd\fR ( \s-1ID\s0, \s-1CLASS\s0, \s-1OPTIONS\s0 )" 4
.IX Item "add ( ID, CLASS, OPTIONS )"
The \fBadd\fR method of Curses::UI is almost the same as the \fBadd\fR
method of Curses::UI::Container. The difference is that Curses::UI
will only accept classes that are (descendants) of the
Curses::UI::Window class. For the rest of the information
see Curses::UI::Container.
.IP "\fBmainloop\fR ( )" 4
.IX Item "mainloop ( )"
Starts a Tk like main loop that will handle input and events.
.IP "\fBMainLoop\fR ( )" 4
.IX Item "MainLoop ( )"
Same as \fBmainloop\fR, for Tk compatibility.
.IP "\fBschedule_event\fR ( \s-1CODE\s0 )" 4
.IX Item "schedule_event ( CODE )"
The schedule_event method adds a method to the mainloop. This
method is executed one time after the input handler has run and
deleted from the mainloop afterwards.
.IP "\fBadd_callback\fR ( \s-1ID\s0, \s-1CODE\s0)" 4
.IX Item "add_callback ( ID, CODE)"
This method lets you add a callback into the mainloop permanently.
The code is executed after the input handler has run.
.IP "\fBdelete_callback\fR ( \s-1ID\s0 )" 4
.IX Item "delete_callback ( ID )"
This method deletes the \s-1CODE\s0 specified by \s-1ID\s0 from the mainloop.
.IP "\fBusemodule\fR ( \s-1CLASSNAME\s0 )" 4
.IX Item "usemodule ( CLASSNAME )"
Loads the with \s-1CLASSNAME\s0 given module.
.IP "\fBuserdata\fR ( [ \s-1SCALAR\s0 ] )" 4
.IX Item "userdata ( [ SCALAR ] )"
This method will return the user internal data stored in the \s-1UI\s0 object.
If a \s-1SCALAR\s0 parameter is specified it will also set the current user
data to it.
.IP "\fBlayout\fR ( )" 4
.IX Item "layout ( )"
The layout method of Curses::UI will try to find out the size of the
screen. After that it will call the \fBlayout\fR routine of every 
contained object. So running \fBlayout\fR on a Curses::UI object will
effectively layout the complete application. Normally you will not 
have to call this method directly.
.IP "\fBcompat\fR ( [\s-1BOOLEAN\s0] )" 4
.IX Item "compat ( [BOOLEAN] )"
The \fB\-compat\fR option will be set to the \s-1BOOLEAN\s0 value, unless
\&\s-1BOOLEAN\s0 is omitted. The method returns the current value 
for \fB\-compat\fR.
.IP "\fBclear_on_exit\fR ( [\s-1BOOLEAN\s0] )" 4
.IX Item "clear_on_exit ( [BOOLEAN] )"
The \fB\-clear_on_exit\fR option will be set to the \s-1BOOLEAN\s0 value, unless
\&\s-1BOOLEAN\s0 is omitted. The method returns the current value 
for \fB\-clear_on_exit\fR.
.IP "\fBdialog\fR ( \s-1MESSAGE\s0 or \s-1OPTIONS\s0 )" 4
.IX Item "dialog ( MESSAGE or OPTIONS )"
Use the \fBdialog\fR method to show a dialog window. If you only
provide a single argument, this argument will be used as the 
message to show. Example:
.Sp
.Vb 1
\&    $cui->dialog("Hello, world!");
.Ve
.Sp
If you want to have some more control over the dialog window, you
will have to provide more arguments (for an explanation of the 
arguments that can be used, see 
Curses::UI::Dialog::Basic. 
Example:
.Sp
.Vb 6
\&    my $yes = $cui->dialog(
\&        -message => "Hello, world?",
\&        -buttons => ['< Yes >','< No >'],
\&        -values  => [1,0],
\&        -title   => 'Question',
\&    );
.Ve
.Sp
.Vb 3
\&    if ($yes) {
\&        # whatever
\&    }
.Ve
.IP "\fBerror\fR ( \s-1MESSAGE\s0 or \s-1OPTIONS\s0 )" 4
.IX Item "error ( MESSAGE or OPTIONS )"
The \fBerror\fR method will create an error dialog. This is 
basically a Curses::UI::Dialog::Basic, but it has an ASCII-art
exclamation sign drawn left to the message. For the rest 
it's just like \fBdialog\fR. Example:
.Sp
.Vb 2
\&    $cui->error("It's the end of the\en"
\&               ."world as we know it!");
.Ve
.IP "\fBfilebrowser\fR ( \s-1OPTIONS\s0 )" 4
.IX Item "filebrowser ( OPTIONS )"
The \fBfilebrowser\fR method will create a file browser
dialog. For an explanation of the arguments that can be 
used, see Curses::UI::Dialog::Filebrowser.
Example:
.Sp
.Vb 4
\&    my $file = $cui->filebrowser(
\&        -path => "/tmp",
\&        -show_hidden => 1,
\&    );
.Ve
.Sp
.Vb 11
\&    # Filebrowser will return undef
\&    # if no file was selected.
\&    if (defined $file) { 
\&        unless (open F, ">$file") {
\&            print F "Hello, world!\en";
\&            close F;
\&    } else {
\&            $cui->error("Error on writing to "
\&                       ."\e"$file\e":\en$!");
\&    }
\&    }
.Ve
.IP "\fBloadfilebrowser\fR( \s-1OPTIONS\s0 )" 4
.IX Item "loadfilebrowser( OPTIONS )"
.PD 0
.IP "\fBsavefilebrowser\fR( \s-1OPTIONS\s0 )" 4
.IX Item "savefilebrowser( OPTIONS )"
.PD
These two methods will create file browser dialogs as well.
The difference is that these will have the dialogs set up
correctly for loading and saving files. Moreover, the save
dialog will check if the selected file exists or not. If it
does exist, it will show an overwrite confirmation to check
if the user really wants to overwrite the selected file.
.IP "\fBstatus\fR ( \s-1MESSAGE\s0 )" 4
.IX Item "status ( MESSAGE )"
.PD 0
.IP "\fBnostatus\fR ( )" 4
.IX Item "nostatus ( )"
.PD
Using these methods it's easy to provide status information for
the user of your program. The status dialog is a dialog with 
only a label on it. The status dialog doesn't really get the
focus. It's only used to display some information. If you need
more than one status, you can call \fBstatus\fR subsequently.
Any existing status dialog will be cleaned up and a new one
will be created.
.Sp
If you are finished, you can delete the status dialog by calling
the \fBnostatus\fR method. Example:
.Sp
.Vb 2
\&    $cui->status("Saying hello to the world...");
\&    # code for saying "Hello, world!"
.Ve
.Sp
.Vb 2
\&    $cui->status("Saying goodbye to the world...");
\&    # code for saying "Goodbye, world!"
.Ve
.Sp
.Vb 1
\&    $cui->nostatus;
.Ve
.IP "\fBprogress\fR ( \s-1OPTIONS\s0 )" 4
.IX Item "progress ( OPTIONS )"
.PD 0
.IP "\fBsetprogress\fR ( \s-1POSITION\s0, \s-1MESSAGE\s0 )" 4
.IX Item "setprogress ( POSITION, MESSAGE )"
.IP "\fBnoprogress\fR ( )" 4
.IX Item "noprogress ( )"
.PD
Using these methods it's easy to provide progress information
to the user. The progress dialog is a dialog with an optional
label on it and a progress bar. Similar to the status dialog,
this dialog does not get the focus. 
.Sp
Using the \fBprogress\fR method, a new progress dialog can be 
created (see also 
Curses::IU::Dialog::Progress). 
This method takes the same arguments as the Curses::IU::Dialog::Progress 
class.
.Sp
After that the progress can be set using \fBsetprogress\fR. This 
method takes one or two arguments. The first argument is the current
position of the progressbar. The second argument is the message
to show in the label. If one of these arguments is undefined,
the current value will be kept. 
.Sp
If you are finished, you can delete the progress dialog by calling
the \fBnoprogress\fR method. 
.Sp
Example:
.Sp
.Vb 4
\&    $cui->progress(
\&        -max => 10,
\&    -message => "Counting 10 seconds...",
\&    );
.Ve
.Sp
.Vb 4
\&    for my $second (0..10) {
\&    $cui->setprogress($second)
\&    sleep 1;
\&    }
.Ve
.Sp
.Vb 1
\&    $cui->noprogress;
.Ve
.IP "\fBcolor\fR ( )" 4
.IX Item "color ( )"
Returns the currently used Curses::UI::Color object
.IP "\fBset_color\fR ( \s-1OBJECT\s0 )" 4
.IX Item "set_color ( OBJECT )"
Replaces the currently used Color object with an other. This
can be used to fast change all colors in a Curses::UI application.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Curses
Curses::UI::Container,
.SH "BASIC TUTORIAL"
.IX Header "BASIC TUTORIAL"
see 'perldoc Curses::UI::Tutorial'
.SH "REFERENCES"
.IX Header "REFERENCES"
Curses::UI::POE is a \s-1POE\s0 eventsystem and mainloop for Curses::UI
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2001\-2002 Maurice Makaay. All rights reserved.
.PP
Maintained by Marcus Thiesen (marcus@cpan.thiesenweb.de)
.PP
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty. It may be used, redistributed and/or modified
under the same terms as perl itself.
