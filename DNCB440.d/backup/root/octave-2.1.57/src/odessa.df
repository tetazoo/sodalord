 XDEFUN_DLD_INTERNAL (odessa_options, args, , 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {} odessa_options (@var{opt}, @var{val})\nWhen called with two arguments, this function\nallows you set options parameters for the function @code{odessa}.\nGiven one argument, @code{odessa_options} returns the value of the\ncorresponding option.  If no arguments are supplied, the names of all\nthe available options and their current values are displayed.\n\nOptions include\n\n@table @code\n@item \"absolute tolerance\"\nAbsolute tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector.\n@item \"relative tolerance\"\nRelative tolerance parameter.  Unlike the absolute tolerance, this\nparameter may only be a scalar.\n\nThe local error test applied at each integration step is\n\n@example\n  abs (local error in x(i)) <= rtol * abs (y(i)) + atol(i)\n@end example\n@item \"integration method\"\nA string specifing the method of integration to use to solve the ODE\nsystem.  Valid values are\n\n@table @asis\n@item \"adams\"\n@itemx \"non-stiff\"\nNo Jacobian used (even if it is available).\n@item \"bdf\"\n@item \"stiff\"\nUse stiff backward differentiation formula (BDF) method.  If a\nfunction to compute the Jacobian is not supplied, @code{lsode} will\ncompute a finite difference approximation of the Jacobian matrix.\n@end table\n@item \"initial step size\"\nThe step size to be attempted on the first step (default is determined\nautomatically).\n@item \"maximum order\"\nRestrict the maximum order of the solution method.  If using the Adams\nmethod, this option must be between 1 and 12.  Otherwise, it must be\nbetween 1 and 5, inclusive.\n@item \"maximum step size\"\nSetting the maximum stepsize will avoid passing over very large\nregions  (default is not specified).\n@item \"minimum step size\"\nThe minimum absolute step size allowed (default is 0).\n@item \"step limit\"\nMaximum number of steps allowed (default is 100000).\n@end table\n@end deftypefn") 
 XDEFUN_DLD_INTERNAL (odessa, args, nargout, 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {[@var{x}, @var{sx}, @var{istate}, @var{msg}]} odessa (@var{fcn}, @var{x_0}, @var{p}, @var{sx_0}, @var{t}, @var{t_crit})\nSolve the set of differential equations\n@tex\n$$ {dx \\over dt} = f (x, t; p) $$\nwith\n$$ x(t_0) = x_0 $$\n@end tex\n@ifinfo\n\n@example\ndx\n-- = f(x, t; p)\ndt\n@end example\n\nwith\n\n@example\nx(t_0) = x_0\n@end example\n\n@end ifinfo\nand simultaneously compute the first-order sensitivity coefficients\ngiven by\n\n@example\ns'(t) = j(t)*s(t) + df/dp\n@end example\n\nin which\n\n@example\ns(t)  = dx(t)/dp        (sensitivity functions)\ns'(t) = d(dx(t)/dp)/dt\nj(t)  = df(x,t;p)/dx(t) (Jacobian matrix)\ndf/dp = df(x,t;p)/dp    (inhomogeneity matrix)\n@end example\n\nThe solution is returned in the matrix @var{x}, with each row\ncorresponding to an element of the vector @var{t}.  The first element\nof @var{t} should be @math{t_0} and should correspond to the initial\nstate of the system @var{x_0}, so that the first row of the output\nis @var{x_0}.\n\nThe sensitivities are returned in a list of matrices, @var{sx},\nwith each element of the list corresponding to an element of the\nvector @var{t}.\n\nThe first argument, @var{fcn}, is a string that names the function to\ncall to compute the vector of right hand sides for the set of equations.\nThe function must have the form\n\n@example\n@var{xdot} = f (@var{x}, @var{t}, @var{p})\n@end example\n\n@noindent\nin which @var{xdot} and @var{x} are vectors and @var{t} is a scalar.\n\nThe variable @var{p} is a vector of parameters.\n\nThe @var{fcn} argument may also be an array of strings\n\n@example\n[\"f\"; \"j\"; \"b\"]\n@end example\n\nin which the first element names the function @math{f} described\nabove, the second element names a function to compute the Jacobian\nof @math{f}, and the third element names a function to compute the\ninhomogeneity matrix.\n\nThe Jacobian function must have the form\n\n@example\n@var{jac} = j (@var{x}, @var{t}, @var{p})\n@end example\n\nin which @var{x}, @var{t}, and @var{p} have the same meanings as\nabove for the function @var{f}, and  @var{jac} is the matrix of\npartial derivatives\n@tex\n$$ J = {\\partial f_i \\over \\partial x_j} $$\n@end tex\n@ifinfo\n\n@example\n      df_i\njac = ----\n      dx_j\n@end example\n\n@end ifinfo\n\nThe function @var{b} must have the form\n\n@example\n@var{dfdp} = b (@var{x}, @var{t}, @var{p}, @var{c})\n@end example\n\nin which @var{x}, @var{t}, and @var{p} have the same meanings as\nabove for the function @var{f}, @var{c} indicates which partial\nderivatives to return in @var{dfdp}.  For example, if @var{c} is 2,\nyou should return the vector\n\n@example\n       df_i\ndfdp = ----,    i = 1:length(x)\n       dp_2\n@end example\n\nThe second argument, @var{x_0}, specifies the intial state of the system.\n\nThe third argument, @var{p}, specifies the set of parameters.\n\nThe fourth argument, @var{sx_0} specifies the initial values of the\nsensitivities.\n\nThe sixth argument is optional, and may be used to specify a set of\ntimes that the ODE solver should not integrate past.  It is useful for\navoiding difficulties with singularities and points where there is a\ndiscontinuity in the derivative.\n\nAfter a successful computation, the value of @var{istate} will be 2\n(consistent with the Fortran version of @sc{Odessa}).\n\nIf the computation is not successful, @var{istate} will be something\nother than 2 and @var{msg} will contain additional information.\n\nYou can use the function @code{lsode_options} to set optional\nparameters for @code{lsode}.\n@end deftypefn\n@seealso{daspk, dassl, dasrt, lsode}") 
