 XDEFUN_DLD_INTERNAL (lsode_options, args, , 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {} lsode_options (@var{opt}, @var{val})\nWhen called with two arguments, this function\nallows you set options parameters for the function @code{lsode}.\nGiven one argument, @code{lsode_options} returns the value of the\ncorresponding option.  If no arguments are supplied, the names of all\nthe available options and their current values are displayed.\n\nOptions include\n\n@table @code\n@item \"absolute tolerance\"\nAbsolute tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector.\n@item \"relative tolerance\"\nRelative tolerance parameter.  Unlike the absolute tolerance, this\nparameter may only be a scalar.\n\nThe local error test applied at each integration step is\n\n@example\n  abs (local error in x(i)) <= rtol * abs (y(i)) + atol(i)\n@end example\n@item \"integration method\"\nA string specifing the method of integration to use to solve the ODE\nsystem.  Valid values are\n\n@table @asis\n@item \"adams\"\n@itemx \"non-stiff\"\nNo Jacobian used (even if it is available).\n@item \"bdf\"\n@item \"stiff\"\nUse stiff backward differentiation formula (BDF) method.  If a\nfunction to compute the Jacobian is not supplied, @code{lsode} will\ncompute a finite difference approximation of the Jacobian matrix.\n@end table\n@item \"initial step size\"\nThe step size to be attempted on the first step (default is determined\nautomatically).\n@item \"maximum order\"\nRestrict the maximum order of the solution method.  If using the Adams\nmethod, this option must be between 1 and 12.  Otherwise, it must be\nbetween 1 and 5, inclusive.\n@item \"maximum step size\"\nSetting the maximum stepsize will avoid passing over very large\nregions  (default is not specified).\n@item \"minimum step size\"\nThe minimum absolute step size allowed (default is 0).\n@item \"step limit\"\nMaximum number of steps allowed (default is 100000).\n@end table\n@end deftypefn") 
 XDEFUN_DLD_INTERNAL (lsode, args, nargout, 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {[@var{x}, @var{istate}, @var{msg}]} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\nSolve the set of differential equations\n@tex\n$$ {dx \\over dt} = f (x, t) $$\nwith\n$$ x(t_0) = x_0 $$\n@end tex\n@ifinfo\n\n@example\ndx\n-- = f(x, t)\ndt\n@end example\n\nwith\n\n@example\nx(t_0) = x_0\n@end example\n\n@end ifinfo\nThe solution is returned in the matrix @var{x}, with each row\ncorresponding to an element of the vector @var{t}.  The first element\nof @var{t} should be @math{t_0} and should correspond to the initial\nstate of the system @var{x_0}, so that the first row of the output\nis @var{x_0}.\n\nThe first argument, @var{fcn}, is a string that names the function to\ncall to compute the vector of right hand sides for the set of equations.\nThe function must have the form\n\n@example\n@var{xdot} = f (@var{x}, @var{t})\n@end example\n\n@noindent\nin which @var{xdot} and @var{x} are vectors and @var{t} is a scalar.\n\nIf @var{fcn} is a two-element string array, the first element names the\nfunction @math{f} described above, and the second element names a function\nto compute the Jacobian of @math{f}.  The Jacobian function must have the\nform\n\n@example\n@var{jac} = j (@var{x}, @var{t})\n@end example\n\nin which @var{jac} is the matrix of partial derivatives\n@tex\n$$ J = {\\partial f_i \\over \\partial x_j} = \\left[\\matrix{\n{\\partial f_1 \\over \\partial x_1}\n  & {\\partial f_1 \\over \\partial x_2}\n  & \\cdots\n  & {\\partial f_1 \\over \\partial x_N} \\cr\n{\\partial f_2 \\over \\partial x_1}\n  & {\\partial f_2 \\over \\partial x_2}\n  & \\cdots\n  & {\\partial f_2 \\over \\partial x_N} \\cr\n \\vdots & \\vdots & \\ddots & \\vdots \\cr\n{\\partial f_3 \\over \\partial x_1}\n  & {\\partial f_3 \\over \\partial x_2}\n  & \\cdots\n  & {\\partial f_3 \\over \\partial x_N} \\cr}\\right]$$\n@end tex\n@ifinfo\n\n@example\n             | df_1  df_1       df_1 |\n             | ----  ----  ...  ---- |\n             | dx_1  dx_2       dx_N |\n             |                       |\n             | df_2  df_2       df_2 |\n             | ----  ----  ...  ---- |\n      df_i   | dx_1  dx_2       dx_N |\njac = ---- = |                       |\n      dx_j   |  .    .     .    .    |\n             |  .    .      .   .    |\n             |  .    .       .  .    |\n             |                       |\n             | df_N  df_N       df_N |\n             | ----  ----  ...  ---- |\n             | dx_1  dx_2       dx_N |\n@end example\n\n@end ifinfo\n\nThe second and third arguments specify the intial state of the system,\n@math{x_0}, and the initial value of the independent variable @math{t_0}.\n\nThe fourth argument is optional, and may be used to specify a set of\ntimes that the ODE solver should not integrate past.  It is useful for\navoiding difficulties with singularities and points where there is a\ndiscontinuity in the derivative.\n\nAfter a successful computation, the value of @var{istate} will be 2\n(consistent with the Fortran version of @sc{Lsode}).\n\nIf the computation is not successful, @var{istate} will be something\nother than 2 and @var{msg} will contain additional information.\n\nYou can use the function @code{lsode_options} to set optional\nparameters for @code{lsode}.\n@end deftypefn\n@seealso{daspk, dassl, dasrt, odessa}") 
