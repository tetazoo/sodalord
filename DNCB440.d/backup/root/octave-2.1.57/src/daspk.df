 XDEFUN_DLD_INTERNAL (daspk_options, args, , 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {} daspk_options (@var{opt}, @var{val})\nWhen called with two arguments, this function\nallows you set options parameters for the function @code{daspk}.\nGiven one argument, @code{daspk_options} returns the value of the\ncorresponding option.  If no arguments are supplied, the names of all\nthe available options and their current values are displayed.\n\nOptions include\n\n@table @code\n@item \"absolute tolerance\"\nAbsolute tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector, and the relative\ntolerance must also be a vector of the same length.\n@item \"relative tolerance\"\nRelative tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector, and the absolute\ntolerance must also be a vector of the same length.\n\nThe local error test applied at each integration step is\n\n@example\n  abs (local error in x(i)) <= rtol(i) * abs (Y(i)) + atol(i)\n@end example\n@item \"compute consistent initial condition\"\nDenoting the differential variables in the state vector by @samp{Y_d}\nand the algebraic variables by @samp{Y_a}, @code{ddaspk} can solve\none of two initialization problems:\n\n@enumerate\n@item Given Y_d, calculate Y_a and Y'_d\n@item Given Y', calculate Y.\n@end enumerate\n\nIn either case, initial values for the given components are input, and\ninitial guesses for the unknown components must also be provided as\ninput.  Set this option to 1 to solve the first problem, or 2 to solve\nthe second (the default default is 0, so you must provide a set of\ninitial conditions that are consistent).\n\nIf this option is set to a nonzero value, you must also set the\n@code{\"algebraic variables\"} option to declare which variables in the\nproblem are algebraic.\n@item \"use initial condition heuristics\"\nSet to a nonzero value to use the initial condition heuristics options\ndescribed below.\n@item \"initial condition heuristics\"\nA vector of the following parameters that can be used to control the\ninitial condition calculation.\n\n@table @code\n@item MXNIT\nMaximum number of Newton iterations (default is 5).\n@item MXNJ\nMaximum number of Jacobian evaluations (default is 6).\n@item MXNH\nMaximum number of values of the artificial stepsize parameter to be\ntried if the @code{\"compute consistent initial condition\"} option has\nbeen set to 1 (default is 5).\n\nNote that the maximum number of Newton iterations allowed in all is\n@code{MXNIT*MXNJ*MXNH} if the @code{\"compute consistent initial\ncondition\"} option has been set to 1 and @code{MXNIT*MXNJ} if it is\nset to 2.\n@item LSOFF\nSet to a nonzero value to disable the linesearch algorithm (default is\n0).\n@item STPTOL\nMinimum scaled step in linesearch algorithm (default is eps^(2/3)).\n@item EPINIT\nSwing factor in the Newton iteration convergence test.  The test is\napplied to the residual vector, premultiplied by the approximate\nJacobian.  For convergence, the weighted RMS norm of this vector\n(scaled by the error weights) must be less than @code{EPINIT*EPCON},\nwhere @code{EPCON} = 0.33 is the analogous test constant used in the\ntime steps. The default is @code{EPINIT} = 0.01.\n@end table\n@item \"print initial condition info\"\nSet this option to a nonzero value to display detailed information\nabout the initial condition calculation (default is 0).\n@item \"exclude algebraic variables from error test\"\nSet to a nonzero value to exclude algebraic variables from the error\ntest.  You must also set the @code{\"algebraic variables\"} option to\ndeclare which variables in the problem are algebraic (default is 0).\n@item \"algebraic variables\"\nA vector of the same length as the state vector.  A nonzero element\nindicates that the corresponding element of the state vector is an\nalgebraic variable (i.e., its derivative does not appear explicitly\nin the equation set.\n\nThis option is required by the\n@code{compute consistent initial condition\"} and\n@code{\"exclude algebraic variables from error test\"} options.\n@item \"enforce inequality constraints\"\nSet to one of the following values to enforce the inequality\nconstraints specified by the @code{\"inequality constraint types\"}\noption (default is 0).\n\n@enumerate\n@item To have constraint checking only in the initial condition calculation.\n@item To enforce constraint checking during the integration.\n@item To enforce both options 1 and 2.\n@end enumerate\n@item \"inequality constraint types\"\nA vector of the same length as the state specifying the type of\ninequality constraint.  Each element of the vector corresponds to an\nelement of the state and should be assigned one of the following\ncodes \n\n@table @asis\n@item -2\nLess than zero.\n@item -1\nLess than or equal to zero.\n@item 0\nNot constrained.\n@item 1\nGreater than or equal to zero.\n@item 2\nGreater than zero.\n@end table\n\nThis option only has an effect if the\n@code{\"enforce inequality constraints\"} option is nonzero.\n@item \"initial step size\"\nDifferential-algebraic problems may occaisionally suffer from severe\nscaling difficulties on the first step.  If you know a great deal\nabout the scaling of your problem, you can help to alleviate this\nproblem by specifying an initial stepsize (default is computed\nautomatically).\n@item \"maximum order\"\nRestrict the maximum order of the solution method.  This option must\nbe between 1 and 5, inclusive (default is 5).\n@item \"maximum step size\"\nSetting the maximum stepsize will avoid passing over very large\nregions (default is not specified).\n@end table\n@end deftypefn") 
 XDEFUN_DLD_INTERNAL (daspk, args, nargout, 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\nSolve the set of differential-algebraic equations\n@tex\n$$ 0 = f (\\dot{x}, x, t) $$\nwith\n$$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n@end tex\n@ifinfo\n\n@example\n0 = f (x, xdot, t)\n@end example\n\nwith\n\n@example\nx(t_0) = x_0, xdot(t_0) = xdot_0\n@end example\n\n@end ifinfo\nThe solution is returned in the matrices @var{x} and @var{xdot},\nwith each row in the result matrices corresponding to one of the\nelements in the vector @var{t}.  The first element of @var{t}\nshould be @math{t_0} and correspond to the initial state of the\nsystem @var{x_0} and its derivative @var{xdot_0}, so that the first\nrow of the output @var{x} is @var{x_0} and the first row\nof the output @var{xdot} is @var{xdot_0}.\n\nThe first argument, @var{fcn}, is a string that names the function to\ncall to compute the vector of residuals for the set of equations.\nIt must have the form\n\n@example\n@var{res} = f (@var{x}, @var{xdot}, @var{t})\n@end example\n\n@noindent\nin which @var{x}, @var{xdot}, and @var{res} are vectors, and @var{t} is a\nscalar.\n\nIf @var{fcn} is a two-element string array, the first element names\nthe function @math{f} described above, and the second element names\na function to compute the modified Jacobian\n@tex\n$$\nJ = {\\partial f \\over \\partial x}\n  + c {\\partial f \\over \\partial \\dot{x}}\n$$\n@end tex\n@ifinfo\n\n@example\n      df       df\njac = -- + c ------\n      dx     d xdot\n@end example\n@end ifinfo\n\nThe modified Jacobian function must have the form\n\n@example\n\n@var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\n@end example\n\nThe second and third arguments to @code{daspk} specify the initial\ncondition of the states and their derivatives, and the fourth argument\nspecifies a vector of output times at which the solution is desired,\nincluding the time corresponding to the initial condition.\n\nThe set of initial states and derivatives are not strictly required to\nbe consistent.  If they are not consistent, you must use the\n@code{daspk_options} function to provide additional information so\nthat @code{daspk} can compute a consistent starting point.\n\nThe fifth argument is optional, and may be used to specify a set of\ntimes that the DAE solver should not integrate past.  It is useful for\navoiding difficulties with singularities and points where there is a\ndiscontinuity in the derivative.\n\nAfter a successful computation, the value of @var{istate} will be\ngreater than zero (consistent with the Fortran version of @sc{Daspk}).\n\nIf the computation is not successful, the value of @var{istate} will be\nless than zero and @var{msg} will contain additional information.\n\nYou can use the function @code{daspk_options} to set optional\nparameters for @code{daspk}.\n@end deftypefn\n@seealso{dassl}") 
