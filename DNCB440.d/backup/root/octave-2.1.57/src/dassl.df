 XDEFUN_DLD_INTERNAL (dassl_options, args, , 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {} dassl_options (@var{opt}, @var{val})\nWhen called with two arguments, this function\nallows you set options parameters for the function @code{dassl}.\nGiven one argument, @code{dassl_options} returns the value of the\ncorresponding option.  If no arguments are supplied, the names of all\nthe available options and their current values are displayed.\n\nOptions include\n\n@table @code\n@item \"absolute tolerance\"\nAbsolute tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector, and the relative\ntolerance must also be a vector of the same length.\n@item \"relative tolerance\"\nRelative tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector, and the absolute\ntolerance must also be a vector of the same length.\n\nThe local error test applied at each integration step is\n\n@example\n  abs (local error in x(i)) <= rtol(i) * abs (Y(i)) + atol(i)\n@end example\n@item \"compute consistent initial condition\"\nIf nonzero, @code{dassl} will attempt to compute a consistent set of intial\nconditions.  This is generally not reliable, so it is best to provide\na consistent set and leave this option set to zero.\n@item \"enforce nonnegativity constraints\"\nIf you know that the solutions to your equations will always be\nnonnegative, it may help to set this parameter to a nonzero\nvalue.  However, it is probably best to try leaving this option set to\nzero first, and only setting it to a nonzero value if that doesn't\nwork very well.\n@item \"initial step size\"\nDifferential-algebraic problems may occaisionally suffer from severe\nscaling difficulties on the first step.  If you know a great deal\nabout the scaling of your problem, you can help to alleviate this\nproblem by specifying an initial stepsize.\n@item \"maximum order\"\nRestrict the maximum order of the solution method.  This option must\nbe between 1 and 5, inclusive.\n@item \"maximum step size\"\nSetting the maximum stepsize will avoid passing over very large\nregions  (default is not specified).\n@item \"step limit\"\nMaximum number of integration steps to attempt on a single call to the\nunderlying Fortran code.\n@end table\n@end deftypefn") 
 XDEFUN_DLD_INTERNAL (dassl, args, nargout, 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\nSolve the set of differential-algebraic equations\n@tex\n$$ 0 = f (\\dot{x}, x, t) $$\nwith\n$$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n@end tex\n@ifinfo\n\n@example\n0 = f (x, xdot, t)\n@end example\n\nwith\n\n@example\nx(t_0) = x_0, xdot(t_0) = xdot_0\n@end example\n\n@end ifinfo\nThe solution is returned in the matrices @var{x} and @var{xdot},\nwith each row in the result matrices corresponding to one of the\nelements in the vector @var{t}.  The first element of @var{t}\nshould be @math{t_0} and correspond to the initial state of the\nsystem @var{x_0} and its derivative @var{xdot_0}, so that the first\nrow of the output @var{x} is @var{x_0} and the first row\nof the output @var{xdot} is @var{xdot_0}.\n\nThe first argument, @var{fcn}, is a string that names the function to\ncall to compute the vector of residuals for the set of equations.\nIt must have the form\n\n@example\n@var{res} = f (@var{x}, @var{xdot}, @var{t})\n@end example\n\n@noindent\nin which @var{x}, @var{xdot}, and @var{res} are vectors, and @var{t} is a\nscalar.\n\nIf @var{fcn} is a two-element string array, the first element names\nthe function @math{f} described above, and the second element names\na function to compute the modified Jacobian\n\n@tex\n$$\nJ = {\\partial f \\over \\partial x}\n  + c {\\partial f \\over \\partial \\dot{x}}\n$$\n@end tex\n@ifinfo\n      df       df\njac = -- + c ------\n      dx     d xdot\n@example\n@end example\n\n@end ifinfo\n\nThe modified Jacobian function must have the form\n\n@example\n\n@var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\n@end example\n\nThe second and third arguments to @code{dassl} specify the initial\ncondition of the states and their derivatives, and the fourth argument\nspecifies a vector of output times at which the solution is desired,\nincluding the time corresponding to the initial condition.\n\nThe set of initial states and derivatives are not strictly required to\nbe consistent.  In practice, however, @sc{Dassl} is not very good at\ndetermining a consistent set for you, so it is best if you ensure that\nthe initial values result in the function evaluating to zero.\n\nThe fifth argument is optional, and may be used to specify a set of\ntimes that the DAE solver should not integrate past.  It is useful for\navoiding difficulties with singularities and points where there is a\ndiscontinuity in the derivative.\n\nAfter a successful computation, the value of @var{istate} will be\ngreater than zero (consistent with the Fortran version of @sc{Dassl}).\n\nIf the computation is not successful, the value of @var{istate} will be\nless than zero and @var{msg} will contain additional information.\n\nYou can use the function @code{dassl_options} to set optional\nparameters for @code{dassl}.\n@end deftypefn\n@seealso{daspk, dasrt, lsode, odessa}") 
