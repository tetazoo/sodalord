 XDEFUN_DLD_INTERNAL (dasrt_options, args, , 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {} dasrt_options (@var{opt}, @var{val})\nWhen called with two arguments, this function\nallows you set options parameters for the function @code{dasrt}.\nGiven one argument, @code{dasrt_options} returns the value of the\ncorresponding option.  If no arguments are supplied, the names of all\nthe available options and their current values are displayed.\n\nOptions include\n\n@table @code\n@item \"absolute tolerance\"\nAbsolute tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector, and the relative\ntolerance must also be a vector of the same length.\n@item \"relative tolerance\"\nRelative tolerance.  May be either vector or scalar.  If a vector, it\nmust match the dimension of the state vector, and the absolute\ntolerance must also be a vector of the same length.\n\nThe local error test applied at each integration step is\n@example\n  abs (local error in x(i)) <= rtol(i) * abs (Y(i)) + atol(i)\n@end example\n@item \"initial step size\"\nDifferential-algebraic problems may occaisionally suffer from severe\nscaling difficulties on the first step.  If you know a great deal\nabout the scaling of your problem, you can help to alleviate this\nproblem by specifying an initial stepsize.\n@item \"maximum order\"\nRestrict the maximum order of the solution method.  This option must\nbe between 1 and 5, inclusive.\n@item \"maximum step size\"\nSetting the maximum stepsize will avoid passing over very large\nregions.\n@item \"step limit\"\nMaximum number of integration steps to attempt on a single call to the\nunderlying Fortran code.\n@end table\n@end deftypefn") 
 XDEFUN_DLD_INTERNAL (dasrt, args, nargout, 0, "-*- texinfo -*-\n@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn} [, @var{g}], @var{x_0}, @var{xdot_0}, @var{t} [, @var{t_crit}])\nSolve the set of differential-algebraic equations\n@tex\n$$ 0 = f (\\dot{x}, x, t) $$\nwith\n$$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n@end tex\n@ifinfo\n\n@example\n0 = f (xdot, x, t)\n@end example\n\nwith\n\n@example\nx(t_0) = x_0, xdot(t_0) = xdot_0\n@end example\n\n@end ifinfo\nwith functional stopping criteria (root solving).\n\nThe solution is returned in the matrices @var{x} and @var{xdot},\nwith each row in the result matrices corresponding to one of the\nelements in the vector @var{t_out}.  The first element of @var{t}\nshould be @math{t_0} and correspond to the initial state of the\nsystem @var{x_0} and its derivative @var{xdot_0}, so that the first\nrow of the output @var{x} is @var{x_0} and the first row\nof the output @var{xdot} is @var{xdot_0}.\n\nThe vector @var{t} provides an upper limit on the length of the\nintegration.  If the stopping condition is met, the vector\n@var{t_out} will be shorter than @var{t}, and the final element of\n@var{t_out} will be the point at which the stopping condition was met,\nand may not correspond to any element of the vector @var{t}.\n\nThe first argument, @var{fcn}, is a string that names the function to\ncall to compute the vector of residuals for the set of equations.\nIt must have the form\n\n@example\n@var{res} = f (@var{x}, @var{xdot}, @var{t})\n@end example\n\n@noindent\nin which @var{x}, @var{xdot}, and @var{res} are vectors, and @var{t} is a\nscalar.\n\nIf @var{fcn} is a two-element string array, the first element names\nthe function @math{f} described above, and the second element names\na function to compute the modified Jacobian\n\n@tex\n$$\nJ = {\\partial f \\over \\partial x}\n  + c {\\partial f \\over \\partial \\dot{x}}\n$$\n@end tex\n@ifinfo\n\n@example\n      df       df\njac = -- + c ------\n      dx     d xdot\n@end example\n\n@end ifinfo\n\nThe modified Jacobian function must have the form\n\n@example\n\n@var{jac} = j (@var{x}, @var{xdot}, @var{t}, @var{c})\n\n@end example\n\nThe optional second argument names a function that defines the\nconstraint functions whose roots are desired during the integration.\nThis function must have the form\n\n@example\n@var{g_out} = g (@var{x}, @var{t})\n@end example\n\nand return a vector of the constraint function values.\nIf the value of any of the constraint functions changes sign, @sc{Dasrt}\nwill attempt to stop the integration at the point of the sign change.\n\nIf the name of the constraint function is omitted, @code{dasrt} solves\nthe saem problem as @code{daspk} or @code{dassl}.\n\nNote that because of numerical errors in the constraint functions\ndue to roundoff and integration error, @sc{Dasrt} may return false\nroots, or return the same root at two or more nearly equal values of\n@var{T}.  If such false roots are suspected, the user should consider\nsmaller error tolerances or higher precision in the evaluation of the\nconstraint functions.\n\nIf a root of some constraint function defines the end of the problem,\nthe input to @sc{Dasrt} should nevertheless allow integration to a\npoint slightly past that root, so that @sc{Dasrt} can locate the root\nby interpolation.\n\nThe third and fourth arguments to @code{dasrt} specify the initial\ncondition of the states and their derivatives, and the fourth argument\nspecifies a vector of output times at which the solution is desired,\nincluding the time corresponding to the initial condition.\n\nThe set of initial states and derivatives are not strictly required to\nbe consistent.  In practice, however, @sc{Dassl} is not very good at\ndetermining a consistent set for you, so it is best if you ensure that\nthe initial values result in the function evaluating to zero.\n\nThe sixth argument is optional, and may be used to specify a set of\ntimes that the DAE solver should not integrate past.  It is useful for\navoiding difficulties with singularities and points where there is a\ndiscontinuity in the derivative.\n\nAfter a successful computation, the value of @var{istate} will be\ngreater than zero (consistent with the Fortran version of @sc{Dassl}).\n\nIf the computation is not successful, the value of @var{istate} will be\nless than zero and @var{msg} will contain additional information.\n\nYou can use the function @code{dasrt_options} to set optional\nparameters for @code{dasrt}.\n@end deftypefn\n@seealso{daspk, dasrt, lsode, odessa}") 
