 XDEFUN_INTERNAL (all, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} all (@var{x}, @var{dim})\nThe function @code{all} behaves like the function @code{any}, except\nthat it returns true only if all the elements of a vector, or all the\nelements along dimension @var{dim} of a matrix, are nonzero.\n@end deftypefn") 
 XDEFUN_INTERNAL (any, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} any (@var{x}, @var{dim})\nFor a vector argument, return 1 if any element of the vector is\nnonzero.\n\nFor a matrix argument, return a row vector of ones and\nzeros with each element indicating whether any of the elements of the\ncorresponding column of the matrix are nonzero.  For example,\n\n@example\n@group\nany (eye (2, 4))\n     @result{} [ 1, 1, 0, 0 ]\n@end group\n@end example\n\nIf the optional argument @var{dim} is supplied, work along dimension\n@var{dim}.  For example,\n\n@example\n@group\nany (eye (2, 4), 2)\n     @result{} [ 1; 1 ]\n@end group\n@end example\n@end deftypefn") 
 XDEFUN_INTERNAL (atan2, args, , false, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\nCompute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\nand @var{x}.  The result is in range -pi to pi.\n@end deftypefn") 
 XDEFUN_INTERNAL (fmod, args, , false, "-*- texinfo -*-\n@deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})\nCompute the floating point remainder of dividing @var{x} by @var{y}\nusing the C library function @code{fmod}.  The result has the same\nsign as @var{x}.  If @var{y} is zero, the result implementation-defined.\n@end deftypefn") 
 XDEFUN_INTERNAL (cumprod, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} cumprod (@var{x}, @var{dim})\nCumulative product of elements along dimension @var{dim}.  If\n@var{dim} is omitted, it defaults to 1 (column-wise cumulative\nproducts).\n@end deftypefn") 
 XDEFUN_INTERNAL (cumsum, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} cumsum (@var{x}, @var{dim})\nCumulative sum of elements along dimension @var{dim}.  If @var{dim}\nis omitted, it defaults to 1 (column-wise cumulative sums).\n@end deftypefn") 
 XDEFUN_INTERNAL (diag, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} diag (@var{v}, @var{k})\nReturn a diagonal matrix with vector @var{v} on diagonal @var{k}.  The\nsecond argument is optional.  If it is positive, the vector is placed on\nthe @var{k}-th super-diagonal.  If it is negative, it is placed on the\n@var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the\nvector is placed on the main diagonal.  For example,\n\n@example\n@group\ndiag ([1, 2, 3], 1)\n     @result{}  0  1  0  0\n         0  0  2  0\n         0  0  0  3\n         0  0  0  0\n@end group\n@end example\n@end deftypefn") 
 XDEFUN_INTERNAL (prod, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} prod (@var{x}, @var{dim})\nProduct of elements along dimension @var{dim}.  If @var{dim} is\nomitted, it defaults to 1 (column-wise products).\n@end deftypefn") 
 XDEFUN_INTERNAL (horzcat, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\nReturn the horizontal concatenation of N-d array objects, @var{array1},\n@var{array2}, @dots{}, @var{arrayN} along dimension 2.\n@end deftypefn\n@seealso{cat and vertcat}") 
 XDEFUN_INTERNAL (vertcat, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\nReturn the vertical concatenation of N-d array objects, @var{array1},\n@var{array2}, @dots{}, @var{arrayN} along dimension 1.\n@end deftypefn\n@seealso{cat and horzcat}") 
 XDEFUN_INTERNAL (cat, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\nReturn the concatenation of N-d array objects, @var{array1},\n@var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\n@example\n@group\nA = ones (2, 2);\nB = zeros (2, 2);\ncat (2, A, B)\n@result{} ans =\n\n     1 1 0 0\n     1 1 0 0\n     1 1 0 0\n     1 1 0 0\n@end group\n@end example\n\nAlternatively, we can concatenate @var{A} and @var{B} along the\nsecond dimension the following way:\n\n@example\n@group\n[A, B].\n@end group\n@end example\n\n@var{dim} can be larger than the dimensions of the N-d array objects\nand the result will thus have @var{dim} dimensions as the\nfollowing example shows:\n@example\n@group\ncat (4, ones(2, 2), zeros (2, 2))\n@result{} ans =\n\n   ans(:,:,1,1) =\n\n     1 1\n     1 1\n\n   ans(:,:,1,2) =\n     0 0\n     0 0\n@end group\n@end example\n\n@end deftypefn\n@seealso{horzcat and vertcat}") 
 XDEFUN_INTERNAL (permute, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} permute (@var{a}, @var{perm})\nReturn the generalized transpose for an N-d array object @var{a}.\nThe permutation vector @var{perm} must contain the elements\n@code{1:ndims(a)} (in any order, but each element must appear just once).\n\n@end deftypefn\n@seealso{ipermute}") 
 XDEFUN_INTERNAL (ipermute, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\nThe inverse of the @code{permute} function.  The expression\n\n@example\nipermute (permute (a, perm), perm)\n@end example\nreturns the original array @var{a}.\n\n@end deftypefn\n@seealso{permute}") 
 XDEFUN_INTERNAL (length, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} length (@var{a})\nReturn the `length' of the object @var{a}.  For matrix objects, the\nlength is the number of rows or columns, whichever is greater (this\nodd definition is used for compatibility with Matlab).\n@end deftypefn") 
 XDEFUN_INTERNAL (ndims, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} ndims (@var{a})\nReturns the number of dimensions of array @var{a}.\nFor any array, the result will always be larger than or equal to 2.\nTrailing singleton dimensions are not counted.\n@end deftypefn") 
 XDEFUN_INTERNAL (numel, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} numel (@var{a})\nReturns the number of elements in the object @var{a}.\n@end deftypefn") 
 XDEFUN_INTERNAL (size, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} size (@var{a}, @var{n})\nReturn the number rows and columns of @var{a}.\n\nWith one input argument and one output argument, the result is returned\nin a row vector.  If there are multiple output arguments, the number of\nrows is assigned to the first, and the number of columns to the second,\netc.  For example,\n\n@example\n@group\nsize ([1, 2; 3, 4; 5, 6])\n     @result{} [ 3, 2 ]\n\n[nr, nc] = size ([1, 2; 3, 4; 5, 6])\n     @result{} nr = 3\n     @result{} nc = 2\n@end group\n@end example\n\nIf given a second argument, @code{size} will return the size of the\ncorresponding dimension.  For example\n\n@example\nsize ([1, 2; 3, 4; 5, 6], 2)\n     @result{} 2\n@end example\n\n@noindent\nreturns the number of columns in the given matrix.\n@end deftypefn") 
 XDEFUN_INTERNAL (sum, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} sum (@var{x}, @var{dim})\nSum of elements along dimension @var{dim}.  If @var{dim} is\nomitted, it defaults to 1 (column-wise sum).\n@end deftypefn") 
 XDEFUN_INTERNAL (sumsq, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} sumsq (@var{x}, @var{dim})\nSum of squares of elements along dimension @var{dim}.  If @var{dim}\nis omitted, it defaults to 1 (column-wise sum of squares).\n\nThis function is equivalent to computing\n@example\nsum (x .* conj (x), dim)\n@end example\nbut it uses less memory and avoids calling conj if @var{x} is real.\n@end deftypefn") 
 XDEFUN_INTERNAL (isbool, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Functio} {} isbool (@var{x})\nReturn true if @var{x} is a boolean object.\n@end deftypefn") 
 XDEFALIAS_INTERNAL(islogical, isbool) ;
 XDEFUN_INTERNAL (iscomplex, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} iscomplex (@var{x})\nReturn true if @var{x} is a complex-valued numeric object.\n@end deftypefn") 
 XDEFUN_INTERNAL (isreal, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} isreal (@var{x})\nReturn true if @var{x} is a real-valued numeric object.\n@end deftypefn") 
 XDEFUN_INTERNAL (isempty, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} isempty (@var{a})\nReturn 1 if @var{a} is an empty matrix (either the number of rows, or\nthe number of columns, or both are zero).  Otherwise, return 0.\n@end deftypefn") 
 XDEFUN_INTERNAL (isnumeric, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} isnumeric (@var{x})\nReturn nonzero if @var{x} is a numeric object.\n@end deftypefn") 
 XDEFUN_INTERNAL (islist, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} islist (@var{x})\nReturn nonzero if @var{x} is a list.\n@end deftypefn") 
 XDEFUN_INTERNAL (ismatrix, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} ismatrix (@var{a})\nReturn 1 if @var{a} is a matrix.  Otherwise, return 0.\n@end deftypefn") 
 XDEFUN_INTERNAL (ones, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} ones (@var{x})\n@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m})\n@deftypefnx {Built-in Function} {} ones (@var{n}, @var{m}, @var{k},...)\nReturn a matrix or N-dimensional array whose elements are all 1.\nThe arguments are handled the same as the arguments for @code{eye}.\n\nIf you need to create a matrix whose values are all the same, you should\nuse an expression like\n\n@example\nval_matrix = val * ones (n, m)\n@end example\n@end deftypefn") 
 XDEFUN_INTERNAL (zeros, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} zeros (@var{x})\n@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})\n@deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m}, @var{k},...)\nReturn a matrix or N-dimensional array whose elements are all 0.\nThe arguments are handled the same as the arguments for @code{eye}.\n@end deftypefn") 
 XDEFUN_INTERNAL (eye, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} eye (@var{x})\n@deftypefnx {Built-in Function} {} eye (@var{n}, @var{m})\nReturn an identity matrix.  If invoked with a single scalar argument,\n@code{eye} returns a square matrix with the dimension specified.  If you\nsupply two scalar arguments, @code{eye} takes them to be the number of\nrows and columns.  If given a vector with two elements, @code{eye} uses\nthe values of the elements as the number of rows and columns,\nrespectively.  For example,\n\n@example\n@group\neye (3)\n     @result{}  1  0  0\n         0  1  0\n         0  0  1\n@end group\n@end example\n\nThe following expressions all produce the same result:\n\n@example\n@group\neye (2)\n@equiv{}\neye (2, 2)\n@equiv{}\neye (size ([1, 2; 3, 4])\n@end group\n@end example\n\nFor compatibility with @sc{Matlab}, calling @code{eye} with no arguments\nis equivalent to calling it with an argument of 1.\n@end deftypefn") 
 XDEFUN_INTERNAL (linspace, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\nReturn a row vector with @var{n} linearly spaced elements between\n@var{base} and @var{limit}.  The number of elements, @var{n}, must be\ngreater than 1.  The @var{base} and @var{limit} are always included in\nthe range.  If @var{base} is greater than @var{limit}, the elements are\nstored in decreasing order.  If the number of points is not specified, a\nvalue of 100 is used.\n\nThe @code{linspace} function always returns a row vector.\n@end deftypefn") 
 XDEFUN_INTERNAL (reshape, args, , false, "-*- texinfo -*-\n@deftypefn {Function File} {} reshape (@var{a}, @var{m}, @var{n}, @dots{})\n@deftypefnx {Function File} {} reshape (@var{a}, @var{siz})\nReturn a matrix with the given dimensions whose elements are taken\nfrom the matrix @var{a}.  The elements of the matrix are access in\ncolumn-major order (like Fortran arrays are stored).\n\nFor example,\n\n@example\n@group\nreshape ([1, 2, 3, 4], 2, 2)\n     @result{}  1  3\n         2  4\n@end group\n@end example\n\n@noindent\nNote that the total number of elements in the original\nmatrix must match the total number of elements in the new matrix.\n@end deftypefn") 
 XDEFUN_INTERNAL (squeeze, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} squeeze (@var{x})\nRemove singleton dimensions from @var{x} and return the result.\n@end deftypefn") 
   XDEFCONST_INTERNAL(I, Complex (0.0, 1.0), "-*- texinfo -*-\n@defvr {Built-in Variable} I\n@defvrx {Built-in Variable} J\n@defvrx {Built-in Variable} i\n@defvrx {Built-in Variable} j\nA pure imaginary number, defined as\n@iftex\n@tex\n  $\\sqrt{-1}$.\n@end tex\n@end iftex\n@ifinfo\n  @code{sqrt (-1)}.\n@end ifinfo\nThe @code{I} and @code{J} forms are true constants, and cannot be\nmodified.  The @code{i} and @code{j} forms are like ordinary variables,\nand may be used for other purposes.  However, unlike other variables,\nthey once again assume their special predefined values if they are\ncleared @xref{Status of Variables}.\n@end defvr") ;
   XDEFCONST_INTERNAL(Inf, lo_ieee_inf_value (), "-*- texinfo -*-\n@defvr {Built-in Variable} Inf\n@defvrx {Built-in Variable} inf\nInfinity.  This is the result of an operation like 1/0, or an operation\nthat results in a floating point overflow.\n@end defvr") ;
   XDEFCONST_INTERNAL(J, Complex (0.0, 1.0), "-*- texinfo -*-\n@defvr {Built-in Variable} I\n@defvrx {Built-in Variable} J\n@defvrx {Built-in Variable} i\n@defvrx {Built-in Variable} j\nA pure imaginary number, defined as\n@iftex\n@tex\n  $\\sqrt{-1}$.\n@end tex\n@end iftex\n@ifinfo\n  @code{sqrt (-1)}.\n@end ifinfo\nThe @code{I} and @code{J} forms are true constants, and cannot be\nmodified.  The @code{i} and @code{j} forms are like ordinary variables,\nand may be used for other purposes.  However, unlike other variables,\nthey once again assume their special predefined values if they are\ncleared @xref{Status of Variables}.\n@end defvr") ;
   XDEFCONST_INTERNAL(NA, lo_ieee_na_value (), "-*- texinfo -*-\n@defvr {Built-in Variable} NA\nMissing value.\n@end defvr") ;
   XDEFCONST_INTERNAL(NaN, lo_ieee_nan_value (), "-*- texinfo -*-\n@defvr {Built-in Variable} NaN\n@defvrx {Built-in Variable} nan\nNot a number.  This is the result of an operation like\n@iftex\n@tex\n$0/0$, or $\\infty - \\infty$,\n@end tex\n@end iftex\n@ifinfo\n0/0, or @samp{Inf - Inf},\n@end ifinfo\nor any operation with a NaN.\n\nNote that NaN always compares not equal to NaN.  This behavior is\nspecified by the IEEE standard for floating point arithmetic.  To\nfind NaN values, you must use the @code{isnan} function.\n@end defvr") ;
   XDEFCONST_INTERNAL(e, e_val, "-*- texinfo -*-\n@defvr {Built-in Variable} e\nThe base of natural logarithms.  The constant\n@iftex\n@tex\n $e$\n@end tex\n@end iftex\n@ifinfo\n @var{e}\n@end ifinfo\n satisfies the equation\n@iftex\n@tex\n $\\log (e) = 1$.\n@end tex\n@end iftex\n@ifinfo\n @code{log} (@var{e}) = 1.\n@end ifinfo\n@end defvr") ;
   XDEFCONST_INTERNAL(eps, 2.2204460492503131e-16, "-*- texinfo -*-\n@defvr {Built-in Variable} eps\nThe machine precision.  More precisely, @code{eps} is the largest\nrelative spacing between any two adjacent numbers in the machine's\nfloating point system.  This number is obviously system-dependent.  On\nmachines that support 64 bit IEEE floating point arithmetic, @code{eps}\nis approximately\n@ifinfo\n 2.2204e-16.\n@end ifinfo\n@iftex\n@tex\n $2.2204\\times10^{-16}$.\n@end tex\n@end iftex\n@end defvr") ;
   XDEFCONST_INTERNAL(false, false, "-*- texinfo -*-\n@defvr {Built-in Variable} false\nLogical false value.\n@end defvr") ;
   XDEFCONST_INTERNAL(i, Complex (0.0, 1.0), "-*- texinfo -*-\n@defvr {Built-in Variable} I\n@defvrx {Built-in Variable} J\n@defvrx {Built-in Variable} i\n@defvrx {Built-in Variable} j\nA pure imaginary number, defined as\n@iftex\n@tex\n  $\\sqrt{-1}$.\n@end tex\n@end iftex\n@ifinfo\n  @code{sqrt (-1)}.\n@end ifinfo\nThe @code{I} and @code{J} forms are true constants, and cannot be\nmodified.  The @code{i} and @code{j} forms are like ordinary variables,\nand may be used for other purposes.  However, unlike other variables,\nthey once again assume their special predefined values if they are\ncleared @xref{Status of Variables}.\n@end defvr") ;
   XDEFCONST_INTERNAL(inf, lo_ieee_inf_value (), "-*- texinfo -*-\n@defvr {Built-in Variable} Inf\n@defvrx {Built-in Variable} inf\nInfinity.  This is the result of an operation like 1/0, or an operation\nthat results in a floating point overflow.\n@end defvr") ;
   XDEFCONST_INTERNAL(j, Complex (0.0, 1.0), "-*- texinfo -*-\n@defvr {Built-in Variable} I\n@defvrx {Built-in Variable} J\n@defvrx {Built-in Variable} i\n@defvrx {Built-in Variable} j\nA pure imaginary number, defined as\n@iftex\n@tex\n  $\\sqrt{-1}$.\n@end tex\n@end iftex\n@ifinfo\n  @code{sqrt (-1)}.\n@end ifinfo\nThe @code{I} and @code{J} forms are true constants, and cannot be\nmodified.  The @code{i} and @code{j} forms are like ordinary variables,\nand may be used for other purposes.  However, unlike other variables,\nthey once again assume their special predefined values if they are\ncleared @xref{Status of Variables}.\n@end defvr") ;
   XDEFCONST_INTERNAL(nan, lo_ieee_nan_value (), "-*- texinfo -*-\n@defvr {Built-in Variable} NaN\n@defvrx {Built-in Variable} nan\nNot a number.  This is the result of an operation like\n@iftex\n@tex\n$0/0$, or $\\infty - \\infty$,\n@end tex\n@end iftex\n@ifinfo\n0/0, or @samp{Inf - Inf},\n@end ifinfo\nor any operation with a NaN.\n\nNote that NaN always compares not equal to NaN.  This behavior is\nspecified by the IEEE standard for floating point arithmetic.  To\nfind NaN values, you must use the @code{isnan} function.\n@end defvr") ;
   XDEFCONST_INTERNAL(pi, pi_val, "-*- texinfo -*-\n@defvr {Built-in Variable} pi\nThe ratio of the circumference of a circle to its diameter.\nInternally, @code{pi} is computed as @samp{4.0 * atan (1.0)}.\n@end defvr") ;
   XDEFCONST_INTERNAL(realmax, 1.7976931348623157e+308, "-*- texinfo -*-\n@defvr {Built-in Variable} realmax\nThe largest floating point number that is representable.  The actual\nvalue is system-dependent.  On machines that support 64-bit IEEE\nfloating point arithmetic, @code{realmax} is approximately\n@ifinfo\n 1.7977e+308\n@end ifinfo\n@iftex\n@tex\n $1.7977\\times10^{308}$.\n@end tex\n@end iftex\n@end defvr") ;
   XDEFCONST_INTERNAL(realmin, 2.2250738585072014e-308, "-*- texinfo -*-\n@defvr {Built-in Variable} realmin\nThe smallest normalized floating point number that is representable.\nThe actual value is system-dependent.  On machines that support\n64-bit IEEE floating point arithmetic, @code{realmin} is approximately\n@ifinfo\n 2.2251e-308\n@end ifinfo\n@iftex\n@tex\n $2.2251\\times10^{-308}$.\n@end tex\n@end iftex\n@end defvr") ;
   XDEFCONST_INTERNAL(true, true, "-*- texinfo -*-\n@defvr {Built-in Variable} true\nLogical true value.\n@end defvr") ;
