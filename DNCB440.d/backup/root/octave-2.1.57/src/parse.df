 XDEFUN_INTERNAL (source, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} source (@var{file})\nParse and execute the contents of @var{file}.  This is equivalent to\nexecuting commands from a script file, but without requiring the file to\nbe named @file{@var{file}.m}.\n@end deftypefn") 
 XDEFUN_INTERNAL (feval, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} feval (@var{name}, @dots{})\nEvaluate the function named @var{name}.  Any arguments after the first\nare passed on to the named function.  For example,\n\n@example\nfeval (\"acos\", -1)\n     @result{} 3.1416\n@end example\n\n@noindent\ncalls the function @code{acos} with the argument @samp{-1}.\n\nThe function @code{feval} is necessary in order to be able to write\nfunctions that call user-supplied functions, because Octave does not\nhave a way to declare a pointer to a function (like C) or to declare a\nspecial kind of variable that can be used to hold the name of a function\n(like @code{EXTERNAL} in Fortran).  Instead, you must refer to functions\nby name, and use @code{feval} to call them.\n@end deftypefn") 
 XDEFUN_INTERNAL (eval, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} eval (@var{try}, @var{catch})\nParse the string @var{try} and evaluate it as if it were an Octave\nprogram.  If that fails, evaluate the string @var{catch}.\nThe string @var{try} is evaluated in the current context,\nso any results remain available after @code{eval} returns.\n@end deftypefn") 
 XDEFUN_INTERNAL (assignin, args, , false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\nAssign @var{value} to @var{varname} in context @var{context}, which\nmay be either @code{\"base\"} or @code{\"caller\"}.\n@end deftypefn") 
 XDEFUN_INTERNAL (evalin, args, nargout, false, "-*- texinfo -*-\n@deftypefn {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\nLike @code{eval}, except that the expressions are evaluated in the\ncontext @var{context}, which may be either @code{\"caller\"} or\n@code{\"base\"}.\n@end deftypefn") 
   XDEFVAR_INTERNAL("warn_assign_as_truth_value", SBV_warn_assign_as_truth_value, true, false, warn_assign_as_truth_value, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_assign_as_truth_value\nIf the value of @code{warn_assign_as_truth_value} is nonzero, a\nwarning is issued for statements like\n\n@example\nif (s = t)\n  ...\n@end example\n\n@noindent\nsince such statements are not common, and it is likely that the intent\nwas to write\n\n@example\nif (s == t)\n  ...\n@end example\n\n@noindent\ninstead.\n\nThere are times when it is useful to write code that contains\nassignments within the condition of a @code{while} or @code{if}\nstatement.  For example, statements like\n\n@example\nwhile (c = getc())\n  ...\n@end example\n\n@noindent\nare common in C programming.\n\nIt is possible to avoid all warnings about such statements by setting\n@code{warn_assign_as_truth_value} to 0, but that may also\nlet real errors like\n\n@example\nif (x = 1)  # intended to test (x == 1)!\n  ...\n@end example\n\n@noindent\nslip by.\n\nIn such cases, it is possible suppress errors for specific statements by\nwriting them with an extra set of parentheses.  For example, writing the\nprevious example as\n\n@example\nwhile ((c = getc()))\n  ...\n@end example\n\n@noindent\nwill prevent the warning from being printed for this statement, while\nallowing Octave to warn about other assignments used in conditional\ncontexts.\n\nThe default value of @code{warn_assign_as_truth_value} is 1.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_function_name_clash", SBV_warn_function_name_clash, true, false, warn_function_name_clash, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_function_name_clash\nIf the value of @code{warn_function_name_clash} is nonzero, a warning is\nissued when Octave finds that the name of a function defined in a\nfunction file differs from the name of the file.  (If the names\ndisagree, the name declared inside the file is ignored.)  If the value\nis 0, the warning is omitted.  The default value is 1.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_future_time_stamp", SBV_warn_future_time_stamp, true, false, warn_future_time_stamp, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_future_time_stamp\nIf the value of this variable is nonzero, Octave will print a warning\nif it finds a function file with a time stamp that is in the future.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_missing_semicolon", SBV_warn_missing_semicolon, false, false, warn_missing_semicolon, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_missing_semicolon\nIf the value of this variable is nonzero, Octave will warn when\nstatements in function definitions don't end in semicolons.  The default\nvalue is 0.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_precedence_change", SBV_warn_precedence_change, true, false, warn_precedence_change, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_precedence_change\nIf the value of this variable is nonzero, Octave will warn about\npossible changes in the meaning of some code due to changes in\nprecedence for some operators.  Precedence changes have typically\nbeen made for Matlab compatibility.  The default value is 1.\n@end defvr") ;
   XDEFVAR_INTERNAL("warn_variable_switch_label", SBV_warn_variable_switch_label, false, false, warn_variable_switch_label, "-*- texinfo -*-\n@defvr {Built-in Variable} warn_variable_switch_label\nIf the value of this variable is nonzero, Octave will print a warning if\na switch label is not a constant or constant expression\n@end defvr") ;
