<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from octave.texi on 15 March 2004 -->

<TITLE>GNU Octave - Data Types</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_3.html">previous</A>, <A HREF="octave_5.html">next</A>, <A HREF="octave_45.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC42" HREF="octave_toc.html#TOC42">Data Types</A></H1>
<P>
<A NAME="IDX124"></A>


<P>
All versions of Octave include a number of built-in data types,
including real and complex scalars and matrices, character strings, and
a data structure type.


<P>
It is also possible to define new specialized data types by writing a
small amount of C++ code.  On some systems, new data types can be loaded
dynamically while Octave is running, so it is not necessary to recompile
all of Octave just to add a new type.  See section <A HREF="octave_14.html#SEC106">Dynamically Linked Functions</A>, for more information about Octave's dynamic linking
capabilities.  section <A HREF="octave_4.html#SEC48">User-defined Data Types</A> describes what you must do
to define a new data type for Octave.


<P>
@anchor{doc-typeinfo}
<DL>
<DT><U>Built-in Function:</U>  <B>typeinfo</B> <I>(<VAR>expr</VAR>)</I>
<DD><A NAME="IDX125"></A>


<P>
Return the type of the expression <VAR>expr</VAR>, as a string.  If
<VAR>EXPR</VAR>  is omitted, return an array of strings containing all the
currently installed data types.
</DL>




<H2><A NAME="SEC43" HREF="octave_toc.html#TOC43">Built-in Data Types</A></H2>
<P>
<A NAME="IDX126"></A>
<A NAME="IDX127"></A>


<P>
The standard built-in data types are real and complex scalars and
matrices, ranges, character strings, and a data structure type.
Additional built-in data types may be added in future versions.  If you
need a specialized data type that is not currently provided as a
built-in type, you are encouraged to write your own user-defined data
type and contribute it for distribution in a future release of Octave.




<H3><A NAME="SEC44" HREF="octave_toc.html#TOC44">Numeric Objects</A></H3>
<P>
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>


<P>
Octave's built-in numeric objects include real and complex scalars and
matrices.  All built-in numeric data is currently stored as double
precision numbers.  On systems that use the IEEE floating point format,
values in the range of approximately
 2.2251e-308 to 1.7977e+308
 can be stored, and the relative precision is approximately
 2.2204e-16.
The exact values are given by the variables <CODE>realmin</CODE>,
<CODE>realmax</CODE>, and <CODE>eps</CODE>, respectively.


<P>
Matrix objects can be of any size, and can be dynamically reshaped and
resized.  It is easy to extract individual rows, columns, or submatrices
using a variety of powerful indexing features.  See section <A HREF="octave_11.html#SEC73">Index Expressions</A>.


<P>
See section <A HREF="octave_5.html#SEC50">Numeric Data Types</A>, for more information.




<H3><A NAME="SEC45" HREF="octave_toc.html#TOC45">Missing Data</A></H3>
<P>
<A NAME="IDX130"></A>


<P>
@anchor{doc-NA}
<DL>
<DT><U>Built-in Variable:</U> <B>NA</B>
<DD><A NAME="IDX131"></A>
Missing value.
</DL>


<P>
@anchor{doc-isna}
<DL>
<DT><U>Mapping Function:</U>  <B>isna</B> <I>(<VAR>x</VAR>)</I>
<DD><A NAME="IDX132"></A>
Return 1 for elements of <VAR>x</VAR> that are NA (missing) values and zero
otherwise. For example,



<PRE>
is_NA ([13, Inf, NA, NaN])
     => [ 0, 0, 1, 0 ]
</PRE>

</DL>

<P>
@anchor{doc-is_nan_or_na}
<DL>
<DT><U>Mapping Function:</U>  <B>is_nan_or_na</B> <I>(<VAR>x</VAR>)</I>
<DD><A NAME="IDX133"></A>
Return 1 for elements of <VAR>x</VAR> that are NaN or NA (missing) values
and zero otherwise. For example,



<PRE>
is_NAN_or_NA ([13, Inf, NA, NaN])
     => [ 0, 0, 1, 1 ]
</PRE>

</DL>



<H3><A NAME="SEC46" HREF="octave_toc.html#TOC46">String Objects</A></H3>
<P>
<A NAME="IDX134"></A>
<A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<A NAME="IDX137"></A>


<P>
A character string in Octave consists of a sequence of characters
enclosed in either double-quote or single-quote marks.  Internally,
Octave currently stores strings as matrices of characters.  All the
indexing operations that work for matrix objects also work for strings.


<P>
See section <A HREF="octave_6.html#SEC56">Strings</A>, for more information.




<H3><A NAME="SEC47" HREF="octave_toc.html#TOC47">Data Structure Objects</A></H3>
<P>
<A NAME="IDX138"></A>
<A NAME="IDX139"></A>


<P>
Octave's data structure type can help you to organize related objects of
different types.  The current implementation uses an associative array
with indices limited to strings, but the syntax is more like C-style
structures.


<P>
See section <A HREF="octave_7.html#SEC61">Data Structures</A>, for more information.




<H2><A NAME="SEC48" HREF="octave_toc.html#TOC48">User-defined Data Types</A></H2>
<P>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>


<P>
Someday I hope to expand this to include a complete description of
Octave's mechanism for managing user-defined data types.  Until this
feature is documented here, you will have to make do by reading the code
in the <TT>`ov.h'</TT>, <TT>`ops.h'</TT>, and related files from Octave's
<TT>`src'</TT> directory.




<H2><A NAME="SEC49" HREF="octave_toc.html#TOC49">Object Sizes</A></H2>

<P>
The following functions allow you to determine the size of a variable or
expression.  These functions are defined for all objects.  They return
-1 when the operation doesn't make sense.  For example, Octave's
data structure type doesn't have rows or columns, so the <CODE>rows</CODE> and
<CODE>columns</CODE> functions return -1 for structure arguments.


<P>
@anchor{doc-columns}
<DL>
<DT><U>Function File:</U>  <B>columns</B> <I>(<VAR>a</VAR>)</I>
<DD><A NAME="IDX142"></A>
Return the number of columns of <VAR>a</VAR>.
</DL>
@seealso{size, rows, length, isscalar, isvector, and ismatrix}


<P>
@anchor{doc-rows}
<DL>
<DT><U>Function File:</U>  <B>rows</B> <I>(<VAR>a</VAR>)</I>
<DD><A NAME="IDX143"></A>
Return the number of rows of <VAR>a</VAR>.
</DL>
@seealso{size, columns, length, isscalar, isvector, and ismatrix}


<P>
@anchor{doc-length}
<DL>
<DT><U>Built-in Function:</U>  <B>length</B> <I>(<VAR>a</VAR>)</I>
<DD><A NAME="IDX144"></A>
Return the `length' of the object <VAR>a</VAR>.  For matrix objects, the
length is the number of rows or columns, whichever is greater (this
odd definition is used for compatibility with Matlab).
</DL>


<P>
@anchor{doc-size}
<DL>
<DT><U>Built-in Function:</U>  <B>size</B> <I>(<VAR>a</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX145"></A>
Return the number rows and columns of <VAR>a</VAR>.


<P>
With one input argument and one output argument, the result is returned
in a row vector.  If there are multiple output arguments, the number of
rows is assigned to the first, and the number of columns to the second,
etc.  For example,



<PRE>
size ([1, 2; 3, 4; 5, 6])
     => [ 3, 2 ]

[nr, nc] = size ([1, 2; 3, 4; 5, 6])
     => nr = 3
     => nc = 2
</PRE>

<P>
If given a second argument, <CODE>size</CODE> will return the size of the
corresponding dimension.  For example



<PRE>
size ([1, 2; 3, 4; 5, 6], 2)
     => 2
</PRE>

<P>
returns the number of columns in the given matrix.
</DL>


<P>
@anchor{doc-isempty}
<DL>
<DT><U>Built-in Function:</U>  <B>isempty</B> <I>(<VAR>a</VAR>)</I>
<DD><A NAME="IDX146"></A>
Return 1 if <VAR>a</VAR> is an empty matrix (either the number of rows, or
the number of columns, or both are zero).  Otherwise, return 0.
</DL>


<P><HR><P>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_3.html">previous</A>, <A HREF="octave_5.html">next</A>, <A HREF="octave_45.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
</BODY>
</HTML>
