<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from octave.texi on 15 March 2004 -->

<TITLE>GNU Octave - Signal Processing</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_30.html">previous</A>, <A HREF="octave_32.html">next</A>, <A HREF="octave_45.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC201" HREF="octave_toc.html#TOC201">Signal Processing</A></H1>

<P>
I hope that someday Octave will include more signal processing
functions.  If you would like to help improve Octave in this area,
please contact <A HREF="mailto:bug-octave@bevo.che.wisc.edu">bug-octave@bevo.che.wisc.edu</A>.


<P>
@anchor{doc-detrend}
<DL>
<DT><U>Function File:</U>  <B>detrend</B> <I>(<VAR>x</VAR>, <VAR>p</VAR>)</I>
<DD><A NAME="IDX1167"></A>
If <VAR>x</VAR> is a vector, <CODE>detrend (<VAR>x</VAR>, <VAR>p</VAR>)</CODE> removes the
best fit of a polynomial of order <VAR>p</VAR> from the data <VAR>x</VAR>.


<P>
If <VAR>x</VAR> is a matrix, <CODE>detrend (<VAR>x</VAR>, <VAR>p</VAR>)</CODE> does the same
for each column in <VAR>x</VAR>.


<P>
The second argument is optional.  If it is not specified, a value of 1
is assumed.  This corresponds to removing a linear trend.
</DL>


<P>
@anchor{doc-fft}
<DL>
<DT><U>Loadable Function:</U>  <B>fft</B> <I>(<VAR>a</VAR>, <VAR>n</VAR>, <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1168"></A>
Compute the FFT of <VAR>a</VAR> using subroutines from
FFTPACK. The FFT is calculated along the first non-singleton dimension of the
array. Thus if <VAR>a</VAR> is a matrix, <CODE>fft (<VAR>a</VAR>)</CODE> computes the
FFT for each column of <VAR>a</VAR>.


<P>
If called with two arguments, <VAR>n</VAR> is expected to be an integer
specifying the number of elements of <VAR>a</VAR> to use, or an empty
matrix to specify that its value should be ignored. If <VAR>n</VAR> is
larger than the dimension along which the FFT is calculated, then
<VAR>a</VAR> is resized and padded with zeros. Otherwise, if<VAR>n</VAR> is
smaller than the dimension along which the FFT is calculated, then
<VAR>a</VAR> is truncated.


<P>
If called with three agruments, <VAR>dim</VAR> is an integer specifying the
dimension of the matrix along which the FFT is performed
</DL>
@seealso {ifft, fft2, fftn, fftw_wisdom}


<P>
@anchor{doc-ifft}
<DL>
<DT><U>Loadable Function:</U>  <B>ifft</B> <I>(<VAR>a</VAR>, <VAR>n</VAR>, <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1169"></A>
Compute the inverse FFT of <VAR>a</VAR> using subroutines from
FFTPACK. The inverse FFT is calculated along the first non-singleton dimension
of the array. Thus if <VAR>a</VAR> is a matrix, <CODE>fft (<VAR>a</VAR>)</CODE> computes
the inverse FFT for each column of <VAR>a</VAR>.


<P>
If called with two arguments, <VAR>n</VAR> is expected to be an integer
specifying the number of elements of <VAR>a</VAR> to use, or an empty
matrix to specify that its value should be ignored. If <VAR>n</VAR> is
larger than the dimension along which the inverse FFT is calculated, then
<VAR>a</VAR> is resized and padded with zeros. Otherwise, if<VAR>n</VAR> is
smaller than the dimension along which the inverse FFT is calculated,
then <VAR>a</VAR> is truncated.


<P>
If called with three agruments, <VAR>dim</VAR> is an integer specifying the
dimension of the matrix along which the inverse FFT is performed
</DL>
@seealso {fft, ifft2, ifftn, fftw_wisdom}


<P>
@anchor{doc-fft2}
<DL>
<DT><U>Loadable Function:</U>  <B>fft2</B> <I>(<VAR>a</VAR>, <VAR>n</VAR>, <VAR>m</VAR>)</I>
<DD><A NAME="IDX1170"></A>
Compute the two dimensional FFT of <VAR>a</VAR> using subroutines from
FFTPACK. The optional arguments <VAR>n</VAR> and <VAR>m</VAR> may be used specify the
number of rows and columns of <VAR>a</VAR> to use.  If either of these is
larger than the size of <VAR>a</VAR>, <VAR>a</VAR> is resized and padded with
zeros.


<P>
If <VAR>a</VAR> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <VAR>a</VAR> is treated seperately
</DL>
@seealso {ifft2, fft, fftn fftw_wisdom}


<P>
@anchor{doc-ifft2}
<DL>
<DT><U>Loadable Function:</U>  <B>fft2</B> <I>(<VAR>a</VAR>, <VAR>n</VAR>, <VAR>m</VAR>)</I>
<DD><A NAME="IDX1171"></A>
Compute the inverse two dimensional FFT of <VAR>a</VAR> using subroutines from
FFTPACK. The optional arguments <VAR>n</VAR> and <VAR>m</VAR> may be used specify the
number of rows and columns of <VAR>a</VAR> to use.  If either of these is
larger than the size of <VAR>a</VAR>, <VAR>a</VAR> is resized and padded with
zeros.


<P>
If <VAR>a</VAR> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <VAR>a</VAR> is treated seperately
</DL>
@seealso {fft2, ifft, ifftn, fftw_wisdom}


<P>
@anchor{doc-fftn}
<DL>
<DT><U>Loadable Function:</U>  <B>fftn</B> <I>(<VAR>a</VAR>, <VAR>size</VAR>)</I>
<DD><A NAME="IDX1172"></A>
Compute the N dimensional FFT of <VAR>a</VAR> using subroutines from
FFTPACK. The optional vector argument <VAR>size</VAR> may be used specify the
dimensions of the array to be used. If an element of <VAR>size</VAR> is
smaller than the corresponding dimension, then the dimension is
truncated prior to performing the FFT. Otherwise if an element
of <VAR>size</VAR> is larger than the corresponding dimension <VAR>a</VAR>
is resized and padded with zeros.
</DL>
@seealso {ifftn, fft, fft2, fftw_wisdom}


<P>
@anchor{doc-ifftn}
<DL>
<DT><U>Loadable Function:</U>  <B>ifftn</B> <I>(<VAR>a</VAR>, <VAR>size</VAR>)</I>
<DD><A NAME="IDX1173"></A>
Compute the invesre N dimensional FFT of <VAR>a</VAR> using subroutines from
FFTPACK. The optional vector argument <VAR>size</VAR> may be used specify the
dimensions of the array to be used. If an element of <VAR>size</VAR> is
smaller than the corresponding dimension, then the dimension is
truncated prior to performing the inverse FFT. Otherwise if an element
of <VAR>size</VAR> is larger than the corresponding dimension <VAR>a</VAR>
is resized and padded with zeros.
</DL>
@seealso {fftn, ifft, ifft2, fftw_wisdom}


<P>
@anchor{doc-fftconv}
<DL>
<DT><U>Function File:</U>  <B>fftconv</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX1174"></A>
Return the convolution of the vectors <VAR>a</VAR> and <VAR>b</VAR>, as a vector
with length equal to the <CODE>length (a) + length (b) - 1</CODE>.  If <VAR>a</VAR>
and <VAR>b</VAR> are the coefficient vectors of two polynomials, the returned
value is the coefficient vector of the product polynomial.


<P>
The computation uses the FFT by calling the function <CODE>fftfilt</CODE>.  If
the optional argument <VAR>n</VAR> is specified, an N-point FFT is used.
</DL>


<P>
@anchor{doc-fftfilt}
<DL>
<DT><U>Function File:</U>  <B>fftfilt</B> <I>(<VAR>b</VAR>, <VAR>x</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX1175"></A>


<P>
With two arguments, <CODE>fftfilt</CODE> filters <VAR>x</VAR> with the FIR filter
<VAR>b</VAR> using the FFT.


<P>
Given the optional third argument, <VAR>n</VAR>, <CODE>fftfilt</CODE> uses the
overlap-add method to filter <VAR>x</VAR> with <VAR>b</VAR> using an N-point FFT.


<P>
If <VAR>x</VAR> is a matrix, filter each column of the matrix.
</DL>


<P>
@anchor{doc-filter}
<DL>
<DT><U>Loadable Function:</U> y = <B>filter</B> <I>(<VAR>b</VAR>, <VAR>a</VAR>, <VAR>x</VAR>)</I>
<DD><A NAME="IDX1176"></A>
<DT><U>Loadable Function:</U> [<VAR>y</VAR>, <VAR>sf</VAR>] = <B>filter</B> <I>(<VAR>b</VAR>, <VAR>a</VAR>, <VAR>x</VAR>, <VAR>si</VAR>)</I>
<DD><A NAME="IDX1177"></A>
Return the solution to the following linear, time-invariant difference
equation:



<PRE>
   N                   M
  SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1&#60;=n&#60;=length(x)
  k=0                 k=0
</PRE>

<P>
where
 N=length(a)-1 and M=length(b)-1.
An equivalent form of this equation is:



<PRE>
            N                   M
  y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&#60;=n&#60;=length(x)
           k=1                 k=0
</PRE>

<P>
where
 c = a/a(1) and d = b/a(1).


<P>
If the fourth argument <VAR>si</VAR> is provided, it is taken as the
initial state of the system and the final state is returned as
<VAR>sf</VAR>.  The state vector is a column vector whose length is
equal to the length of the longest coefficient vector minus one.
If <VAR>si</VAR> is not supplied, the initial state vector is set to all
zeros.


<P>
In terms of the z-transform, y is the result of passing the discrete-
time signal x through a system characterized by the following rational
system function:



<PRE>
             M
            SUM d(k+1) z^(-k)
            k=0
  H(z) = ----------------------
               N
          1 + SUM c(k+1) z(-k)
              k=1
</PRE>

</DL>

<P>
@anchor{doc-freqz}
<DL>
<DT><U>Function File:</U> [<VAR>h</VAR>, <VAR>w</VAR>] = <B>freqz</B> <I>(<VAR>b</VAR>, <VAR>a</VAR>, <VAR>n</VAR>, "whole")</I>
<DD><A NAME="IDX1178"></A>
Return the complex frequency response <VAR>h</VAR> of the rational IIR filter
whose numerator and denominator coefficients are <VAR>b</VAR> and <VAR>a</VAR>,
respectively.  The response is evaluated at <VAR>n</VAR> angular frequencies
between 0 and
 2*pi.


<P>
The output value <VAR>w</VAR> is a vector of the frequencies.


<P>
If the fourth argument is omitted, the response is evaluated at
frequencies between 0 and
 pi.


<P>
If <VAR>n</VAR> is omitted, a value of 512 is assumed.


<P>
If <VAR>a</VAR> is omitted, the denominator is assumed to be 1 (this
corresponds to a simple FIR filter).


<P>
For fastest computation, <VAR>n</VAR> should factor into a small number of
small primes.


<P>
<DT><U>Function File:</U> <VAR>h</VAR> = <B>freqz</B> <I>(<VAR>b</VAR>, <VAR>a</VAR>, <VAR>w</VAR>)</I>
<DD><A NAME="IDX1179"></A>
Evaluate the response at the specific frequencies in the vector <VAR>w</VAR>.
The values for <VAR>w</VAR> are measured in radians.


<P>
<DT><U>Function File:</U> [...] = <B>freqz</B> <I>(..., <VAR>Fs</VAR>)</I>
<DD><A NAME="IDX1180"></A>
Return frequencies in Hz instead of radians assuming a sampling rate
<VAR>Fs</VAR>.  If you are evaluating the response at specific frequencies 
<VAR>w</VAR>, those frequencies should be requested in Hz rather than radians.


<P>
<DT><U>Function File:</U>  <B>freqz</B> <I>(...)</I>
<DD><A NAME="IDX1181"></A>
Plot the pass band, stop band and phase response of <VAR>h</VAR> rather
than returning them.
</DL>


<P>
@anchor{doc-freqz_plot}
<DL>
<DT><U>Function File:</U> freqz_plot <B>(<VAR>w</VAR>,</B> <I><VAR>h</VAR>)</I>
<DD><A NAME="IDX1182"></A>
Plot the pass band, stop band and phase response of <VAR>h</VAR>.
</DL>


<P>
@anchor{doc-sinc}
<DL>
<DT><U>Function File:</U>  <B>sinc</B> <I>(<VAR>x</VAR>)</I>
<DD><A NAME="IDX1183"></A>
Return
 sin(pi*x)/(pi*x).
</DL>


<P>
@anchor{doc-unwrap}
<DL>
<DT><U>Function File:</U> <VAR>b</VAR> = <B>unwrap</B> <I>(<VAR>a</VAR>, <VAR>tol</VAR>, <VAR>dim</VAR>)</I>
<DD><A NAME="IDX1184"></A>


<P>
Unwrap radian phases by adding multiples of 2*pi as appropriate to
remove jumps greater than <VAR>tol</VAR>.  <VAR>tol</VAR> defaults to pi.


<P>
Unwrap will unwrap along the columns of <VAR>a</VAR> unless the row
dimension of <VAR>a</VAR> is 1 or <VAR>dim</VAR> is given with a
value of 1, when it will unwrap along the row(s).
</DL>


<P>
@anchor{doc-arch_fit}
<DL>
<DT><U>Function File:</U> [<VAR>a</VAR>, <VAR>b</VAR>] = <B>arch_fit</B> <I>(<VAR>y</VAR>, <VAR>x</VAR>, <VAR>p</VAR>, <VAR>iter</VAR>, <VAR>gamma</VAR>, <VAR>a0</VAR>, <VAR>b0</VAR>)</I>
<DD><A NAME="IDX1185"></A>
Fit an ARCH regression model to the time series <VAR>y</VAR> using the
scoring algorithm in Engle's original ARCH paper.  The model is



<PRE>
y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2
</PRE>

<P>
in which <EM>e(t)</EM> is <EM>N(0, h(t))</EM>, given a time-series vector
<VAR>y</VAR> up to time <EM>t-1</EM> and a matrix of (ordinary) regressors
<VAR>x</VAR> up to <EM>t</EM>.  The order of the regression of the residual
variance is specified by <VAR>p</VAR>.


<P>
If invoked as <CODE>arch_fit (<VAR>y</VAR>, <VAR>k</VAR>, <VAR>p</VAR>)</CODE> with a
positive integer <VAR>k</VAR>, fit an ARCH(<VAR>k</VAR>, <VAR>p</VAR>) process,
i.e., do the above with the <EM>t</EM>-th row of <VAR>x</VAR> given by



<PRE>
[1, y(t-1), ..., y(t-k)]
</PRE>

<P>
Optionally, one can specify the number of iterations <VAR>iter</VAR>, the
updating factor <VAR>gamma</VAR>, and initial values <EM>a0</EM> and
<EM>b0</EM> for the scoring algorithm.
</DL>


<P>
@anchor{doc-arch_rnd}
<DL>
<DT><U>Function File:</U>  <B>arch_rnd</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>t</VAR>)</I>
<DD><A NAME="IDX1186"></A>
Simulate an ARCH sequence of length <VAR>t</VAR> with AR
coefficients <VAR>b</VAR> and CH coefficients <VAR>a</VAR>.  I.e., the result
<EM>y(t)</EM> follows the model



<PRE>
y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),
</PRE>

<P>
where <EM>e(t)</EM>, given <VAR>y</VAR> up to time <EM>t-1</EM>, is
<EM>N(0, h(t))</EM>, with



<PRE>
h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
</PRE>

</DL>

<P>
@anchor{doc-arch_test}
<DL>
<DT><U>Function File:</U> [<VAR>pval</VAR>, <VAR>lm</VAR>] = <B>arch_test</B> <I>(<VAR>y</VAR>, <VAR>x</VAR>, <VAR>p</VAR>)</I>
<DD><A NAME="IDX1187"></A>
For a linear regression model



<PRE>
y = x * b + e
</PRE>

<P>
perform a Lagrange Multiplier (LM) test of the null hypothesis of no
conditional heteroscedascity against the alternative of CH(<VAR>p</VAR>).


<P>
I.e., the model is



<PRE>
y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
</PRE>

<P>
given <VAR>y</VAR> up to <EM>t-1</EM> and <VAR>x</VAR> up to <EM>t</EM>,
<EM>e</EM>(t) is <EM>N(0, h(t))</EM> with



<PRE>
h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,
</PRE>

<P>
and the null is <EM>a(1)</EM> == ... == <EM>a(p)</EM> == 0.


<P>
If the second argument is a scalar integer, <EM>k</EM>, perform the same
test in a linear autoregression model of order <EM>k</EM>, i.e., with



<PRE>
[1, y(t-1), ..., y(t-<VAR>k</VAR>)]
</PRE>

<P>
as the <EM>t</EM>-th row of <VAR>x</VAR>.


<P>
Under the null, LM approximately has a chisquare distribution with
<VAR>p</VAR> degrees of freedom and <VAR>pval</VAR> is the <EM>p</EM>-value (1
minus the CDF of this distribution at LM) of the test.


<P>
If no output argument is given, the <EM>p</EM>-value is displayed.
</DL>


<P>
@anchor{doc-arma_rnd}
<DL>
<DT><U>Function File:</U>  <B>arma_rnd</B> <I>(<VAR>a</VAR>, <VAR>b</VAR>, <VAR>v</VAR>, <VAR>t</VAR>, <VAR>n</VAR>)</I>
<DD><A NAME="IDX1188"></A>
Return a simulation of the ARMA model



<PRE>
x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
     + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)
</PRE>

<P>
in which <VAR>k</VAR> is the length of vector <VAR>a</VAR>, <VAR>l</VAR> is the
length of vector <VAR>b</VAR> and <VAR>e</VAR> is gaussian white noise with
variance <VAR>v</VAR>.  The function returns a vector of length <VAR>t</VAR>.


<P>
The optional parameter <VAR>n</VAR> gives the number of dummy
<VAR>x</VAR>(<VAR>i</VAR>) used for initialization, i.e., a sequence of length
<VAR>t</VAR>+<VAR>n</VAR> is generated and <VAR>x</VAR>(<VAR>n</VAR>+1:<VAR>t</VAR>+<VAR>n</VAR>)
is returned.  If <VAR>n</VAR> is omitted, <VAR>n</VAR> = 100 is used. 
</DL>


<P>
@anchor{doc-autocor}
<DL>
<DT><U>Function File:</U>  <B>autocor</B> <I>(<VAR>x</VAR>, <VAR>h</VAR>)</I>
<DD><A NAME="IDX1189"></A>
Return the autocorrelations from lag 0 to <VAR>h</VAR> of vector <VAR>x</VAR>.
If <VAR>h</VAR> is omitted, all autocorrelations are computed.
If <VAR>x</VAR> is a matrix, the autocorrelations of each column are
computed.
</DL>


<P>
@anchor{doc-autocov}
<DL>
<DT><U>Function File:</U>  <B>autocov</B> <I>(<VAR>x</VAR>, <VAR>h</VAR>)</I>
<DD><A NAME="IDX1190"></A>
Return the autocovariances from lag 0 to <VAR>h</VAR> of vector <VAR>x</VAR>.
If <VAR>h</VAR> is omitted, all autocovariances are computed.
If <VAR>x</VAR> is a matrix, the autocovariances of each column are
computed.
</DL>


<P>
@anchor{doc-autoreg_matrix}
<DL>
<DT><U>Function File:</U>  <B>autoreg_matrix</B> <I>(<VAR>y</VAR>, <VAR>k</VAR>)</I>
<DD><A NAME="IDX1191"></A>
Given a time series (vector) <VAR>y</VAR>, return a matrix with ones in the
first column and the first <VAR>k</VAR> lagged values of <VAR>y</VAR> in the
other columns.  I.e., for <VAR>t</VAR> &#62; <VAR>k</VAR>, <CODE>[1,
<VAR>y</VAR>(<VAR>t</VAR>-1), ..., <VAR>y</VAR>(<VAR>t</VAR>-<VAR>k</VAR>)]</CODE> is the t-th row
of the result.  The resulting matrix may be used as a regressor matrix
in autoregressions.
</DL>


<P>
@anchor{doc-bartlett}
<DL>
<DT><U>Function File:</U>  <B>bartlett</B> <I>(<VAR>m</VAR>)</I>
<DD><A NAME="IDX1192"></A>
Return the filter coefficients of a Bartlett (triangular) window of
length <VAR>m</VAR>.


<P>
For a definition of the Bartlett window, see e.g. A. V. Oppenheim &#38;
R. W. Schafer, "Discrete-Time Signal Processing".
</DL>


<P>
@anchor{doc-blackman}
<DL>
<DT><U>Function File:</U>  <B>blackman</B> <I>(<VAR>m</VAR>)</I>
<DD><A NAME="IDX1193"></A>
Return the filter coefficients of a Blackman window of length <VAR>m</VAR>.


<P>
For a definition of the  Blackman window, see e.g. A. V. Oppenheim &#38;
R. W. Schafer, "Discrete-Time Signal Processing".
</DL>


<P>
@anchor{doc-diffpara}
<DL>
<DT><U>Function File:</U> [<VAR>d</VAR>, <VAR>dd</VAR>] <B>=</B> <I>diffpara (<VAR>x</VAR>, <VAR>a</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1194"></A>
Return the estimator <VAR>d</VAR> for the differencing parameter of an
integrated time series.


<P>
The frequencies from <EM>[2*pi*a/t, 2*pi*b/T]</EM> are used for the
estimation.  If <VAR>b</VAR> is omitted, the interval
<EM>[2*pi/T, 2*pi*a/T]</EM> is used.  If both <VAR>b</VAR> and <VAR>a</VAR> are
omitted then <EM>a = 0.5 * sqrt (T)</EM> and <EM>b = 1.5 * sqrt (T)</EM>
is used, where <EM>T</EM> is the sample size.  If <VAR>x</VAR> is a matrix,
the differencing parameter of each column is estimated.


<P>
The estimators for all frequencies in the intervals
described above is returned in <VAR>dd</VAR>.  The value of <VAR>d</VAR> is
simply the mean of <VAR>dd</VAR>.


<P>
Reference: Brockwell, Peter J. &#38; Davis, Richard A. Time Series:
Theory and Methods Springer 1987.
</DL>


<P>
@anchor{doc-durbinlevinson}
<DL>
<DT><U>Function File:</U>  <B>durbinlevinson</B> <I>(<VAR>c</VAR>, <VAR>oldphi</VAR>, <VAR>oldv</VAR>)</I>
<DD><A NAME="IDX1195"></A>
Perform one step of the Durbin-Levinson algorithm.


<P>
The vector <VAR>c</VAR> specifies the autocovariances <CODE>[gamma_0, ...,
gamma_t]</CODE> from lag 0 to <VAR>t</VAR>, <VAR>oldphi</VAR> specifies the
coefficients based on <VAR>c</VAR>(<VAR>t</VAR>-1) and <VAR>oldv</VAR> specifies the
corresponding error.


<P>
If <VAR>oldphi</VAR> and <VAR>oldv</VAR> are omitted, all steps from 1 to
<VAR>t</VAR> of the algorithm are performed.
</DL>


<P>
@anchor{doc-fftshift}
<DL>
<DT><U>Function File:</U>  <B>fftshift</B> <I>(<VAR>v</VAR>)</I>
<DD><A NAME="IDX1196"></A>
Perform a shift of the vector <VAR>v</VAR>, for use with the <CODE>fft</CODE>
and <CODE>ifft</CODE> functions, in order the move the frequency 0 to the
center of the vector or matrix.


<P>
If <VAR>v</VAR> is a vector of <EM>N</EM> elements corresponding to <EM>N</EM>
time samples spaced of <EM>Dt</EM> each, then <CODE>fftshift (fft
(<VAR>v</VAR>))</CODE> corresponds to frequencies



<PRE>
f = ((1:N) - ceil(N/2)) / N / Dt
</PRE>

<P>
If <VAR>v</VAR> is a matrix, the same holds for rows and columns.
</DL>


<P>
@anchor{doc-fractdiff}
<DL>
<DT><U>Function File:</U>  <B>fractdiff</B> <I>(<VAR>x</VAR>, <VAR>d</VAR>)</I>
<DD><A NAME="IDX1197"></A>
Compute the fractional differences <EM>(1-L)^d x</EM> where <EM>L</EM>
denotes the lag-operator and <EM>d</EM> is greater than -1.
</DL>


<P>
@anchor{doc-hamming}
<DL>
<DT><U>Function File:</U>  <B>hamming</B> <I>(<VAR>m</VAR>)</I>
<DD><A NAME="IDX1198"></A>
Return the filter coefficients of a Hamming window of length <VAR>m</VAR>.


<P>
For a definition of the Hamming window, see e.g. A. V. Oppenheim &#38;
R. W. Schafer, "Discrete-Time Signal Processing".
</DL>


<P>
@anchor{doc-hanning}
<DL>
<DT><U>Function File:</U>  <B>hanning</B> <I>(<VAR>m</VAR>)</I>
<DD><A NAME="IDX1199"></A>
Return the filter coefficients of a Hanning window of length <VAR>m</VAR>.


<P>
For a definition of this window type, see e.g. A. V. Oppenheim &#38;
R. W. Schafer, "Discrete-Time Signal Processing".
</DL>


<P>
@anchor{doc-hurst}
<DL>
<DT><U>Function File:</U>  <B>hurst</B> <I>(<VAR>x</VAR>)</I>
<DD><A NAME="IDX1200"></A>
Estimate the Hurst parameter of sample <VAR>x</VAR> via the rescaled range
statistic.  If <VAR>x</VAR> is a matrix, the parameter is estimated for
every single column.
</DL>


<P>
@anchor{doc-periodogram}
<DL>
<DT><U>Function File:</U>  <B>periodogram</B> <I>(<VAR>x</VAR>)</I>
<DD><A NAME="IDX1201"></A>
For a data matrix <VAR>x</VAR> from a sample of size <VAR>n</VAR>, return the
periodogram.
</DL>


<P>
@anchor{doc-rectangle_lw}
<DL>
<DT><U>Function File:</U>  <B>rectangle_lw</B> <I>(<VAR>n</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1202"></A>
Rectangular lag window. Subfunction used for spectral density
estimation.
</DL>


<P>
@anchor{doc-rectangle_sw}
<DL>
<DT><U>Function File:</U>  <B>rectangle_sw</B> <I>(<VAR>n</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1203"></A>
Rectangular spectral window.  Subfunction used for spectral density
estimation.
</DL>


<P>
@anchor{doc-sinetone}
<DL>
<DT><U>Function File:</U>  <B>sinetone</B> <I>(<VAR>freq</VAR>, <VAR>rate</VAR>, <VAR>sec</VAR>, <VAR>ampl</VAR>)</I>
<DD><A NAME="IDX1204"></A>
Return a sinetone of frequency <VAR>freq</VAR> with length of <VAR>sec</VAR>
seconds at sampling rate <VAR>rate</VAR> and with amplitude <VAR>ampl</VAR>.
The arguments <VAR>freq</VAR> and <VAR>ampl</VAR> may be vectors of common size.


<P>
Defaults are <VAR>rate</VAR> = 8000, <VAR>sec</VAR> = 1 and <VAR>ampl</VAR> = 64.
</DL>


<P>
@anchor{doc-sinewave}
<DL>
<DT><U>Function File:</U>  <B>sinewave</B> <I>(<VAR>m</VAR>, <VAR>n</VAR>, <VAR>d</VAR>)</I>
<DD><A NAME="IDX1205"></A>
Return an <VAR>m</VAR>-element vector with <VAR>i</VAR>-th element given by
<CODE>sin (2 * pi * (<VAR>i</VAR>+<VAR>d</VAR>-1) / <VAR>n</VAR>)</CODE>.


<P>
The default value for <VAR>d</VAR> is 0 and the default value for <VAR>n</VAR>
is <VAR>m</VAR>.
</DL>


<P>
@anchor{doc-spectral_adf}
<DL>
<DT><U>Function File:</U>  <B>spectral_adf</B> <I>(<VAR>c</VAR>, <VAR>win</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1206"></A>
Return the spectral density estimator given a vector of
autocovariances <VAR>c</VAR>, window name <VAR>win</VAR>, and bandwidth,
<VAR>b</VAR>.


<P>
The window name, e.g., <CODE>"triangle"</CODE> or <CODE>"rectangle"</CODE> is
used to search for a function called <CODE><VAR>win</VAR>_sw</CODE>.


<P>
If <VAR>win</VAR> is omitted, the triangle window is used.  If <VAR>b</VAR> is
omitted, <CODE>1 / sqrt (length (<VAR>x</VAR>))</CODE> is used.
</DL>


<P>
@anchor{doc-spectral_xdf}
<DL>
<DT><U>Function File:</U>  <B>spectral_xdf</B> <I>(<VAR>x</VAR>, <VAR>win</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1207"></A>
Return the spectral density estimator given a data vector <VAR>x</VAR>,
window name <VAR>win</VAR>, and bandwidth, <VAR>b</VAR>.


<P>
The window name, e.g., <CODE>"triangle"</CODE> or <CODE>"rectangle"</CODE> is
used to search for a function called <CODE><VAR>win</VAR>_sw</CODE>.


<P>
If <VAR>win</VAR> is omitted, the triangle window is used.  If <VAR>b</VAR> is
omitted, <CODE>1 / sqrt (length (<VAR>x</VAR>))</CODE> is used.
</DL>


<P>
@anchor{doc-spencer}
<DL>
<DT><U>Function File:</U>  <B>spencer</B> <I>(<VAR>x</VAR>)</I>
<DD><A NAME="IDX1208"></A>
Return Spencer's 15 point moving average of every single column of
<VAR>x</VAR>.
</DL>


<P>
@anchor{doc-stft}
<DL>
<DT><U>Function File:</U> [<VAR>y</VAR>, <VAR>c</VAR>] <B>=</B> <I>stft (<VAR>x</VAR>, <VAR>win_size</VAR>, <VAR>inc</VAR>, <VAR>num_coef</VAR>, <VAR>w_type</VAR>)</I>
<DD><A NAME="IDX1209"></A>
Compute the short-term Fourier transform of the vector <VAR>x</VAR> with
<VAR>num_coef</VAR> coefficients by applying a window of <VAR>win_size</VAR> data
points and an increment of <VAR>inc</VAR> points.


<P>
Before computing the Fourier transform, one of the following windows
is applied:


<DL COMPACT>

<DT>hanning
<DD>
w_type = 1
<DT>hamming
<DD>
w_type = 2
<DT>rectangle
<DD>
w_type = 3
</DL>

<P>
The window names can be passed as strings or by the <VAR>w_type</VAR> number.


<P>
If not all arguments are specified, the following defaults are used:
<VAR>win_size</VAR> = 80, <VAR>inc</VAR> = 24, <VAR>num_coef</VAR> = 64, and
<VAR>w_type</VAR> = 1.


<P>
<CODE><VAR>y</VAR> = stft (<VAR>x</VAR>, ...)</CODE> returns the absolute values
of the Fourier coefficients according to the <VAR>num_coef</VAR> positive
frequencies.


<P>
<CODE>[<VAR>y</VAR>, <VAR>c</VAR>] = stft (<CODE>x</CODE>, ...)</CODE> returns the
entire STFT-matrix <VAR>y</VAR> and a 3-element vector <VAR>c</VAR> containing
the window size, increment, and window type, which is needed by the
synthesis function.
</DL>


<P>
@anchor{doc-synthesis}
<DL>
<DT><U>Function File:</U>  <B>synthesis</B> <I>(<VAR>y</VAR>, <VAR>c</VAR>)</I>
<DD><A NAME="IDX1210"></A>
Compute a signal from its short-time Fourier transform <VAR>y</VAR> and a
3-element vector <VAR>c</VAR> specifying window size, increment, and
window type.


<P>
The values <VAR>y</VAR> and <VAR>c</VAR> can be derived by



<PRE>
[<VAR>y</VAR>, <VAR>c</VAR>] = stft (<VAR>x</VAR> , ...)
</PRE>

</DL>

<P>
@anchor{doc-triangle_lw}
<DL>
<DT><U>Function File:</U>  <B>triangle_lw</B> <I>(<VAR>n</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1211"></A>
Triangular lag window. Subfunction used for spectral density
estimation.
</DL>


<P>
@anchor{doc-triangle_sw}
<DL>
<DT><U>Function File:</U>  <B>triangle_sw</B> <I>(<VAR>n</VAR>, <VAR>b</VAR>)</I>
<DD><A NAME="IDX1212"></A>
Triangular spectral window.  Subfunction used for spectral density
estimation.
</DL>


<P>
@anchor{doc-yulewalker}
<DL>
<DT><U>Function File:</U> [<VAR>a</VAR>, <VAR>v</VAR>] = <B>yulewalker</B> <I>(<VAR>c</VAR>)</I>
<DD><A NAME="IDX1213"></A>
Fit an AR (p)-model with Yule-Walker estimates given a vector <VAR>c</VAR>
of autocovariances <CODE>[gamma_0, ..., gamma_p]</CODE>.


<P>
Returns the AR coefficients, <VAR>a</VAR>, and the variance of white
noise, <VAR>v</VAR>.
</DL>


<P><HR><P>
Go to the <A HREF="octave_1.html">first</A>, <A HREF="octave_30.html">previous</A>, <A HREF="octave_32.html">next</A>, <A HREF="octave_45.html">last</A> section, <A HREF="octave_toc.html">table of contents</A>.
</BODY>
</HTML>
