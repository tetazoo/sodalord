This is octave.info, produced by makeinfo version 4.5 from octave.texi.

START-INFO-DIR-ENTRY
* Octave: (octave).	Interactive language for numerical computations.
END-INFO-DIR-ENTRY

   Copyright (C) 1996, 1997 John W. Eaton.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: octave.info,  Node: systime,  Next: sysfreq,  Prev: sysprop,  Up: Control Theory

System Analysis-Time Domain
===========================

 - Function File:  c2d (SYS, OPT, T)
 - Function File:  c2d (SYS, T)
     *Inputs*
    SYS
          system data structure (may have both continuous time and
          discrete time subsystems)

    OPT
          string argument; conversion option (optional argument; may be
          omitted as shown above)
         `"ex"'
               use the matrix exponential (default)

         `"bi"'
               use the bilinear transformation

                   2(z-1)
               s = -----
                   T(z+1)
          FIXME: This option exits with an error if SYS is not purely
          continuous. (The `ex' option can handle mixed systems.)

    T
          sampling time; required if sys is purely continuous.

          *Note* If the 2nd argument is not a string, `c2d' assumes that
          the 2nd argument is T and performs appropriate argument
          checks.

    "MATCHED"
          Use the matched pole/zero equivalent transformation
          (currently only works for purely continuous SISO systems).

     *Outputs* DSYS discrete time equivalent via zero-order hold,
     sample each T sec.

     converts the system data structure describing
          .
          x = Ac x + Bc u
     into a discrete time equivalent model
          x[n+1] = Ad x[n] + Bd u[n]
     via the matrix exponential or bilinear transform

     *Note* This function adds the suffix  `_d' to the names of the new
     discrete states.

 - Function File:  d2c (SYS, TOL)
 - Function File:  d2c (SYS, OPT)
     Convert discrete (sub)system to a purely continuous system.
     Sampling time used is `sysgettsam(SYS)'

     *Inputs*
    SYS
          system data structure with discrete components

    TOL
          Scalar value.  tolerance for convergence of default `"log"'
          option (see below)

    OPT
          conversion option.  Choose from:
         `"log"'
               (default) Conversion is performed via a matrix logarithm.
               Due to some problems with this computation, it is
               followed by a steepest descent algorithm to identify
               continuous time A, B, to get a better fit to the
               original data.

               If called as `d2c (SYS, TOL)', with TOL positive scalar,
               the `"log"' option is used.  The default value for TOL
               is `1e-8'.

         `"bi"'
               Conversion is performed via bilinear transform z = (1 +
               s T / 2)/(1 - s T / 2) where T is the system sampling
               time (see `sysgettsam').

               FIXME: bilinear option exits with an error if SYS is not
               purely discrete
     *Outputs* CSYS continuous time system (same dimensions and
     signal names as in SYS).

 - Function File: [DSYS, FIDX] = dmr2d (SYS, IDX, SPREFIX, TS2, CUFLG)
     convert a multirate digital system to a single rate digital system
     states specified by IDX, SPREFIX are sampled at TS2, all others
     are assumed sampled at TS1 = `sysgettsam (SYS)'.

     *Inputs*
    SYS
          discrete time system; `dmr2d' exits with an error if SYS is
          not discrete

    IDX
          indices or names of states with sampling time
          `sysgettsam(SYS)' (may be empty); see `listidx'

    SPREFIX
          list of string prefixes of states with sampling time
          `sysgettsam(SYS)' (may be empty)

    TS2
          sampling time of states not specified by IDX, SPREFIX must be
          an integer multiple of `sysgettsam(SYS)'

    CUFLG
          "constant u flag" if CUFLG is nonzero then the system inputs
          are assumed to be constant over the revised sampling interval
          TS2.  Otherwise, since the inputs can change during the
          interval T in [k ts2, (k+1) ts2], an additional set of inputs
          is included in the revised B matrix so that these intersample
          inputs may be included in the single-rate system.  default
          CUFLG = 1.

     *Outputs*
    DSYS
          equivalent discrete time system with sampling time TS2.

          The sampling time of sys is updated to TS2.

          if CUFLG=0 then a set of additional inputs is added to the
          system with suffixes _d1, ..., _dn to indicate their delay
          from the starting time k TS2, i.e.  u = [u_1; u_1_d1; ...,
          u_1_dn] where u_1_dk is the input k*ts1 units of time after
          u_1 is sampled. (TS1 is the original sampling time of the
          discrete time system and TS2 = (n+1)*ts1)

    FIDX
          indices of "formerly fast" states specified by IDX and
          SPREFIX; these states are updated to the new (slower)
          sampling interval TS2.

     *WARNING* Not thoroughly tested yet; especially when CUFLG == 0.

 - Function File:  damp (P, TSAM)
     Displays eigenvalues, natural frequencies and damping ratios of
     the eigenvalues of a matrix P or the A-matrix of a system P,
     respectively.  If P is a system, TSAM must not be specified.  If P
     is a matrix and TSAM is specified, eigenvalues of P are assumed to
     be in Z-domain.

 - Function File:  dcgain (SYS, TOL)
     Returns dc-gain matrix. If dc-gain is infinite an empty matrix is
     returned.  The argument TOL is an optional tolerance for the
     condition number of the A-Matrix in SYS (default TOL = 1.0e-10)

 - Function File: [Y, T] = impulse (SYS, INP, TSTOP, N)
     Impulse response for a linear system.  The system can be discrete
     or multivariable (or both).  If no output arguments are specified,
     `impulse' produces a plot or the impulse response data for system
     SYS.

     *Inputs*
    SYS
          System data structure.

    INP
          Index of input being excited

    TSTOP
          The argument TSTOP (scalar value) denotes the time when the
          simulation should end.

    N
          the number of data values.

          Both parameters TSTOP and N can be omitted and will be
          computed from the eigenvalues of the A-Matrix.
     *Outputs* Y, T: impulse response

 - Function File: [Y, T] = step (SYS, INP, TSTOP, N)
     Step response for a linear system.  The system can be discrete or
     multivariable (or both).  If no output arguments are specified,
     `step' produces a plot or the step response data for system SYS.

     *Inputs*
    SYS
          System data structure.

    INP
          Index of input being excited

    TSTOP
          The argument TSTOP (scalar value) denotes the time when the
          simulation should end.

    N
          the number of data values.

          Both parameters TSTOP and N can be omitted and will be
          computed from the eigenvalues of the A-Matrix.
     *Outputs* Y, T: impulse response

     When invoked with the output paramter y the plot is not displayed.


File: octave.info,  Node: sysfreq,  Next: cacsd,  Prev: systime,  Up: Control Theory

System Analysis-Frequency Domain
================================

   *Demonstration/tutorial script*

 - Function File:  frdemo ()
     Octave Controls toolbox demo: Frequency Response demo

 - Function File: [MAG, PHASE, W] = bode (SYS, W, OUT_IDX, IN_IDX)
     If no output arguments are given: produce Bode plots of a system;
     otherwise, compute the frequency response of a system data
     structure

     *Inputs*
    SYS
          a system data structure (must be either purely continuous or
          discrete; see is_digital)

    W
          frequency values for evaluation.

          if SYS is continuous, then bode evaluates G(jw) where G(s) is
          the system transfer function.

          if SYS is discrete, then bode evaluates G(`exp'(jwT)), where
             * T is the system sampling time

             * G(z) is the system transfer function.

          *Default* the default frequency range is selected as follows:
          (These steps are NOT performed if W is specified)
            1. via routine __bodquist__, isolate all poles and zeros
               away from W=0 (JW=0 or `exp'(jwT)=1) and select the
               frequency range based on the breakpoint locations of the
               frequencies.

            2. if SYS is discrete time, the frequency range is limited
                           to jwT in [0,2 pi /T]

            3. A "smoothing" routine is used to ensure that the plot
               phase does not change excessively from point to point
               and that singular points (e.g., crossovers from +/- 180)
               are accurately shown.


    OUT_IDX
    IN_IDX
          The names or indices of outputs and inputs to be used in the
          frequency response.  See `sysprune'.

          *Example*
               bode(sys,[],"y_3",list("u_1","u_4");
     *Outputs*
    MAG
    PHASE
          the magnitude and phase of the frequency response G(jw) or
          G(`exp'(jwT)) at the selected frequency values.

    W
          the vector of frequency values used

     *Notes*
       1. If no output arguments are given, e.g.,
               bode(sys);
          bode plots the results to the screen.  Descriptive labels are
          automatically placed.

          Failure to include a concluding semicolon will yield some
          garbage being printed to the screen (`ans = []').

       2. If the requested plot is for an MIMO system, mag is set to
          ||G(jw)|| or ||G(`exp'(jwT))|| and phase information is not
          computed.

 - Function File: [WMIN, WMAX] = bode_bounds (ZER, POL, DFLG, TSAM)
     Get default range of frequencies based on cutoff frequencies of
     system poles and zeros.  Frequency range is the interval
     [10^wmin,10^wmax]

     Used internally in __freqresp__ (`bode', `nyquist')

 - Function File:  freqchkw (W)
     Used by `__freqresp__' to check that input frequency vector W is
     valid.  Returns boolean value.

 - Function File:  ltifr (A, B, W)
 - Function File:  ltifr (SYS, W)
     Linear time invariant frequency response of single input systems
     *Inputs*
    A
    B
          coefficient matrices of dx/dt = A x + B u

    SYS
          system data structure

    W
          vector of frequencies
     *Outputs* OUT
                                     -1
                      G(s) = (jw I-A) B
     for complex frequencies s = jw.

 - Function File: [REALP, IMAGP, W] = nyquist (SYS, W, OUT_IDX, IN_IDX,
          ATOL)
 - Function File:  nyquist (SYS, W, OUT_IDX, IN_IDX, ATOL)
     Produce Nyquist plots of a system; if no output arguments are
     given, Nyquist plot is printed to the screen.

     Compute the frequency response of a system.  *Inputs* (pass as
     empty to get default values)
    SYS
          system data structure (must be either purely continuous or
          discrete; see is_digital)

    W
          frequency values for evaluation.  if sys is continuous, then
          bode evaluates G(jw) if sys is discrete, then bode evaluates
          G(exp(jwT)), where T is the system sampling time.

    DEFAULT
          the default frequency range is selected as follows: (These
          steps are NOT performed if W is specified)

       1. via routine __bodquist__, isolate all poles and zeros away
          from W=0 (JW=0 or exp(JWT)=1) and select the frequency range
          based on the breakpoint locations of the frequencies.

       2. if SYS is discrete time, the frequency range is limited to
          JWT in [0,2p*pi]

       3. A "smoothing" routine is used to ensure that the plot phase
          does not change excessively from point to point and that
          singular points (e.g., crossovers from +/- 180) are
          accurately shown.
          outputs, inputs: names or indices of the output(s) and
     input(s) to be used in the frequency response; see sysprune.

     *Inputs* (pass as empty to get default values)
    ATOL
          for interactive nyquist plots: atol is a change-in-slope
          tolerance for the of asymptotes (default = 0; 1e-2 is a good
          choice).  This allows the user to "zoom in" on portions of
          the Nyquist plot too small to be seen with large asymptotes.
     *Outputs*
    REALP
    IMAGP
          the real and imaginary parts of the frequency response G(jw)
          or G(exp(jwT)) at the selected frequency values.

    W
          the vector of frequency values used

     If no output arguments are given, nyquist plots the results to the
     screen.  If ATOL != 0 and asymptotes are detected then the user is
     asked interactively if they wish to zoom in (remove asymptotes)
     Descriptive labels are automatically placed.

     Note: if the requested plot is for an MIMO system, a warning
     message is presented; the returned information is of the magnitude
     ||G(jw)|| or ||G(exp(jwT))|| only; phase information is not
     computed.

 - Function File:  tzero (A, B, C, D, OPT)
 - Function File:  tzero (SYS, OPT)
     Compute transmission zeros of a continuous
          .
          x = Ax + Bu
          y = Cx + Du
     or discrete
          x(k+1) = A x(k) + B u(k)
          y(k)   = C x(k) + D u(k)
     system.  *Outputs*
    ZER
          transmission zeros of the system

    GAIN
          leading coefficient (pole-zero form) of SISO transfer function
          returns gain=0 if system is multivariable
     *References*
       1. Emami-Naeini and Van Dooren, Automatica, 1982.

       2. Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg.
          Appl.

 - Function File:  tzero2 (A, B, C, D, BAL)
     Compute the transmission zeros of a, b, c, d.

     bal = balancing option (see balance); default is "B".

     Needs to incorporate `mvzero' algorithm to isolate finite zeros;
     use `tzero' instead.


File: octave.info,  Node: cacsd,  Next: misc,  Prev: sysfreq,  Up: Control Theory

Controller Design
=================

 - Function File:  dgkfdemo ()
     Octave Controls toolbox demo: H2/Hinfinity options demos

 - Function File:  hinfdemo ()
     H_infinity design demos for continuous SISO and MIMO systems and a
     discrete system.  The SISO system is difficult to control because
     it is non minimum phase and unstable.  The second design example
     controls the "jet707" plant, the linearized state space model of a
     Boeing 707-321 aircraft at v=80m/s (M = 0.26, Ga0 = -3 deg, alpha0
     = 4 deg, kappa = 50 deg).  Inputs: (1) thrust and (2) elevator
     angle outputs: (1) airspeed and (2) pitch angle. The discrete
     system is a stable and second order.

    SISO plant
                               s - 2
                    G(s) = --------------
                           (s + 2)(s - 1)
               
                                             +----+
                        -------------------->| W1 |---> v1
                    z   |                    +----+
                    ----|-------------+                   || T   ||     => min.
                        |             |                       vz   infty
                        |    +---+    v   y  +----+
                      u *--->| G |--->O--*-->| W2 |---> v2
                        |    +---+       |   +----+
                        |                |
                        |    +---+       |
                        -----| K |<-------
                             +---+
          W1 und W2 are the robustness and performance weighting
          functions

    MIMO plant
          The optimal controller minimizes the H_infinity norm of the
          augmented plant P (mixed-sensitivity problem):
                    w
                     1 -----------+
                                  |                   +----+
                              +---------------------->| W1 |----> z1
                    w         |   |                   +----+
                     2 ------------------------+
                              |   |            |
                              |   v   +----+   v      +----+
                           +--*-->o-->| G  |-->o--*-->| W2 |---> z2
                           |          +----+      |   +----+
                           |                      |
                           ^                      v
                            u (from                 y (to K)
                              controller
                              K)
               
               
                                 +    +           +    +
                                 | z  |           | w  |
                                 |  1 |           |  1 |
                                 | z  | = [ P ] * | w  |
                                 |  2 |           |  2 |
                                 | y  |           | u  |
                                 +    +           +    +

    DISCRETE SYSTEM
          This is not a true discrete design. The design is carried out
          in continuous time while the effect of sampling is described
          by a bilinear transformation of the sampled system.  This
          method works quite well if the sampling period is "small"
          compared to the plant time constants.

    The continuous plant
                                  1
                    G (s) = --------------
                     k      (s + 2)(s + 1)
          is discretised with a ZOH (Sampling period = Ts = 1
          second):

                              0.199788z + 0.073498
                    G(s) = --------------------------
                           (z - 0.36788)(z - 0.13534)
               
                                             +----+
                        -------------------->| W1 |---> v1
                    z   |                    +----+
                    ----|-------------+                   || T   ||     => min.
                        |             |                       vz   infty
                        |    +---+    v      +----+
                        *--->| G |--->O--*-->| W2 |---> v2
                        |    +---+       |   +----+
                        |                |
                        |    +---+       |
                        -----| K |<-------
                             +---+
          W1 and W2 are the robustness and performancs weighting
          functions

 - Function File: [L, M, P, E] = dlqe (A, G, C, SIGW, SIGV, Z)
     Construct the linear quadratic estimator (Kalman filter) for the
     discrete time system

          x[k+1] = A x[k] + B u[k] + G w[k]
            y[k] = C x[k] + D u[k] + v[k]

     where W, V are zero-mean gaussian noise processes with respective
     intensities `SIGW = cov (W, W)' and `SIGV = cov (V, V)'.

     If specified, Z is `cov (W, V)'.  Otherwise `cov (W, V) = 0'.

     The observer structure is

          z[k|k] = z[k|k-1] + L (y[k] - C z[k|k-1] - D u[k])
          z[k+1|k] = A z[k|k] + B u[k]

     The following values are returned:

    L
          The observer gain, (A - ALC).  is stable.

    M
          The Riccati equation solution.

    P
          The estimate error covariance after the measurement update.

    E
          The closed loop poles of (A - ALC).

 - Function File: [K, P, E] = dlqr (A, B, Q, R, Z)
     Construct the linear quadratic regulator for the discrete time
     system

          x[k+1] = A x[k] + B u[k]

     to minimize the cost functional

          J = Sum (x' Q x + u' R u)

     Z omitted or

          J = Sum (x' Q x + u' R u + 2 x' Z u)

     Z included.

     The following values are returned:

    K
          The state feedback gain, (A - BK) is stable.

    P
          The solution of algebraic Riccati equation.

    E
          The closed loop poles of (A - BK).

 - Function File: [LP, LF, P, Z] = dkalman (A, G, C, QW, RV, S)
     Construct the linear quadratic estimator (Kalman predictor) for the
     discrete time system

          x[k+1] = A x[k] + B u[k] + G w[k]
            y[k] = C x[k] + D u[k] + v[k]

     where W, V are zero-mean gaussian noise processes with respective
     intensities `QW = cov (W, W)' and `RV = cov (V, V)'.

     If specified, S is `cov (W, V)'.  Otherwise `cov (W, V) = 0'.

     The observer structure is

          x[k+1|k] = A x[k|k-1] + B u[k] + LP (y[k] - C x[k|k-1] - D u[k])
          x[k|k] = x[k|k-1] + LF (y[k] - C x[k|k-1] - D u[k])

     The following values are returned:

    LP
          The predictor gain, (A - LP C) is stable.

    LF
          The filter gain.

    P
          The Riccati solution.

          P = E [(x - x[n|n-1])(x - x[n|n-1])']

    Z
          The updated error covariance matrix.

          Z = E [(x - x[n|n])(x - x[n|n])']

 - Function File: [K , GAIN, KC, KF, PC, PF] = h2syn (ASYS, NU, NY, TOL)
     Design H2 optimal controller per procedure in Doyle, Glover,
     Khargonekar, Francis, "State Space Solutions to Standard H2 and
     Hinf Control Problems", IEEE TAC August 1989

     Discrete time control per Zhou, Doyle, and Glover, ROBUST AND
     OPTIMAL CONTROL, Prentice-Hall, 1996

     *Inputs* input system is passed as either
    ASYS
          system data structure (see ss, sys2ss)
             * controller is implemented for continuous time systems

             * controller is NOT implemented for discrete time systems

    NU
          number of controlled inputs

    NY
          number of measured outputs

    TOL
          threshhold for 0.  Default: 200*eps

     *Outputs*
    K
          system controller

    GAIN
          optimal closed loop gain

    KC
          full information control (packed)

    KF
          state estimator (packed)

    PC
          ARE solution matrix for regulator subproblem

    PF
          ARE solution matrix for filter subproblem

 - Function File:  hinf_ctr (DGS, F, H, Z, G)
     Called by `hinfsyn' to compute the H_inf optimal controller.

     *Inputs*
    DGS
          data structure returned by `is_dgkf'

    F
    H
          feedback and filter gain (not partitioned)

    G
          final gamma value
     *Outputs* controller (system data structure)

     Do not attempt to use this at home; no argument checking performed.

 - Function File: [K, G, GW, XINF, YINF] = hinfsyn (ASYS, NU, NY, GMIN,
          GMAX, GTOL, PTOL, TOL)
     *Inputs* input system is passed as either
    ASYS
          system data structure (see ss, sys2ss)
             * controller is implemented for continuous time systems

             * controller is NOT implemented for discrete time systems
               (see bilinear transforms in `c2d', `d2c')

    NU
          number of controlled inputs

    NY
          number of measured outputs

    GMIN
          initial lower bound on H-infinity optimal gain

    GMAX
          initial upper bound on H-infinity optimal gain

    GTOL
          gain threshhold.  Routine quits when gmax/gmin < 1+tol

    PTOL
          poles with abs(real(pole)) < ptol*||H|| (H is appropriate
          Hamiltonian) are considered to be on the imaginary axis.
          Default: 1e-9

    TOL
          threshhold for 0.  Default: 200*eps

          GMAX, MIN, TOL, and TOL must all be postive scalars.
     *Outputs*
    K
          system controller

    G
          designed gain value

    GW
          closed loop system

    XINF
          ARE solution matrix for regulator subproblem

    YINF
          ARE solution matrix for filter subproblem

       1. Doyle, Glover, Khargonekar, Francis, "State Space Solutions
          to Standard H2 and Hinf Control Problems," IEEE TAC August
          1989

       2. Maciejowksi, J.M., "Multivariable feedback design,"
          Addison-Wesley, 1989, ISBN 0-201-18243-2

       3. Keith Glover and John C. Doyle, "State-space formulae for all
          stabilizing controllers that satisfy and h-infinity-norm bound
          and relations to risk sensitivity," Systems & Control Letters
          11, Oct. 1988, pp 167-172.

 - Function File: [RETVAL, PC, PF] = hinfsyn_chk (A, B1, B2, C1, C2,
          D12, D21, G, PTOL)
     Called by `hinfsyn' to see if gain G satisfies conditions in
     Theorem 3 of Doyle, Glover, Khargonekar, Francis, "State Space
     Solutions to Standard H2 and Hinf Control Problems", IEEE TAC
     August 1989

     *Warning* Do not attempt to use this at home; no argument checking
     performed.

     *Inputs* as returned by `is_dgkf', except for:
    G
          candidate gain level

    PTOL
          as in `hinfsyn'

     *Outputs*
    RETVAL
          1 if g exceeds optimal Hinf closed loop gain, else 0

    PC
          solution of "regulator" H-inf ARE

    PF
          solution of "filter" H-inf ARE
     Do not attempt to use this at home; no argument checking performed.

 - Function File: [XINF, X_HA_ERR] = hinfsyn_ric (A, BB, C1, D1DOT, R,
          PTOL)
     Forms
          xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
          Ha = [A 0*A; -C1'*C1 -A'] - xx;
     and solves associated Riccati equation.  The error code X_HA_ERR
     indicates one of the following conditions:
    0
          successful

    1
          XINF has imaginary eigenvalues

    2
          HX not Hamiltonian

    3
          XINF has infinite eigenvalues (numerical overflow)

    4
          XINF not symmetric

    5
          XINF not positive definite

    6
          R is singular

 - Function File: [K, P, E] = lqe (A, G, C, SIGW, SIGV, Z)
     Construct the linear quadratic estimator (Kalman filter) for the
     continuous time system

          dx
          -- = a x + b u
          dt
          
          y = c x + d u

     where W and V are zero-mean gaussian noise processes with
     respective intensities

          sigw = cov (w, w)
          sigv = cov (v, v)

     The optional argument Z is the cross-covariance `cov (W, V)'.  If
     it is omitted, `cov (W, V) = 0' is assumed.

     Observer structure is `dz/dt = A z + B u + k (y - C z - D u)'

     The following values are returned:

    K
          The observer gain, (A - KC) is stable.

    P
          The solution of algebraic Riccati equation.

    E
          The vector of closed loop poles of (A - KC).

 - Function File: [K, Q1, P1, EE, ER] = lqg (SYS, SIGW, SIGV, Q, R,
          IN_IDX)
     Design a linear-quadratic-gaussian optimal controller for the
     system
          dx/dt = A x + B u + G w       [w]=N(0,[Sigw 0    ])
              y = C x + v               [v]  (    0   Sigv ])
     or
          x(k+1) = A x(k) + B u(k) + G w(k)       [w]=N(0,[Sigw 0    ])
            y(k) = C x(k) + v(k)                  [v]  (    0   Sigv ])

     *Inputs*
    SYS
          system data structure

    SIGW
    SIGV
          intensities of independent Gaussian noise processes (as above)

    Q
    R
          state, control weighting respectively.  Control ARE is

    IN_IDX
          names or indices of controlled inputs (see `sysidx',
          `listidx')

          default: last dim(R) inputs are assumed to be controlled
          inputs, all others are assumed to be noise inputs.
     *Outputs*
    K
          system data structure format LQG optimal controller (Obtain
          A,B,C matrices with `sys2ss', `sys2tf', or `sys2zp' as
          appropriate)

    P1
          Solution of control (state feedback) algebraic Riccati
          equation

    Q1
          Solution of estimation algebraic Riccati equation

    EE
          estimator poles

    ES
          controller poles

 - Function File: [K, P, E] = lqr (A, B, Q, R, Z)
     construct the linear quadratic regulator for the continuous time
     system

          dx
          -- = A x + B u
          dt

     to minimize the cost functional

                infinity
                /
            J = |  x' Q x + u' R u
               /
              t=0

     Z omitted or

                infinity
                /
            J = |  x' Q x + u' R u + 2 x' Z u
               /
              t=0

     Z included.

     The following values are returned:

    K
          The state feedback gain, (A - BK) is stable and minimizes the
          cost functional

    P
          The stabilizing solution of appropriate algebraic Riccati
          equation.

    E
          The vector of the closed loop poles of (A - BK).

     *Reference* Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC
     METHODS, Prentice-Hall, 1990, pp. 56-58

 - Function File:  lsim (SYS, U, T, X0)
     Produce output for a linear simulation of a system

     Produces a plot for the output of the system, sys.

     U is an array that contains the system's inputs.  Each row in u
     corresponds to a different time step.  Each column in u
     corresponds to a different input.  T is an array that contains the
     time index of the system.  T should be regularly spaced.  If
     initial conditions are required on the system, the x0 vector
     should be added to the argument list.

     When the lsim function is invoked with output parameters: [y,x] =
     lsim(sys,u,t,[x0]) a plot is not displayed, however, the data is
     returned in y = system output and x = system states.

 - Function File:  place (SYS, P)
     Computes the matrix  K such that if the state is feedback with
     gain K, then the eigenvalues  of the closed loop system (i.e.
     A-BK) are those specified in the vector P.

     Version: Beta (May-1997): If you have any comments, please let me
     know.  (see the file place.m for my address)


File: octave.info,  Node: misc,  Prev: cacsd,  Up: Control Theory

Miscellaneous Functions (Not yet properly filed/documented)
===========================================================

 - Function File:  axis2dlim (AXDATA)
     determine axis limits for 2-d data(column vectors); leaves a 10%
     margin around the plots.  puts in margins of +/- 0.1 if data is
     one dimensional (or a single point)

     *Inputs* AXDATA nx2 matrix of data [x,y]

     *Outputs* AXVEC vector of axis limits appropriate for call to
     axis() function

 - Function File:  moddemo (INPUTS)
     Octave Controls toolbox demo: Model Manipulations demo

 - Function File:  prompt (INPUTS)
     function prompt([str])
     Prompt user to continue
     str: input string. Default value: "\n ---- Press a key to continue ---"

 - Function File:  rldemo (INPUTS)
     Octave Controls toolbox demo: Root Locus demo

 - Function File:  rlocus (INPUTS)
     [rldata, k] = rlocus(sys[,increment,min_k,max_k])
     Displays root locus plot of the specified SISO system.
     
            -----   ---     --------
        --->| + |---|k|---->| SISO |----------->
            -----   ---     --------        |
            - ^                             |
              |_____________________________|
     
     inputs: sys = system data structure
     min_k, max_k,increment: minimum, maximum values of k and
     the increment used in computing gain values
     Outputs: plots the root locus to the screen.
     rldata: Data points plotted column 1: real values, column 2: imaginary
     values)
     k: gains for real axis break points.

 - Function File:  sortcom (INPUTS)
     [yy,idx] = sortcom(xx[,opt]): sort a complex vector
     xx: complex vector
     opt: sorting option:
      "re": real part (default)
      "mag": by magnitude
      "im": by imaginary part
     
     if opt != "im" then complex conjugate pairs are grouped together,
     a - jb followed by a + jb.
     yy: sorted values
     idx: permutation vector: yy = xx(idx)

 - Function File:  ss2tf (INPUTS)
     [num,den] = ss2tf(a,b,c,d)
     Conversion from tranfer function to state-space.
     The state space system
           .
           x = Ax + Bu
           y = Cx + Du
     
     is converted to a transfer function
     
                     num(s)
               G(s)=-------
                     den(s)
     
     used internally in system data structure format manipulations

 - Function File:  ss2zp (INPUTS)
     Converts a state space representation to a set of poles and zeros.
     
     [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space
     system (a,b,c,d).  K is a gain associated with the zeros.
     
     used internally in system data structure format manipulations

 - Function File:  starp (P, K, NY, NU)

     Redheffer star product or upper/lower LFT, respectively.
     
     
                    +-------+
          --------->|       |--------->
                    |   P   |
               +--->|       |---+  ny
               |    +-------+   |
               +-------------------+
                                |  |
               +----------------+  |
               |                   |
               |    +-------+      |
               +--->|       |------+ nu
                    |   K   |
          --------->|       |--------->
                    +-------+
     
     If ny and nu "consume" all inputs and outputs of K then the result
     is a lower fractional transformation. If ny and nu "consume" all
     inputs and outputs of P then the result is an upper fractional
     transformation.
     
     ny and/or nu may be negative (= negative feedback)

 - Function File:  tf2ss (INPUTS)
     Conversion from tranfer function to state-space.
     The state space system
           .
           x = Ax + Bu
           y = Cx + Du
     
     is obtained from a transfer function
     
                     num(s)
               G(s)=-------
                     den(s)
     
     via the function call [a,b,c,d] = tf2ss(num,den).
     The vector 'den' must contain only one row, whereas the vector 'num'
     may contain as many rows as there are outputs of the system 'y'.
     The state space system matrices obtained from this function will be
     in controllable canonical form as described in "Modern Control Theory",
     [Brogan, 1991].

 - Function File:  tf2zp (INPUTS)
     Converts transfer functions to poles / zeros.

     [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the
     SISO system defined by num/den.  K is a gain associated with the
     system zeros.

 - Function File: [A, B, C, D] = zp2ss (ZER, POL, K)
     Conversion from zero / pole to state space.  *Inputs*
    ZER
    POL
          vectors of (possibly) complex poles and zeros of a transfer
          function.  Complex values must come in conjugate pairs (i.e.,
          x+jy in zer means that x-jy is also in zer)

    K
          real scalar (leading coefficient)
     *Outputs* A, B, C, D The state space system
          .
          x = Ax + Bu
          y = Cx + Du
     is obtained from a vector of zeros and a vector of poles via the
     function call `[a,b,c,d] = zp2ss(zer,pol,k)'.  The vectors `zer'
     and `pol' may either be row or column vectors.  Each zero and pole
     that has an imaginary part must have a conjugate in the list.  The
     number of zeros must not exceed the number of poles.  `k' is
     `zp'-form leading coefficient.

 - Function File: [NUM, DEN] = zp2tf (ZER, POL, K)
     Converts zeros / poles to a transfer function.  *Inputs*
    ZER
    POL
          vectors of (possibly complex) poles and zeros of a transfer
          function.  Complex values should appear in conjugate pairs

    K
          real scalar (leading coefficient)
     `[num,den] = zp2tf(zer,pol,k)' forms the transfer function
     `num/den' from the vectors of poles and zeros.


File: octave.info,  Node: Signal Processing,  Next: Image Processing,  Prev: Control Theory,  Up: Top

Signal Processing
*****************

   I hope that someday Octave will include more signal processing
functions.  If you would like to help improve Octave in this area,
please contact <bug-octave@bevo.che.wisc.edu>.

 - Function File:  detrend (X, P)
     If X is a vector, `detrend (X, P)' removes the best fit of a
     polynomial of order P from the data X.

     If X is a matrix, `detrend (X, P)' does the same for each column
     in X.

     The second argument is optional.  If it is not specified, a value
     of 1 is assumed.  This corresponds to removing a linear trend.

 - Loadable Function:  fft (A, N, DIM)
     Compute the FFT of A using subroutines from FFTPACK. The FFT is
     calculated along the first non-singleton dimension of the array.
     Thus if A is a matrix, `fft (A)' computes the FFT for each column
     of A.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of A to use, or an empty matrix
     to specify that its value should be ignored. If N is larger than
     the dimension along which the FFT is calculated, then A is resized
     and padded with zeros. Otherwise, ifN is smaller than the
     dimension along which the FFT is calculated, then A is truncated.

     If called with three agruments, DIM is an integer specifying the
     dimension of the matrix along which the FFT is performed

 - Loadable Function:  ifft (A, N, DIM)
     Compute the inverse FFT of A using subroutines from FFTPACK. The
     inverse FFT is calculated along the first non-singleton dimension
     of the array. Thus if A is a matrix, `fft (A)' computes the
     inverse FFT for each column of A.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of A to use, or an empty matrix
     to specify that its value should be ignored. If N is larger than
     the dimension along which the inverse FFT is calculated, then A is
     resized and padded with zeros. Otherwise, ifN is smaller than the
     dimension along which the inverse FFT is calculated, then A is
     truncated.

     If called with three agruments, DIM is an integer specifying the
     dimension of the matrix along which the inverse FFT is performed

 - Loadable Function:  fft2 (A, N, M)
     Compute the two dimensional FFT of A using subroutines from
     FFTPACK. The optional arguments N and M may be used specify the
     number of rows and columns of A to use.  If either of these is
     larger than the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated seperately

 - Loadable Function:  fft2 (A, N, M)
     Compute the inverse two dimensional FFT of A using subroutines from
     FFTPACK. The optional arguments N and M may be used specify the
     number of rows and columns of A to use.  If either of these is
     larger than the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated seperately

 - Loadable Function:  fftn (A, SIZE)
     Compute the N dimensional FFT of A using subroutines from FFTPACK.
     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used. If an element of SIZE is
     smaller than the corresponding dimension, then the dimension is
     truncated prior to performing the FFT. Otherwise if an element of
     SIZE is larger than the corresponding dimension A is resized and
     padded with zeros.

 - Loadable Function:  ifftn (A, SIZE)
     Compute the invesre N dimensional FFT of A using subroutines from
     FFTPACK. The optional vector argument SIZE may be used specify the
     dimensions of the array to be used. If an element of SIZE is
     smaller than the corresponding dimension, then the dimension is
     truncated prior to performing the inverse FFT. Otherwise if an
     element of SIZE is larger than the corresponding dimension A is
     resized and padded with zeros.

 - Function File:  fftconv (A, B, N)
     Return the convolution of the vectors A and B, as a vector with
     length equal to the `length (a) + length (b) - 1'.  If A and B are
     the coefficient vectors of two polynomials, the returned value is
     the coefficient vector of the product polynomial.

     The computation uses the FFT by calling the function `fftfilt'.  If
     the optional argument N is specified, an N-point FFT is used.

 - Function File:  fftfilt (B, X, N)
     With two arguments, `fftfilt' filters X with the FIR filter B
     using the FFT.

     Given the optional third argument, N, `fftfilt' uses the
     overlap-add method to filter X with B using an N-point FFT.

     If X is a matrix, filter each column of the matrix.

 - Loadable Function: y = filter (B, A, X)
 - Loadable Function: [Y, SF] = filter (B, A, X, SI)
     Return the solution to the following linear, time-invariant
     difference equation:

             N                   M
            SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)
            k=0                 k=0

     where  N=length(a)-1 and M=length(b)-1.  An equivalent form of
     this equation is:

                      N                   M
            y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
                     k=1                 k=0

     where  c = a/a(1) and d = b/a(1).

     If the fourth argument SI is provided, it is taken as the initial
     state of the system and the final state is returned as SF.  The
     state vector is a column vector whose length is equal to the
     length of the longest coefficient vector minus one.  If SI is not
     supplied, the initial state vector is set to all zeros.

     In terms of the z-transform, y is the result of passing the
     discrete- time signal x through a system characterized by the
     following rational system function:

                       M
                      SUM d(k+1) z^(-k)
                      k=0
            H(z) = ----------------------
                         N
                    1 + SUM c(k+1) z(-k)
                        k=1

 - Function File: [H, W] = freqz (B, A, N, "whole")
     Return the complex frequency response H of the rational IIR filter
     whose numerator and denominator coefficients are B and A,
     respectively.  The response is evaluated at N angular frequencies
     between 0 and  2*pi.

     The output value W is a vector of the frequencies.

     If the fourth argument is omitted, the response is evaluated at
     frequencies between 0 and  pi.

     If N is omitted, a value of 512 is assumed.

     If A is omitted, the denominator is assumed to be 1 (this
     corresponds to a simple FIR filter).

     For fastest computation, N should factor into a small number of
     small primes.

 - Function File: H = freqz (B, A, W)
     Evaluate the response at the specific frequencies in the vector W.
     The values for W are measured in radians.

 - Function File: [...] = freqz (..., FS)
     Return frequencies in Hz instead of radians assuming a sampling
     rate FS.  If you are evaluating the response at specific
     frequencies W, those frequencies should be requested in Hz rather
     than radians.

 - Function File:  freqz (...)
     Plot the pass band, stop band and phase response of H rather than
     returning them.

 - Function File: freqz_plot (W, H)
     Plot the pass band, stop band and phase response of H.

 - Function File:  sinc (X)
     Return  sin(pi*x)/(pi*x).

 - Function File: B = unwrap (A, TOL, DIM)
     Unwrap radian phases by adding multiples of 2*pi as appropriate to
     remove jumps greater than TOL.  TOL defaults to pi.

     Unwrap will unwrap along the columns of A unless the row dimension
     of A is 1 or DIM is given with a value of 1, when it will unwrap
     along the row(s).

 - Function File: [A, B] = arch_fit (Y, X, P, ITER, GAMMA, A0, B0)
     Fit an ARCH regression model to the time series Y using the
     scoring algorithm in Engle's original ARCH paper.  The model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2

     in which e(t) is N(0, h(t)), given a time-series vector Y up to
     time t-1 and a matrix of (ordinary) regressors X up to t.  The
     order of the regression of the residual variance is specified by P.

     If invoked as `arch_fit (Y, K, P)' with a positive integer K, fit
     an ARCH(K, P) process, i.e., do the above with the t-th row of X
     given by

          [1, y(t-1), ..., y(t-k)]

     Optionally, one can specify the number of iterations ITER, the
     updating factor GAMMA, and initial values a0 and b0 for the
     scoring algorithm.

 - Function File:  arch_rnd (A, B, T)
     Simulate an ARCH sequence of length T with AR coefficients B and
     CH coefficients A.  I.e., the result y(t) follows the model

          y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),

     where e(t), given Y up to time t-1, is N(0, h(t)), with

          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2

 - Function File: [PVAL, LM] = arch_test (Y, X, P)
     For a linear regression model

          y = x * b + e

     perform a Lagrange Multiplier (LM) test of the null hypothesis of
     no conditional heteroscedascity against the alternative of CH(P).

     I.e., the model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),

     given Y up to t-1 and X up to t, e(t) is N(0, h(t)) with

          h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,

     and the null is a(1) == ... == a(p) == 0.

     If the second argument is a scalar integer, k, perform the same
     test in a linear autoregression model of order k, i.e., with

          [1, y(t-1), ..., y(t-K)]

     as the t-th row of X.

     Under the null, LM approximately has a chisquare distribution with
     P degrees of freedom and PVAL is the p-value (1 minus the CDF of
     this distribution at LM) of the test.

     If no output argument is given, the p-value is displayed.

 - Function File:  arma_rnd (A, B, V, T, N)
     Return a simulation of the ARMA model

          x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
               + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)

     in which K is the length of vector A, L is the length of vector B
     and E is gaussian white noise with variance V.  The function
     returns a vector of length T.

     The optional parameter N gives the number of dummy X(I) used for
     initialization, i.e., a sequence of length T+N is generated and
     X(N+1:T+N) is returned.  If N is omitted, N = 100 is used.

 - Function File:  autocor (X, H)
     Return the autocorrelations from lag 0 to H of vector X.  If H is
     omitted, all autocorrelations are computed.  If X is a matrix, the
     autocorrelations of each column are computed.

 - Function File:  autocov (X, H)
     Return the autocovariances from lag 0 to H of vector X.  If H is
     omitted, all autocovariances are computed.  If X is a matrix, the
     autocovariances of each column are computed.

 - Function File:  autoreg_matrix (Y, K)
     Given a time series (vector) Y, return a matrix with ones in the
     first column and the first K lagged values of Y in the other
     columns.  I.e., for T > K, `[1, Y(T-1), ..., Y(T-K)]' is the t-th
     row of the result.  The resulting matrix may be used as a
     regressor matrix in autoregressions.

 - Function File:  bartlett (M)
     Return the filter coefficients of a Bartlett (triangular) window of
     length M.

     For a definition of the Bartlett window, see e.g. A. V. Oppenheim &
     R. W. Schafer, "Discrete-Time Signal Processing".

 - Function File:  blackman (M)
     Return the filter coefficients of a Blackman window of length M.

     For a definition of the  Blackman window, see e.g. A. V. Oppenheim
     & R. W. Schafer, "Discrete-Time Signal Processing".

 - Function File: [D, DD] = diffpara (X, A, B)
     Return the estimator D for the differencing parameter of an
     integrated time series.

     The frequencies from [2*pi*a/t, 2*pi*b/T] are used for the
     estimation.  If B is omitted, the interval [2*pi/T, 2*pi*a/T] is
     used.  If both B and A are omitted then a = 0.5 * sqrt (T) and b =
     1.5 * sqrt (T) is used, where T is the sample size.  If X is a
     matrix, the differencing parameter of each column is estimated.

     The estimators for all frequencies in the intervals described
     above is returned in DD.  The value of D is simply the mean of DD.

     Reference: Brockwell, Peter J. & Davis, Richard A. Time Series:
     Theory and Methods Springer 1987.

 - Function File:  durbinlevinson (C, OLDPHI, OLDV)
     Perform one step of the Durbin-Levinson algorithm.

     The vector C specifies the autocovariances `[gamma_0, ...,
     gamma_t]' from lag 0 to T, OLDPHI specifies the coefficients based
     on C(T-1) and OLDV specifies the corresponding error.

     If OLDPHI and OLDV are omitted, all steps from 1 to T of the
     algorithm are performed.

 - Function File:  fftshift (V)
     Perform a shift of the vector V, for use with the `fft' and `ifft'
     functions, in order the move the frequency 0 to the center of the
     vector or matrix.

     If V is a vector of N elements corresponding to N time samples
     spaced of Dt each, then `fftshift (fft (V))' corresponds to
     frequencies

          f = ((1:N) - ceil(N/2)) / N / Dt

     If V is a matrix, the same holds for rows and columns.

 - Function File:  fractdiff (X, D)
     Compute the fractional differences (1-L)^d x where L denotes the
     lag-operator and d is greater than -1.

 - Function File:  hamming (M)
     Return the filter coefficients of a Hamming window of length M.

     For a definition of the Hamming window, see e.g. A. V. Oppenheim &
     R. W. Schafer, "Discrete-Time Signal Processing".

 - Function File:  hanning (M)
     Return the filter coefficients of a Hanning window of length M.

     For a definition of this window type, see e.g. A. V. Oppenheim &
     R. W. Schafer, "Discrete-Time Signal Processing".

 - Function File:  hurst (X)
     Estimate the Hurst parameter of sample X via the rescaled range
     statistic.  If X is a matrix, the parameter is estimated for every
     single column.

 - Function File:  periodogram (X)
     For a data matrix X from a sample of size N, return the
     periodogram.

 - Function File:  rectangle_lw (N, B)
     Rectangular lag window. Subfunction used for spectral density
     estimation.

 - Function File:  rectangle_sw (N, B)
     Rectangular spectral window.  Subfunction used for spectral density
     estimation.

 - Function File:  sinetone (FREQ, RATE, SEC, AMPL)
     Return a sinetone of frequency FREQ with length of SEC seconds at
     sampling rate RATE and with amplitude AMPL.  The arguments FREQ
     and AMPL may be vectors of common size.

     Defaults are RATE = 8000, SEC = 1 and AMPL = 64.

 - Function File:  sinewave (M, N, D)
     Return an M-element vector with I-th element given by `sin (2 * pi
     * (I+D-1) / N)'.

     The default value for D is 0 and the default value for N is M.

 - Function File:  spectral_adf (C, WIN, B)
     Return the spectral density estimator given a vector of
     autocovariances C, window name WIN, and bandwidth, B.

     The window name, e.g., `"triangle"' or `"rectangle"' is used to
     search for a function called `WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     `1 / sqrt (length (X))' is used.

 - Function File:  spectral_xdf (X, WIN, B)
     Return the spectral density estimator given a data vector X,
     window name WIN, and bandwidth, B.

     The window name, e.g., `"triangle"' or `"rectangle"' is used to
     search for a function called `WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     `1 / sqrt (length (X))' is used.

 - Function File:  spencer (X)
     Return Spencer's 15 point moving average of every single column of
     X.

 - Function File: [Y, C] = stft (X, WIN_SIZE, INC, NUM_COEF, W_TYPE)
     Compute the short-term Fourier transform of the vector X with
     NUM_COEF coefficients by applying a window of WIN_SIZE data points
     and an increment of INC points.

     Before computing the Fourier transform, one of the following
     windows is applied:

    hanning
          w_type = 1

    hamming
          w_type = 2

    rectangle
          w_type = 3

     The window names can be passed as strings or by the W_TYPE number.

     If not all arguments are specified, the following defaults are
     used: WIN_SIZE = 80, INC = 24, NUM_COEF = 64, and W_TYPE = 1.

     `Y = stft (X, ...)' returns the absolute values of the Fourier
     coefficients according to the NUM_COEF positive frequencies.

     `[Y, C] = stft (`x', ...)' returns the entire STFT-matrix Y and a
     3-element vector C containing the window size, increment, and
     window type, which is needed by the synthesis function.

 - Function File:  synthesis (Y, C)
     Compute a signal from its short-time Fourier transform Y and a
     3-element vector C specifying window size, increment, and window
     type.

     The values Y and C can be derived by

          [Y, C] = stft (X , ...)

 - Function File:  triangle_lw (N, B)
     Triangular lag window. Subfunction used for spectral density
     estimation.

 - Function File:  triangle_sw (N, B)
     Triangular spectral window.  Subfunction used for spectral density
     estimation.

 - Function File: [A, V] = yulewalker (C)
     Fit an AR (p)-model with Yule-Walker estimates given a vector C of
     autocovariances `[gamma_0, ..., gamma_p]'.

     Returns the AR coefficients, A, and the variance of white noise, V.

